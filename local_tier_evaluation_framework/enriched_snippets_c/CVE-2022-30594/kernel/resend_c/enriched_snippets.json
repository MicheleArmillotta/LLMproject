[
  {
    "function_name": "irq_inject_interrupt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "155-182",
    "snippet": "int irq_inject_interrupt(unsigned int irq)\n{\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint err;\n\n\t/* Try the state injection hardware interface first */\n\tif (!irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true))\n\t\treturn 0;\n\n\t/* That failed, try via the resend mechanism */\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only try to inject when the interrupt is:\n\t *  - not NMI type\n\t *  - activated\n\t */\n\tif ((desc->istate & IRQS_NMI) || !irqd_is_activated(&desc->irq_data))\n\t\terr = -EINVAL;\n\telse\n\t\terr = check_irq_resend(desc, true);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_resend",
          "args": [
            "desc",
            "true"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_resend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
          "lines": "106-135",
          "snippet": "int check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nint check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "&desc->irq_data"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "0"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_irqchip_state",
          "args": [
            "irq",
            "IRQCHIP_STATE_PENDING",
            "true"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_irqchip_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "2833-2869",
          "snippet": "int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,\n\t\t\t  bool val)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_data *data;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn err;\n\n\tdata = irq_desc_get_irq_data(desc);\n\n\tdo {\n\t\tchip = irq_data_get_irq_chip(data);\n\t\tif (WARN_ON_ONCE(!chip)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (chip->irq_set_irqchip_state)\n\t\t\tbreak;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\tdata = data->parent_data;\n#else\n\t\tdata = NULL;\n#endif\n\t} while (data);\n\n\tif (data)\n\t\terr = chip->irq_set_irqchip_state(data, which, val);\n\nout_unlock:\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nint irq_inject_interrupt(unsigned int irq)\n{\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint err;\n\n\t/* Try the state injection hardware interface first */\n\tif (!irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true))\n\t\treturn 0;\n\n\t/* That failed, try via the resend mechanism */\n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only try to inject when the interrupt is:\n\t *  - not NMI type\n\t *  - activated\n\t */\n\tif ((desc->istate & IRQS_NMI) || !irqd_is_activated(&desc->irq_data))\n\t\terr = -EINVAL;\n\telse\n\t\terr = check_irq_resend(desc, true);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "check_irq_resend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "106-135",
    "snippet": "int check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_sw_resend",
          "args": [
            "desc"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "irq_sw_resend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
          "lines": "83-86",
          "snippet": "static int irq_sw_resend(struct irq_desc *desc)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic int irq_sw_resend(struct irq_desc *desc)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_retrigger",
          "args": [
            "desc"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "try_retrigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
          "lines": "89-99",
          "snippet": "static int try_retrigger(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_retrigger)\n\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic int try_retrigger(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_retrigger)\n\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_level",
          "args": [
            "desc"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_level",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "85-88",
          "snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nint check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t/*\n\t * We do not resend level type interrupts. Level type interrupts\n\t * are resent by hardware when they are still active. Clear the\n\t * pending bit so suspend/resume does not get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t/* If the retrigger was successful, mark it with the REPLAY bit */\n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}"
  },
  {
    "function_name": "try_retrigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "89-99",
    "snippet": "static int try_retrigger(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_retrigger)\n\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_chip_retrigger_hierarchy",
          "args": [
            "&desc->irq_data"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "irq_chip_retrigger_hierarchy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1463-1470",
          "snippet": "int irq_chip_retrigger_hierarchy(struct irq_data *data)\n{\n\tfor (data = data->parent_data; data; data = data->parent_data)\n\t\tif (data->chip && data->chip->irq_retrigger)\n\t\t\treturn data->chip->irq_retrigger(data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_chip_retrigger_hierarchy(struct irq_data *data)\n{\n\tfor (data = data->parent_data; data; data = data->parent_data)\n\t\tif (data->chip && data->chip->irq_retrigger)\n\t\t\treturn data->chip->irq_retrigger(data);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_retrigger",
          "args": [
            "&desc->irq_data"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic int try_retrigger(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_retrigger)\n\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "irq_sw_resend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "83-86",
    "snippet": "static int irq_sw_resend(struct irq_desc *desc)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic int irq_sw_resend(struct irq_desc *desc)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "irq_sw_resend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "50-80",
    "snippet": "static int irq_sw_resend(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t/*\n\t * Validate whether this interrupt can be safely injected from\n\t * non interrupt context\n\t */\n\tif (handle_enforce_irqctx(&desc->irq_data))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the interrupt is running in the thread context of the parent\n\t * irq we need to be careful, because we cannot trigger it\n\t * directly.\n\t */\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\t/*\n\t\t * If the parent_irq is valid, we retrigger the parent,\n\t\t * otherwise we do nothing.\n\t\t */\n\t\tif (!desc->parent_irq)\n\t\t\treturn -EINVAL;\n\t\tirq = desc->parent_irq;\n\t}\n\n\t/* Set it pending and activate the softirq: */\n\tset_bit(irq, irqs_resend);\n\ttasklet_schedule(&resend_tasklet);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_schedule",
          "args": [
            "&resend_tasklet"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "__tasklet_schedule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "735-739",
          "snippet": "void __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "irq",
            "irqs_resend"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_enforce_irqctx",
          "args": [
            "&desc->irq_data"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "handle_enforce_irqctx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "458-461",
          "snippet": "static inline bool handle_enforce_irqctx(struct irq_data *data)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline bool handle_enforce_irqctx(struct irq_data *data)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic int irq_sw_resend(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t/*\n\t * Validate whether this interrupt can be safely injected from\n\t * non interrupt context\n\t */\n\tif (handle_enforce_irqctx(&desc->irq_data))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the interrupt is running in the thread context of the parent\n\t * irq we need to be careful, because we cannot trigger it\n\t * directly.\n\t */\n\tif (irq_settings_is_nested_thread(desc)) {\n\t\t/*\n\t\t * If the parent_irq is valid, we retrigger the parent,\n\t\t * otherwise we do nothing.\n\t\t */\n\t\tif (!desc->parent_irq)\n\t\t\treturn -EINVAL;\n\t\tirq = desc->parent_irq;\n\t}\n\n\t/* Set it pending and activate the softirq: */\n\tset_bit(irq, irqs_resend);\n\ttasklet_schedule(&resend_tasklet);\n\treturn 0;\n}"
  },
  {
    "function_name": "resend_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/resend.c",
    "lines": "30-45",
    "snippet": "static void resend_irqs(struct tasklet_struct *unused)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\twhile (!bitmap_empty(irqs_resend, nr_irqs)) {\n\t\tirq = find_first_bit(irqs_resend, nr_irqs);\n\t\tclear_bit(irq, irqs_resend);\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tlocal_irq_disable();\n\t\tdesc->handle_irq(desc);\n\t\tlocal_irq_enable();\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->handle_irq",
          "args": [
            "desc"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "irq",
            "irqs_resend"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "irqs_resend",
            "nr_irqs"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "irqs_resend",
            "nr_irqs"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resend_irqs(struct tasklet_struct *unused)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\twhile (!bitmap_empty(irqs_resend, nr_irqs)) {\n\t\tirq = find_first_bit(irqs_resend, nr_irqs);\n\t\tclear_bit(irq, irqs_resend);\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tlocal_irq_disable();\n\t\tdesc->handle_irq(desc);\n\t\tlocal_irq_enable();\n\t}\n}"
  }
]