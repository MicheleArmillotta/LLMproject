[
  {
    "function_name": "__ww_mutex_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "559-569",
    "snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "!lock->ctx->acquired"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void __ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tif (lock->ctx) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n}"
  },
  {
    "function_name": "__ww_mutex_add_waiter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "488-557",
    "snippet": "static inline int\n__ww_mutex_add_waiter(struct MUTEX_WAITER *waiter,\n\t\t      struct MUTEX *lock,\n\t\t      struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur, *pos = NULL;\n\tbool is_wait_die;\n\n\tif (!ww_ctx) {\n\t\t__ww_waiter_add(lock, waiter, NULL);\n\t\treturn 0;\n\t}\n\n\tis_wait_die = ww_ctx->is_wait_die;\n\n\t/*\n\t * Add the waiter before the first waiter with a higher stamp.\n\t * Waiters without a context are skipped to avoid starving\n\t * them. Wait-Die waiters may die here. Wound-Wait waiters\n\t * never die here, but they are sorted in stamp order and\n\t * may wound the lock holder.\n\t */\n\tfor (cur = __ww_waiter_last(lock); cur;\n\t     cur = __ww_waiter_prev(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_ctx_less(ww_ctx, cur->ww_ctx)) {\n\t\t\t/*\n\t\t\t * Wait-Die: if we find an older context waiting, there\n\t\t\t * is no point in queueing behind it, as we'd have to\n\t\t\t * die the moment it would acquire the lock.\n\t\t\t */\n\t\t\tif (is_wait_die) {\n\t\t\t\tint ret = __ww_mutex_kill(lock, ww_ctx);\n\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = cur;\n\n\t\t/* Wait-Die: ensure younger waiters die. */\n\t\t__ww_mutex_die(lock, cur, ww_ctx);\n\t}\n\n\t__ww_waiter_add(lock, waiter, pos);\n\n\t/*\n\t * Wound-Wait: if we're blocking on a mutex owned by a younger context,\n\t * wound that such that we might proceed.\n\t */\n\tif (!is_wait_die) {\n\t\tstruct ww_mutex *ww = container_of(lock, struct ww_mutex, base);\n\n\t\t/*\n\t\t * See ww_mutex_set_context_fastpath(). Orders setting\n\t\t * MUTEX_FLAG_WAITERS vs the ww->ctx load,\n\t\t * such that either we or the fastpath will wound @ww->ctx.\n\t\t */\n\t\tsmp_mb();\n\t\t__ww_mutex_wound(lock, ww_ctx, ww->ctx);\n\t}\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX_WAITER\trt_mutex_waiter",
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX_WAITER\tmutex_waiter",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ww_mutex_wound",
          "args": [
            "lock",
            "ww_ctx",
            "ww->ctx"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_wound",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "300-340",
          "snippet": "static bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lock",
            "structww_mutex",
            "base"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ww_waiter_add",
          "args": [
            "lock",
            "waiter",
            "pos"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "129-133",
          "snippet": "static inline void\n__ww_waiter_add(struct rt_mutex *lock, struct rt_mutex_waiter *waiter, struct rt_mutex_waiter *pos)\n{\n\t/* RT unconditionally adds the waiter first and then removes it on error */\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\n__ww_waiter_add(struct rt_mutex *lock, struct rt_mutex_waiter *waiter, struct rt_mutex_waiter *pos)\n{\n\t/* RT unconditionally adds the waiter first and then removes it on error */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_mutex_die",
          "args": [
            "lock",
            "cur",
            "ww_ctx"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_die",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "276-291",
          "snippet": "static bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX_WAITER\trt_mutex_waiter",
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX_WAITER\tmutex_waiter",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_mutex_kill",
          "args": [
            "lock",
            "ww_ctx"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_kill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "412-427",
          "snippet": "static __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_ctx_less",
          "args": [
            "ww_ctx",
            "cur->ww_ctx"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_ctx_less",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "227-266",
          "snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_waiter_prev",
          "args": [
            "lock",
            "cur"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_prev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "111-118",
          "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_waiter_last",
          "args": [
            "lock"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_last",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "120-127",
          "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_last(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_last(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_last(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_last(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic inline int\n__ww_mutex_add_waiter(struct MUTEX_WAITER *waiter,\n\t\t      struct MUTEX *lock,\n\t\t      struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur, *pos = NULL;\n\tbool is_wait_die;\n\n\tif (!ww_ctx) {\n\t\t__ww_waiter_add(lock, waiter, NULL);\n\t\treturn 0;\n\t}\n\n\tis_wait_die = ww_ctx->is_wait_die;\n\n\t/*\n\t * Add the waiter before the first waiter with a higher stamp.\n\t * Waiters without a context are skipped to avoid starving\n\t * them. Wait-Die waiters may die here. Wound-Wait waiters\n\t * never die here, but they are sorted in stamp order and\n\t * may wound the lock holder.\n\t */\n\tfor (cur = __ww_waiter_last(lock); cur;\n\t     cur = __ww_waiter_prev(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_ctx_less(ww_ctx, cur->ww_ctx)) {\n\t\t\t/*\n\t\t\t * Wait-Die: if we find an older context waiting, there\n\t\t\t * is no point in queueing behind it, as we'd have to\n\t\t\t * die the moment it would acquire the lock.\n\t\t\t */\n\t\t\tif (is_wait_die) {\n\t\t\t\tint ret = __ww_mutex_kill(lock, ww_ctx);\n\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = cur;\n\n\t\t/* Wait-Die: ensure younger waiters die. */\n\t\t__ww_mutex_die(lock, cur, ww_ctx);\n\t}\n\n\t__ww_waiter_add(lock, waiter, pos);\n\n\t/*\n\t * Wound-Wait: if we're blocking on a mutex owned by a younger context,\n\t * wound that such that we might proceed.\n\t */\n\tif (!is_wait_die) {\n\t\tstruct ww_mutex *ww = container_of(lock, struct ww_mutex, base);\n\n\t\t/*\n\t\t * See ww_mutex_set_context_fastpath(). Orders setting\n\t\t * MUTEX_FLAG_WAITERS vs the ww->ctx load,\n\t\t * such that either we or the fastpath will wound @ww->ctx.\n\t\t */\n\t\tsmp_mb();\n\t\t__ww_mutex_wound(lock, ww_ctx, ww->ctx);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ww_mutex_check_kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "440-475",
    "snippet": "static inline int\n__ww_mutex_check_kill(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t\t      struct ww_acquire_ctx *ctx)\n{\n\tstruct ww_mutex *ww = container_of(lock, struct ww_mutex, base);\n\tstruct ww_acquire_ctx *hold_ctx = READ_ONCE(ww->ctx);\n\tstruct MUTEX_WAITER *cur;\n\n\tif (ctx->acquired == 0)\n\t\treturn 0;\n\n\tif (!ctx->is_wait_die) {\n\t\tif (ctx->wounded)\n\t\t\treturn __ww_mutex_kill(lock, ctx);\n\n\t\treturn 0;\n\t}\n\n\tif (hold_ctx && __ww_ctx_less(ctx, hold_ctx))\n\t\treturn __ww_mutex_kill(lock, ctx);\n\n\t/*\n\t * If there is a waiter in front of us that has a context, then its\n\t * stamp is earlier than ours and we must kill ourself.\n\t */\n\tfor (cur = __ww_waiter_prev(lock, waiter); cur;\n\t     cur = __ww_waiter_prev(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\treturn __ww_mutex_kill(lock, ctx);\n\t}\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX_WAITER\trt_mutex_waiter",
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX_WAITER\tmutex_waiter",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ww_mutex_kill",
          "args": [
            "lock",
            "ctx"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_kill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "412-427",
          "snippet": "static __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_waiter_prev",
          "args": [
            "lock",
            "cur"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_prev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "111-118",
          "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_ctx_less",
          "args": [
            "ctx",
            "hold_ctx"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_ctx_less",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "227-266",
          "snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ww->ctx"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lock",
            "structww_mutex",
            "base"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic inline int\n__ww_mutex_check_kill(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t\t      struct ww_acquire_ctx *ctx)\n{\n\tstruct ww_mutex *ww = container_of(lock, struct ww_mutex, base);\n\tstruct ww_acquire_ctx *hold_ctx = READ_ONCE(ww->ctx);\n\tstruct MUTEX_WAITER *cur;\n\n\tif (ctx->acquired == 0)\n\t\treturn 0;\n\n\tif (!ctx->is_wait_die) {\n\t\tif (ctx->wounded)\n\t\t\treturn __ww_mutex_kill(lock, ctx);\n\n\t\treturn 0;\n\t}\n\n\tif (hold_ctx && __ww_ctx_less(ctx, hold_ctx))\n\t\treturn __ww_mutex_kill(lock, ctx);\n\n\t/*\n\t * If there is a waiter in front of us that has a context, then its\n\t * stamp is earlier than ours and we must kill ourself.\n\t */\n\tfor (cur = __ww_waiter_prev(lock, waiter); cur;\n\t     cur = __ww_waiter_prev(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\treturn __ww_mutex_kill(lock, ctx);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ww_mutex_kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "412-427",
    "snippet": "static __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww_ctx->contending_lock"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lock",
            "structww_mutex",
            "base"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic __always_inline int\n__ww_mutex_kill(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tif (ww_ctx->acquired > 0) {\n#ifdef DEBUG_WW_MUTEXES\n\t\tstruct ww_mutex *ww;\n\n\t\tww = container_of(lock, struct ww_mutex, base);\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock);\n\t\tww_ctx->contending_lock = ww;\n#endif\n\t\treturn -EDEADLK;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ww_mutex_set_context_fastpath",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "377-410",
    "snippet": "static __always_inline void\nww_mutex_set_context_fastpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tww_mutex_lock_acquired(lock, ctx);\n\n\t/*\n\t * The lock->ctx update should be visible on all cores before\n\t * the WAITERS check is done, otherwise contended waiters might be\n\t * missed. The contended waiters will either see ww_ctx == NULL\n\t * and keep spinning, or it will acquire wait_lock, add itself\n\t * to waiter list and sleep.\n\t */\n\tsmp_mb(); /* See comments above and below. */\n\n\t/*\n\t * [W] ww->ctx = ctx\t    [W] MUTEX_FLAG_WAITERS\n\t *     MB\t\t        MB\n\t * [R] MUTEX_FLAG_WAITERS   [R] ww->ctx\n\t *\n\t * The memory barrier above pairs with the memory barrier in\n\t * __ww_mutex_add_waiter() and makes sure we either observe ww->ctx\n\t * and/or !empty list.\n\t */\n\tif (likely(!__ww_mutex_has_waiters(&lock->base)))\n\t\treturn;\n\n\t/*\n\t * Uh oh, we raced in fastpath, check if any of the waiters need to\n\t * die or wound us.\n\t */\n\tlock_wait_lock(&lock->base);\n\t__ww_mutex_check_waiters(&lock->base, ctx);\n\tunlock_wait_lock(&lock->base);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_wait_lock",
          "args": [
            "&lock->base"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_wait_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "152-155",
          "snippet": "static inline void unlock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_unlock(&lock->rtmutex.wait_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_unlock(&lock->rtmutex.wait_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_mutex_check_waiters",
          "args": [
            "&lock->base",
            "ctx"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_check_waiters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "354-371",
          "snippet": "static void\n__ww_mutex_check_waiters(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur;\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\tfor (cur = __ww_waiter_first(lock); cur;\n\t     cur = __ww_waiter_next(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_mutex_die(lock, cur, ww_ctx) ||\n\t\t    __ww_mutex_wound(lock, cur->ww_ctx, ww_ctx))\n\t\t\tbreak;\n\t}\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX_WAITER\trt_mutex_waiter",
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX_WAITER\tmutex_waiter",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic void\n__ww_mutex_check_waiters(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur;\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\tfor (cur = __ww_waiter_first(lock); cur;\n\t     cur = __ww_waiter_next(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_mutex_die(lock, cur, ww_ctx) ||\n\t\t    __ww_mutex_wound(lock, cur->ww_ctx, ww_ctx))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!__ww_mutex_has_waiters(&lock->base)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ww_mutex_has_waiters",
          "args": [
            "&lock->base"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_has_waiters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "141-145",
          "snippet": "static inline bool\n__ww_mutex_has_waiters(struct rt_mutex *lock)\n{\n\treturn rt_mutex_has_waiters(&lock->rtmutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\n__ww_mutex_has_waiters(struct rt_mutex *lock)\n{\n\treturn rt_mutex_has_waiters(&lock->rtmutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_acquired",
          "args": [
            "lock",
            "ctx"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "180-219",
          "snippet": "static __always_inline void\nww_mutex_lock_acquired(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\t/*\n\t * If this WARN_ON triggers, you used ww_mutex_lock to acquire,\n\t * but released with a normal mutex_unlock in this call.\n\t *\n\t * This should never happen, always use ww_mutex_unlock.\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww->ctx);\n\n\t/*\n\t * Not quite done after calling ww_acquire_done() ?\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->done_acquire);\n\n\tif (ww_ctx->contending_lock) {\n\t\t/*\n\t\t * After -EDEADLK you tried to\n\t\t * acquire a different ww_mutex? Bad!\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock != ww);\n\n\t\t/*\n\t\t * You called ww_mutex_lock after receiving -EDEADLK,\n\t\t * but 'forgot' to unlock everything else first?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->acquired > 0);\n\t\tww_ctx->contending_lock = NULL;\n\t}\n\n\t/*\n\t * Naughty, using a different class will lead to undefined behavior!\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->ww_class != ww->ww_class);\n#endif\n\tww_ctx->acquired++;\n\tww->ctx = ww_ctx;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __always_inline void\nww_mutex_lock_acquired(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\t/*\n\t * If this WARN_ON triggers, you used ww_mutex_lock to acquire,\n\t * but released with a normal mutex_unlock in this call.\n\t *\n\t * This should never happen, always use ww_mutex_unlock.\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww->ctx);\n\n\t/*\n\t * Not quite done after calling ww_acquire_done() ?\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->done_acquire);\n\n\tif (ww_ctx->contending_lock) {\n\t\t/*\n\t\t * After -EDEADLK you tried to\n\t\t * acquire a different ww_mutex? Bad!\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock != ww);\n\n\t\t/*\n\t\t * You called ww_mutex_lock after receiving -EDEADLK,\n\t\t * but 'forgot' to unlock everything else first?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->acquired > 0);\n\t\tww_ctx->contending_lock = NULL;\n\t}\n\n\t/*\n\t * Naughty, using a different class will lead to undefined behavior!\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->ww_class != ww->ww_class);\n#endif\n\tww_ctx->acquired++;\n\tww->ctx = ww_ctx;\n}"
        }
      }
    ],
    "contextual_snippet": "static __always_inline void\nww_mutex_set_context_fastpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tww_mutex_lock_acquired(lock, ctx);\n\n\t/*\n\t * The lock->ctx update should be visible on all cores before\n\t * the WAITERS check is done, otherwise contended waiters might be\n\t * missed. The contended waiters will either see ww_ctx == NULL\n\t * and keep spinning, or it will acquire wait_lock, add itself\n\t * to waiter list and sleep.\n\t */\n\tsmp_mb(); /* See comments above and below. */\n\n\t/*\n\t * [W] ww->ctx = ctx\t    [W] MUTEX_FLAG_WAITERS\n\t *     MB\t\t        MB\n\t * [R] MUTEX_FLAG_WAITERS   [R] ww->ctx\n\t *\n\t * The memory barrier above pairs with the memory barrier in\n\t * __ww_mutex_add_waiter() and makes sure we either observe ww->ctx\n\t * and/or !empty list.\n\t */\n\tif (likely(!__ww_mutex_has_waiters(&lock->base)))\n\t\treturn;\n\n\t/*\n\t * Uh oh, we raced in fastpath, check if any of the waiters need to\n\t * die or wound us.\n\t */\n\tlock_wait_lock(&lock->base);\n\t__ww_mutex_check_waiters(&lock->base, ctx);\n\tunlock_wait_lock(&lock->base);\n}"
  },
  {
    "function_name": "__ww_mutex_check_waiters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "354-371",
    "snippet": "static void\n__ww_mutex_check_waiters(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur;\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\tfor (cur = __ww_waiter_first(lock); cur;\n\t     cur = __ww_waiter_next(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_mutex_die(lock, cur, ww_ctx) ||\n\t\t    __ww_mutex_wound(lock, cur->ww_ctx, ww_ctx))\n\t\t\tbreak;\n\t}\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX_WAITER\trt_mutex_waiter",
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX_WAITER\tmutex_waiter",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ww_mutex_wound",
          "args": [
            "lock",
            "cur->ww_ctx",
            "ww_ctx"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_wound",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "300-340",
          "snippet": "static bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_mutex_die",
          "args": [
            "lock",
            "cur",
            "ww_ctx"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_die",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "276-291",
          "snippet": "static bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}",
          "includes": [],
          "macros_used": [
            "#define MUTEX_WAITER\trt_mutex_waiter",
            "#define MUTEX\t\trt_mutex",
            "#define MUTEX_WAITER\tmutex_waiter",
            "#define MUTEX\t\tmutex"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_waiter_next",
          "args": [
            "lock",
            "cur"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "102-109",
          "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_next(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_next(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_next(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_next(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_waiter_first",
          "args": [
            "lock"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_waiter_first",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "93-100",
          "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_first(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_first(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_first(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_first(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_wait_lock_held",
          "args": [
            "lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_wait_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "157-160",
          "snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic void\n__ww_mutex_check_waiters(struct MUTEX *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct MUTEX_WAITER *cur;\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\tfor (cur = __ww_waiter_first(lock); cur;\n\t     cur = __ww_waiter_next(lock, cur)) {\n\n\t\tif (!cur->ww_ctx)\n\t\t\tcontinue;\n\n\t\tif (__ww_mutex_die(lock, cur, ww_ctx) ||\n\t\t    __ww_mutex_wound(lock, cur->ww_ctx, ww_ctx))\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "__ww_mutex_wound",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "300-340",
    "snippet": "static bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "owner"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_ctx_less",
          "args": [
            "hold_ctx",
            "ww_ctx"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_ctx_less",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "227-266",
          "snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_wait_lock_held",
          "args": [
            "lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_wait_lock_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "157-160",
          "snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_mutex_owner",
          "args": [
            "lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_owner",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "135-139",
          "snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct rt_mutex *lock)\n{\n\treturn rt_mutex_owner(&lock->rtmutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct rt_mutex *lock)\n{\n\treturn rt_mutex_owner(&lock->rtmutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#define MUTEX\t\trt_mutex\n#define MUTEX\t\tmutex\n\nstatic bool __ww_mutex_wound(struct MUTEX *lock,\n\t\t\t     struct ww_acquire_ctx *ww_ctx,\n\t\t\t     struct ww_acquire_ctx *hold_ctx)\n{\n\tstruct task_struct *owner = __ww_mutex_owner(lock);\n\n\tlockdep_assert_wait_lock_held(lock);\n\n\t/*\n\t * Possible through __ww_mutex_add_waiter() when we race with\n\t * ww_mutex_set_context_fastpath(). In that case we'll get here again\n\t * through __ww_mutex_check_waiters().\n\t */\n\tif (!hold_ctx)\n\t\treturn false;\n\n\t/*\n\t * Can have !owner because of __mutex_unlock_slowpath(), but if owner,\n\t * it cannot go away because we'll have FLAG_WAITERS set and hold\n\t * wait_lock.\n\t */\n\tif (!owner)\n\t\treturn false;\n\n\tif (ww_ctx->acquired > 0 && __ww_ctx_less(hold_ctx, ww_ctx)) {\n\t\thold_ctx->wounded = 1;\n\n\t\t/*\n\t\t * wake_up_process() paired with set_current_state()\n\t\t * inserts sufficient barriers to make sure @owner either sees\n\t\t * it's wounded in __ww_mutex_check_kill() or has a\n\t\t * wakeup pending to re-read the wounded state.\n\t\t */\n\t\tif (owner != current)\n\t\t\twake_up_process(owner);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "__ww_mutex_die",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "276-291",
    "snippet": "static bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}",
    "includes": [],
    "macros_used": [
      "#define MUTEX_WAITER\trt_mutex_waiter",
      "#define MUTEX\t\trt_mutex",
      "#define MUTEX_WAITER\tmutex_waiter",
      "#define MUTEX\t\tmutex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter->task"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_mutex_wake_waiter",
          "args": [
            "lock",
            "waiter"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "debug_mutex_wake_waiter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
          "lines": "36-42",
          "snippet": "void debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\n\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n}",
          "includes": [
            "#include \"mutex.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\n\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ww_ctx_less",
          "args": [
            "waiter->ww_ctx",
            "ww_ctx"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_ctx_less",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
          "lines": "227-266",
          "snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#define MUTEX_WAITER\trt_mutex_waiter\n#define MUTEX\t\trt_mutex\n#define MUTEX_WAITER\tmutex_waiter\n#define MUTEX\t\tmutex\n\nstatic bool\n__ww_mutex_die(struct MUTEX *lock, struct MUTEX_WAITER *waiter,\n\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tif (!ww_ctx->is_wait_die)\n\t\treturn false;\n\n\tif (waiter->ww_ctx->acquired > 0 && __ww_ctx_less(waiter->ww_ctx, ww_ctx)) {\n#ifndef WW_RT\n\t\tdebug_mutex_wake_waiter(lock, waiter);\n#endif\n\t\twake_up_process(waiter->task);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "__ww_ctx_less",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "227-266",
    "snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "a->task->dl.deadline",
            "b->task->dl.deadline"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "b->task->dl.deadline",
            "a->task->dl.deadline"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "a_prio"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_prio",
          "args": [
            "b_prio"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpupri.c",
          "lines": "43-66",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tswitch (prio) {\n\tcase CPUPRI_INVALID:\n\t\tcpupri = CPUPRI_INVALID;\t/* -1 */\n\t\tbreak;\n\n\tcase 0 ... 98:\n\t\tcpupri = MAX_RT_PRIO-1 - prio;\t/* 1 ... 99 */\n\t\tbreak;\n\n\tcase MAX_RT_PRIO-1:\n\t\tcpupri = CPUPRI_NORMAL;\t\t/*  0 */\n\t\tbreak;\n\n\tcase MAX_RT_PRIO:\n\t\tcpupri = CPUPRI_HIGHER;\t\t/* 100 */\n\t\tbreak;\n\t}\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tswitch (prio) {\n\tcase CPUPRI_INVALID:\n\t\tcpupri = CPUPRI_INVALID;\t/* -1 */\n\t\tbreak;\n\n\tcase 0 ... 98:\n\t\tcpupri = MAX_RT_PRIO-1 - prio;\t/* 1 ... 99 */\n\t\tbreak;\n\n\tcase MAX_RT_PRIO-1:\n\t\tcpupri = CPUPRI_NORMAL;\t\t/*  0 */\n\t\tbreak;\n\n\tcase MAX_RT_PRIO:\n\t\tcpupri = CPUPRI_HIGHER;\t\t/* 100 */\n\t\tbreak;\n\t}\n\n\treturn cpupri;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool\n__ww_ctx_less(struct ww_acquire_ctx *a, struct ww_acquire_ctx *b)\n{\n/*\n * Can only do the RT prio for WW_RT, because task->prio isn't stable due to PI,\n * so the wait_list ordering will go wobbly. rt_mutex re-queues the waiter and\n * isn't affected by this.\n */\n#ifdef WW_RT\n\t/* kernel prio; less is more */\n\tint a_prio = a->task->prio;\n\tint b_prio = b->task->prio;\n\n\tif (rt_prio(a_prio) || rt_prio(b_prio)) {\n\n\t\tif (a_prio > b_prio)\n\t\t\treturn true;\n\n\t\tif (a_prio < b_prio)\n\t\t\treturn false;\n\n\t\t/* equal static prio */\n\n\t\tif (dl_prio(a_prio)) {\n\t\t\tif (dl_time_before(b->task->dl.deadline,\n\t\t\t\t\t   a->task->dl.deadline))\n\t\t\t\treturn true;\n\n\t\t\tif (dl_time_before(a->task->dl.deadline,\n\t\t\t\t\t   b->task->dl.deadline))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/* equal prio */\n\t}\n#endif\n\n\t/* FIFO order tie break -- bigger is younger */\n\treturn (signed long)(a->stamp - b->stamp) > 0;\n}"
  },
  {
    "function_name": "ww_mutex_lock_acquired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "180-219",
    "snippet": "static __always_inline void\nww_mutex_lock_acquired(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\t/*\n\t * If this WARN_ON triggers, you used ww_mutex_lock to acquire,\n\t * but released with a normal mutex_unlock in this call.\n\t *\n\t * This should never happen, always use ww_mutex_unlock.\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww->ctx);\n\n\t/*\n\t * Not quite done after calling ww_acquire_done() ?\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->done_acquire);\n\n\tif (ww_ctx->contending_lock) {\n\t\t/*\n\t\t * After -EDEADLK you tried to\n\t\t * acquire a different ww_mutex? Bad!\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock != ww);\n\n\t\t/*\n\t\t * You called ww_mutex_lock after receiving -EDEADLK,\n\t\t * but 'forgot' to unlock everything else first?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->acquired > 0);\n\t\tww_ctx->contending_lock = NULL;\n\t}\n\n\t/*\n\t * Naughty, using a different class will lead to undefined behavior!\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->ww_class != ww->ww_class);\n#endif\n\tww_ctx->acquired++;\n\tww->ctx = ww_ctx;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww_ctx->ww_class != ww->ww_class"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww_ctx->acquired > 0"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww_ctx->contending_lock != ww"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww_ctx->done_acquire"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "ww->ctx"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static __always_inline void\nww_mutex_lock_acquired(struct ww_mutex *ww, struct ww_acquire_ctx *ww_ctx)\n{\n#ifdef DEBUG_WW_MUTEXES\n\t/*\n\t * If this WARN_ON triggers, you used ww_mutex_lock to acquire,\n\t * but released with a normal mutex_unlock in this call.\n\t *\n\t * This should never happen, always use ww_mutex_unlock.\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww->ctx);\n\n\t/*\n\t * Not quite done after calling ww_acquire_done() ?\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->done_acquire);\n\n\tif (ww_ctx->contending_lock) {\n\t\t/*\n\t\t * After -EDEADLK you tried to\n\t\t * acquire a different ww_mutex? Bad!\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->contending_lock != ww);\n\n\t\t/*\n\t\t * You called ww_mutex_lock after receiving -EDEADLK,\n\t\t * but 'forgot' to unlock everything else first?\n\t\t */\n\t\tDEBUG_LOCKS_WARN_ON(ww_ctx->acquired > 0);\n\t\tww_ctx->contending_lock = NULL;\n\t}\n\n\t/*\n\t * Naughty, using a different class will lead to undefined behavior!\n\t */\n\tDEBUG_LOCKS_WARN_ON(ww_ctx->ww_class != ww->ww_class);\n#endif\n\tww_ctx->acquired++;\n\tww->ctx = ww_ctx;\n}"
  },
  {
    "function_name": "lockdep_assert_wait_lock_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "157-160",
    "snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&lock->rtmutex.wait_lock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void lockdep_assert_wait_lock_held(struct rt_mutex *lock)\n{\n\tlockdep_assert_held(&lock->rtmutex.wait_lock);\n}"
  },
  {
    "function_name": "unlock_wait_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "152-155",
    "snippet": "static inline void unlock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_unlock(&lock->rtmutex.wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&lock->rtmutex.wait_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void unlock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_unlock(&lock->rtmutex.wait_lock);\n}"
  },
  {
    "function_name": "lock_wait_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "147-150",
    "snippet": "static inline void lock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_lock(&lock->rtmutex.wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&lock->rtmutex.wait_lock"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void lock_wait_lock(struct rt_mutex *lock)\n{\n\traw_spin_lock(&lock->rtmutex.wait_lock);\n}"
  },
  {
    "function_name": "__ww_mutex_has_waiters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "141-145",
    "snippet": "static inline bool\n__ww_mutex_has_waiters(struct rt_mutex *lock)\n{\n\treturn rt_mutex_has_waiters(&lock->rtmutex);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_has_waiters",
          "args": [
            "&lock->rtmutex"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_has_waiters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_common.h",
          "lines": "93-96",
          "snippet": "static inline int rt_mutex_has_waiters(struct rt_mutex_base *lock)\n{\n\treturn !RB_EMPTY_ROOT(&lock->waiters.rb_root);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n#include <linux/debug_locks.h>\n\nstatic inline int rt_mutex_has_waiters(struct rt_mutex_base *lock)\n{\n\treturn !RB_EMPTY_ROOT(&lock->waiters.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline bool\n__ww_mutex_has_waiters(struct rt_mutex *lock)\n{\n\treturn rt_mutex_has_waiters(&lock->rtmutex);\n}"
  },
  {
    "function_name": "__ww_mutex_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "135-139",
    "snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct rt_mutex *lock)\n{\n\treturn rt_mutex_owner(&lock->rtmutex);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_owner",
          "args": [
            "&lock->rtmutex"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_owner",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_common.h",
          "lines": "207-210",
          "snippet": "static inline struct task_struct *rt_mutex_owner(struct rt_mutex_base *lock)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n#include <linux/debug_locks.h>\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex_base *lock)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct rt_mutex *lock)\n{\n\treturn rt_mutex_owner(&lock->rtmutex);\n}"
  },
  {
    "function_name": "__ww_waiter_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "129-133",
    "snippet": "static inline void\n__ww_waiter_add(struct rt_mutex *lock, struct rt_mutex_waiter *waiter, struct rt_mutex_waiter *pos)\n{\n\t/* RT unconditionally adds the waiter first and then removes it on error */\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void\n__ww_waiter_add(struct rt_mutex *lock, struct rt_mutex_waiter *waiter, struct rt_mutex_waiter *pos)\n{\n\t/* RT unconditionally adds the waiter first and then removes it on error */\n}"
  },
  {
    "function_name": "__ww_waiter_last",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "120-127",
    "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_last(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_last(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structrt_mutex_waiter",
            "tree_entry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&lock->rtmutex.waiters.rb_root"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_last(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_last(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
  },
  {
    "function_name": "__ww_waiter_prev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "111-118",
    "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structrt_mutex_waiter",
            "tree_entry"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&w->tree_entry"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_prev(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_prev(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
  },
  {
    "function_name": "__ww_waiter_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "102-109",
    "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_next(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_next(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structrt_mutex_waiter",
            "tree_entry"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&w->tree_entry"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_next(struct rt_mutex *lock, struct rt_mutex_waiter *w)\n{\n\tstruct rb_node *n = rb_next(&w->tree_entry);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
  },
  {
    "function_name": "__ww_waiter_first",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "93-100",
    "snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_first(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_first(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structrt_mutex_waiter",
            "tree_entry"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&lock->rtmutex.waiters.rb_root"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "prb_first_valid_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "1981-1989",
          "snippet": "u64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline struct rt_mutex_waiter *\n__ww_waiter_first(struct rt_mutex *lock)\n{\n\tstruct rb_node *n = rb_first(&lock->rtmutex.waiters.rb_root);\n\tif (!n)\n\t\treturn NULL;\n\treturn rb_entry(n, struct rt_mutex_waiter, tree_entry);\n}"
  },
  {
    "function_name": "lockdep_assert_wait_lock_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "83-86",
    "snippet": "static inline void lockdep_assert_wait_lock_held(struct mutex *lock)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&lock->wait_lock"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void lockdep_assert_wait_lock_held(struct mutex *lock)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n}"
  },
  {
    "function_name": "unlock_wait_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "78-81",
    "snippet": "static inline void unlock_wait_lock(struct mutex *lock)\n{\n\traw_spin_unlock(&lock->wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&lock->wait_lock"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void unlock_wait_lock(struct mutex *lock)\n{\n\traw_spin_unlock(&lock->wait_lock);\n}"
  },
  {
    "function_name": "lock_wait_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "73-76",
    "snippet": "static inline void lock_wait_lock(struct mutex *lock)\n{\n\traw_spin_lock(&lock->wait_lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&lock->wait_lock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void lock_wait_lock(struct mutex *lock)\n{\n\traw_spin_lock(&lock->wait_lock);\n}"
  },
  {
    "function_name": "__ww_mutex_has_waiters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "67-71",
    "snippet": "static inline bool\n__ww_mutex_has_waiters(struct mutex *lock)\n{\n\treturn atomic_long_read(&lock->owner) & MUTEX_FLAG_WAITERS;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&lock->owner"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline bool\n__ww_mutex_has_waiters(struct mutex *lock)\n{\n\treturn atomic_long_read(&lock->owner) & MUTEX_FLAG_WAITERS;\n}"
  },
  {
    "function_name": "__ww_mutex_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "61-65",
    "snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct mutex *lock)\n{\n\treturn __mutex_owner(lock);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mutex_owner",
          "args": [
            "lock"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__mutex_owner",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "76-79",
          "snippet": "static inline struct task_struct *__mutex_owner(struct mutex *lock)\n{\n\treturn (struct task_struct *)(atomic_long_read(&lock->owner) & ~MUTEX_FLAGS);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define MUTEX_FLAGS\t\t0x07"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n#define MUTEX_FLAGS\t\t0x07\n\nstatic inline struct task_struct *__mutex_owner(struct mutex *lock)\n{\n\treturn (struct task_struct *)(atomic_long_read(&lock->owner) & ~MUTEX_FLAGS);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline struct task_struct *\n__ww_mutex_owner(struct mutex *lock)\n{\n\treturn __mutex_owner(lock);\n}"
  },
  {
    "function_name": "__ww_waiter_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "52-59",
    "snippet": "static inline void\n__ww_waiter_add(struct mutex *lock, struct mutex_waiter *waiter, struct mutex_waiter *pos)\n{\n\tstruct list_head *p = &lock->wait_list;\n\tif (pos)\n\t\tp = &pos->list;\n\t__mutex_add_waiter(lock, waiter, p);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mutex_add_waiter",
          "args": [
            "lock",
            "waiter",
            "p"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__mutex_add_waiter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "201-210",
          "snippet": "static void\n__mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t   struct list_head *list)\n{\n\tdebug_mutex_add_waiter(lock, waiter, current);\n\n\tlist_add_tail(&waiter->list, list);\n\tif (__mutex_waiter_is_first(lock, waiter))\n\t\t__mutex_set_flag(lock, MUTEX_FLAG_WAITERS);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [
            "#define MUTEX_FLAG_WAITERS\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n#define MUTEX_FLAG_WAITERS\t0x01\n\nstatic void\n__mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t   struct list_head *list)\n{\n\tdebug_mutex_add_waiter(lock, waiter, current);\n\n\tlist_add_tail(&waiter->list, list);\n\tif (__mutex_waiter_is_first(lock, waiter))\n\t\t__mutex_set_flag(lock, MUTEX_FLAG_WAITERS);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void\n__ww_waiter_add(struct mutex *lock, struct mutex_waiter *waiter, struct mutex_waiter *pos)\n{\n\tstruct list_head *p = &lock->wait_list;\n\tif (pos)\n\t\tp = &pos->list;\n\t__mutex_add_waiter(lock, waiter, p);\n}"
  },
  {
    "function_name": "__ww_waiter_last",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "40-50",
    "snippet": "static inline struct mutex_waiter *\n__ww_waiter_last(struct mutex *lock)\n{\n\tstruct mutex_waiter *w;\n\n\tw = list_last_entry(&lock->wait_list, struct mutex_waiter, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "w",
            "&lock->wait_list",
            "list"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&lock->wait_list",
            "structmutex_waiter",
            "list"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct mutex_waiter *\n__ww_waiter_last(struct mutex *lock)\n{\n\tstruct mutex_waiter *w;\n\n\tw = list_last_entry(&lock->wait_list, struct mutex_waiter, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}"
  },
  {
    "function_name": "__ww_waiter_prev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "30-38",
    "snippet": "static inline struct mutex_waiter *\n__ww_waiter_prev(struct mutex *lock, struct mutex_waiter *w)\n{\n\tw = list_prev_entry(w, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "w",
            "&lock->wait_list",
            "list"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_prev_entry",
          "args": [
            "w",
            "list"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct mutex_waiter *\n__ww_waiter_prev(struct mutex *lock, struct mutex_waiter *w)\n{\n\tw = list_prev_entry(w, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}"
  },
  {
    "function_name": "__ww_waiter_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "20-28",
    "snippet": "static inline struct mutex_waiter *\n__ww_waiter_next(struct mutex *lock, struct mutex_waiter *w)\n{\n\tw = list_next_entry(w, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "w",
            "&lock->wait_list",
            "list"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "w",
            "list"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct mutex_waiter *\n__ww_waiter_next(struct mutex *lock, struct mutex_waiter *w)\n{\n\tw = list_next_entry(w, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}"
  },
  {
    "function_name": "__ww_waiter_first",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/ww_mutex.h",
    "lines": "8-18",
    "snippet": "static inline struct mutex_waiter *\n__ww_waiter_first(struct mutex *lock)\n{\n\tstruct mutex_waiter *w;\n\n\tw = list_first_entry(&lock->wait_list, struct mutex_waiter, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "w",
            "&lock->wait_list",
            "list"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&lock->wait_list",
            "structmutex_waiter",
            "list"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct mutex_waiter *\n__ww_waiter_first(struct mutex *lock)\n{\n\tstruct mutex_waiter *w;\n\n\tw = list_first_entry(&lock->wait_list, struct mutex_waiter, list);\n\tif (list_entry_is_head(w, &lock->wait_list, list))\n\t\treturn NULL;\n\n\treturn w;\n}"
  }
]