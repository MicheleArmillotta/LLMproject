[
  {
    "function_name": "kexec_elf_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "388-430",
    "snippet": "int kexec_elf_load(struct kimage *image, struct elfhdr *ehdr,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t struct kexec_buf *kbuf,\n\t\t\t unsigned long *lowest_load_addr)\n{\n\tunsigned long lowest_addr = UINT_MAX;\n\tint ret;\n\tsize_t i;\n\n\t/* Read in the PT_LOAD segments. */\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tunsigned long load_addr;\n\t\tsize_t size;\n\t\tconst struct elf_phdr *phdr;\n\n\t\tphdr = &elf_info->proghdrs[i];\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tsize = phdr->p_filesz;\n\t\tif (size > phdr->p_memsz)\n\t\t\tsize = phdr->p_memsz;\n\n\t\tkbuf->buffer = (void *) elf_info->buffer + phdr->p_offset;\n\t\tkbuf->bufsz = size;\n\t\tkbuf->memsz = phdr->p_memsz;\n\t\tkbuf->buf_align = phdr->p_align;\n\t\tkbuf->buf_min = phdr->p_paddr;\n\t\tkbuf->mem = KEXEC_BUF_MEM_UNKNOWN;\n\t\tret = kexec_add_buffer(kbuf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tload_addr = kbuf->mem;\n\n\t\tif (load_addr < lowest_addr)\n\t\t\tlowest_addr = load_addr;\n\t}\n\n\t*lowest_load_addr = lowest_addr;\n\tret = 0;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_add_buffer",
          "args": [
            "kbuf"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_add_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_file.c",
          "lines": "672-713",
          "snippet": "int kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = arch_kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha2.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/memblock.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha2.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/memblock.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nint kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t/* Currently adding segment this way is allowed only in file mode */\n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Make sure we are not trying to add buffer after allocating\n\t * control pages. All segments need to be placed first before\n\t * any control pages are allocated. As control page allocation\n\t * logic goes through list of segments to make sure there are\n\t * no destination overlaps.\n\t */\n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure minimum alignment needed for segments. */\n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t/* Walk the RAM ranges and allocate a suitable range for the buffer */\n\tret = arch_kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Found a suitable memory range */\n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nint kexec_elf_load(struct kimage *image, struct elfhdr *ehdr,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t struct kexec_buf *kbuf,\n\t\t\t unsigned long *lowest_load_addr)\n{\n\tunsigned long lowest_addr = UINT_MAX;\n\tint ret;\n\tsize_t i;\n\n\t/* Read in the PT_LOAD segments. */\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tunsigned long load_addr;\n\t\tsize_t size;\n\t\tconst struct elf_phdr *phdr;\n\n\t\tphdr = &elf_info->proghdrs[i];\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tsize = phdr->p_filesz;\n\t\tif (size > phdr->p_memsz)\n\t\t\tsize = phdr->p_memsz;\n\n\t\tkbuf->buffer = (void *) elf_info->buffer + phdr->p_offset;\n\t\tkbuf->bufsz = size;\n\t\tkbuf->memsz = phdr->p_memsz;\n\t\tkbuf->buf_align = phdr->p_align;\n\t\tkbuf->buf_min = phdr->p_paddr;\n\t\tkbuf->mem = KEXEC_BUF_MEM_UNKNOWN;\n\t\tret = kexec_add_buffer(kbuf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tload_addr = kbuf->mem;\n\n\t\tif (load_addr < lowest_addr)\n\t\t\tlowest_addr = load_addr;\n\t}\n\n\t*lowest_load_addr = lowest_addr;\n\tret = 0;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "kexec_elf_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "365-378",
    "snippet": "int kexec_elf_probe(const char *buf, unsigned long len)\n{\n\tstruct elfhdr ehdr;\n\tstruct kexec_elf_info elf_info;\n\tint ret;\n\n\tret = kexec_build_elf_info(buf, len, &ehdr, &elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\tkexec_free_elf_info(&elf_info);\n\n\treturn elf_check_arch(&ehdr) ? 0 : -ENOEXEC;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&ehdr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_free_elf_info",
          "args": [
            "&elf_info"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_free_elf_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "319-323",
          "snippet": "void kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nvoid kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kexec_build_elf_info",
          "args": [
            "buf",
            "len",
            "&ehdr",
            "&elf_info"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_build_elf_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "327-362",
          "snippet": "int kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info)\n{\n\tint i;\n\tint ret;\n\n\tret = elf_read_from_buffer(buf, len, ehdr, elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Big endian vmlinux has type ET_DYN. */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\n\t\tpr_err(\"Not an ELF executable.\\n\");\n\t\tgoto error;\n\t} else if (!elf_info->proghdrs) {\n\t\tpr_err(\"No ELF program header.\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t/*\n\t\t * Kexec does not support loading interpreters.\n\t\t * In addition this check keeps us from attempting\n\t\t * to kexec ordinay executables.\n\t\t */\n\t\tif (elf_info->proghdrs[i].p_type == PT_INTERP) {\n\t\t\tpr_err(\"Requires an ELF interpreter.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tkexec_free_elf_info(elf_info);\n\treturn -ENOEXEC;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nint kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info)\n{\n\tint i;\n\tint ret;\n\n\tret = elf_read_from_buffer(buf, len, ehdr, elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Big endian vmlinux has type ET_DYN. */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\n\t\tpr_err(\"Not an ELF executable.\\n\");\n\t\tgoto error;\n\t} else if (!elf_info->proghdrs) {\n\t\tpr_err(\"No ELF program header.\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t/*\n\t\t * Kexec does not support loading interpreters.\n\t\t * In addition this check keeps us from attempting\n\t\t * to kexec ordinay executables.\n\t\t */\n\t\tif (elf_info->proghdrs[i].p_type == PT_INTERP) {\n\t\t\tpr_err(\"Requires an ELF interpreter.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tkexec_free_elf_info(elf_info);\n\treturn -ENOEXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nint kexec_elf_probe(const char *buf, unsigned long len)\n{\n\tstruct elfhdr ehdr;\n\tstruct kexec_elf_info elf_info;\n\tint ret;\n\n\tret = kexec_build_elf_info(buf, len, &ehdr, &elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\tkexec_free_elf_info(&elf_info);\n\n\treturn elf_check_arch(&ehdr) ? 0 : -ENOEXEC;\n}"
  },
  {
    "function_name": "kexec_build_elf_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "327-362",
    "snippet": "int kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info)\n{\n\tint i;\n\tint ret;\n\n\tret = elf_read_from_buffer(buf, len, ehdr, elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Big endian vmlinux has type ET_DYN. */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\n\t\tpr_err(\"Not an ELF executable.\\n\");\n\t\tgoto error;\n\t} else if (!elf_info->proghdrs) {\n\t\tpr_err(\"No ELF program header.\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t/*\n\t\t * Kexec does not support loading interpreters.\n\t\t * In addition this check keeps us from attempting\n\t\t * to kexec ordinay executables.\n\t\t */\n\t\tif (elf_info->proghdrs[i].p_type == PT_INTERP) {\n\t\t\tpr_err(\"Requires an ELF interpreter.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tkexec_free_elf_info(elf_info);\n\treturn -ENOEXEC;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_free_elf_info",
          "args": [
            "elf_info"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "kexec_free_elf_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "319-323",
          "snippet": "void kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nvoid kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Requires an ELF interpreter.\\n\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ELF program header.\\n\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not an ELF executable.\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_read_from_buffer",
          "args": [
            "buf",
            "len",
            "ehdr",
            "elf_info"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "elf_read_from_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "296-314",
          "snippet": "static int elf_read_from_buffer(const char *buf, size_t len,\n\t\t\t\tstruct elfhdr *ehdr,\n\t\t\t\tstruct kexec_elf_info *elf_info)\n{\n\tint ret;\n\n\tret = elf_read_ehdr(buf, len, ehdr);\n\tif (ret)\n\t\treturn ret;\n\n\telf_info->buffer = buf;\n\telf_info->ehdr = ehdr;\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tret = elf_read_phdrs(buf, len, elf_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_from_buffer(const char *buf, size_t len,\n\t\t\t\tstruct elfhdr *ehdr,\n\t\t\t\tstruct kexec_elf_info *elf_info)\n{\n\tint ret;\n\n\tret = elf_read_ehdr(buf, len, ehdr);\n\tif (ret)\n\t\treturn ret;\n\n\telf_info->buffer = buf;\n\telf_info->ehdr = ehdr;\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tret = elf_read_phdrs(buf, len, elf_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nint kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info)\n{\n\tint i;\n\tint ret;\n\n\tret = elf_read_from_buffer(buf, len, ehdr, elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Big endian vmlinux has type ET_DYN. */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\n\t\tpr_err(\"Not an ELF executable.\\n\");\n\t\tgoto error;\n\t} else if (!elf_info->proghdrs) {\n\t\tpr_err(\"No ELF program header.\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t/*\n\t\t * Kexec does not support loading interpreters.\n\t\t * In addition this check keeps us from attempting\n\t\t * to kexec ordinay executables.\n\t\t */\n\t\tif (elf_info->proghdrs[i].p_type == PT_INTERP) {\n\t\t\tpr_err(\"Requires an ELF interpreter.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tkexec_free_elf_info(elf_info);\n\treturn -ENOEXEC;\n}"
  },
  {
    "function_name": "kexec_free_elf_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "319-323",
    "snippet": "void kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf_info",
            "0",
            "sizeof(*elf_info)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_info->proghdrs"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nvoid kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}"
  },
  {
    "function_name": "elf_read_from_buffer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "296-314",
    "snippet": "static int elf_read_from_buffer(const char *buf, size_t len,\n\t\t\t\tstruct elfhdr *ehdr,\n\t\t\t\tstruct kexec_elf_info *elf_info)\n{\n\tint ret;\n\n\tret = elf_read_ehdr(buf, len, ehdr);\n\tif (ret)\n\t\treturn ret;\n\n\telf_info->buffer = buf;\n\telf_info->ehdr = ehdr;\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tret = elf_read_phdrs(buf, len, elf_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_read_phdrs",
          "args": [
            "buf",
            "len",
            "elf_info"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "elf_read_phdrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "251-279",
          "snippet": "static int elf_read_phdrs(const char *buf, size_t len,\n\t\t\t  struct kexec_elf_info *elf_info)\n{\n\tsize_t phdr_size, i;\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\n\t/*\n\t * e_phnum is at most 65535 so calculating the size of the\n\t * program header cannot overflow.\n\t */\n\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\telf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\n\tif (!elf_info->proghdrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tint ret;\n\n\t\tret = elf_read_phdr(buf, len, elf_info, i);\n\t\tif (ret) {\n\t\t\tkfree(elf_info->proghdrs);\n\t\t\telf_info->proghdrs = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_phdrs(const char *buf, size_t len,\n\t\t\t  struct kexec_elf_info *elf_info)\n{\n\tsize_t phdr_size, i;\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\n\t/*\n\t * e_phnum is at most 65535 so calculating the size of the\n\t * program header cannot overflow.\n\t */\n\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\telf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\n\tif (!elf_info->proghdrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tint ret;\n\n\t\tret = elf_read_phdr(buf, len, elf_info, i);\n\t\tif (ret) {\n\t\t\tkfree(elf_info->proghdrs);\n\t\t\telf_info->proghdrs = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_read_ehdr",
          "args": [
            "buf",
            "len",
            "ehdr"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "elf_read_ehdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "119-179",
          "snippet": "static int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\n{\n\tstruct elfhdr *buf_ehdr;\n\n\tif (len < sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Buffer is too small to hold ELF header.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tmemset(ehdr, 0, sizeof(*ehdr));\n\tmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\n\tif (!elf_is_elf_file(ehdr)) {\n\t\tpr_debug(\"No ELF header magic.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tpr_debug(\"Not a supported ELF class.\\n\");\n\t\treturn -ENOEXEC;\n\t} else  if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\n\t\tehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n\t\tpr_debug(\"Not a supported ELF data format.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbuf_ehdr = (struct elfhdr *) buf;\n\tif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Bad ELF header size.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tehdr->e_type      = elf16_to_cpu(ehdr, buf_ehdr->e_type);\n\tehdr->e_machine   = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\n\tehdr->e_version   = elf32_to_cpu(ehdr, buf_ehdr->e_version);\n\tehdr->e_flags     = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\n\tehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\n\tehdr->e_phnum     = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\n\tehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\n\tehdr->e_shnum     = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\n\tehdr->e_shstrndx  = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tehdr->e_entry = elf64_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf64_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf64_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tehdr->e_entry = elf32_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf32_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf32_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\n{\n\tstruct elfhdr *buf_ehdr;\n\n\tif (len < sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Buffer is too small to hold ELF header.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tmemset(ehdr, 0, sizeof(*ehdr));\n\tmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\n\tif (!elf_is_elf_file(ehdr)) {\n\t\tpr_debug(\"No ELF header magic.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tpr_debug(\"Not a supported ELF class.\\n\");\n\t\treturn -ENOEXEC;\n\t} else  if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\n\t\tehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n\t\tpr_debug(\"Not a supported ELF data format.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbuf_ehdr = (struct elfhdr *) buf;\n\tif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Bad ELF header size.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tehdr->e_type      = elf16_to_cpu(ehdr, buf_ehdr->e_type);\n\tehdr->e_machine   = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\n\tehdr->e_version   = elf32_to_cpu(ehdr, buf_ehdr->e_version);\n\tehdr->e_flags     = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\n\tehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\n\tehdr->e_phnum     = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\n\tehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\n\tehdr->e_shnum     = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\n\tehdr->e_shstrndx  = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tehdr->e_entry = elf64_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf64_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf64_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tehdr->e_entry = elf32_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf32_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf32_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_from_buffer(const char *buf, size_t len,\n\t\t\t\tstruct elfhdr *ehdr,\n\t\t\t\tstruct kexec_elf_info *elf_info)\n{\n\tint ret;\n\n\tret = elf_read_ehdr(buf, len, ehdr);\n\tif (ret)\n\t\treturn ret;\n\n\telf_info->buffer = buf;\n\telf_info->ehdr = ehdr;\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tret = elf_read_phdrs(buf, len, elf_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_read_phdrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "251-279",
    "snippet": "static int elf_read_phdrs(const char *buf, size_t len,\n\t\t\t  struct kexec_elf_info *elf_info)\n{\n\tsize_t phdr_size, i;\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\n\t/*\n\t * e_phnum is at most 65535 so calculating the size of the\n\t * program header cannot overflow.\n\t */\n\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\telf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\n\tif (!elf_info->proghdrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tint ret;\n\n\t\tret = elf_read_phdr(buf, len, elf_info, i);\n\t\tif (ret) {\n\t\t\tkfree(elf_info->proghdrs);\n\t\t\telf_info->proghdrs = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_info->proghdrs"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_read_phdr",
          "args": [
            "buf",
            "len",
            "elf_info",
            "i"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "elf_read_phdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "202-243",
          "snippet": "static int elf_read_phdr(const char *buf, size_t len,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t int idx)\n{\n\t/* Override the const in proghdrs, we are the ones doing the loading. */\n\tstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\tconst char *pbuf;\n\tstruct elf_phdr *buf_phdr;\n\n\tpbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\n\tbuf_phdr = (struct elf_phdr *) pbuf;\n\n\tphdr->p_type   = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\n\tphdr->p_flags  = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tphdr->p_offset = elf64_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf64_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf64_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf64_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf64_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf64_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tphdr->p_offset = elf32_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf32_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf32_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf32_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf32_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf32_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_phdr(const char *buf, size_t len,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t int idx)\n{\n\t/* Override the const in proghdrs, we are the ones doing the loading. */\n\tstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\tconst char *pbuf;\n\tstruct elf_phdr *buf_phdr;\n\n\tpbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\n\tbuf_phdr = (struct elf_phdr *) pbuf;\n\n\tphdr->p_type   = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\n\tphdr->p_flags  = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tphdr->p_offset = elf64_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf64_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf64_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf64_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf64_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf64_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tphdr->p_offset = elf32_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf32_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf32_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf32_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf32_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf32_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "phdr_size",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_phdrs(const char *buf, size_t len,\n\t\t\t  struct kexec_elf_info *elf_info)\n{\n\tsize_t phdr_size, i;\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\n\t/*\n\t * e_phnum is at most 65535 so calculating the size of the\n\t * program header cannot overflow.\n\t */\n\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\telf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\n\tif (!elf_info->proghdrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tint ret;\n\n\t\tret = elf_read_phdr(buf, len, elf_info, i);\n\t\tif (ret) {\n\t\t\tkfree(elf_info->proghdrs);\n\t\t\telf_info->proghdrs = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_read_phdr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "202-243",
    "snippet": "static int elf_read_phdr(const char *buf, size_t len,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t int idx)\n{\n\t/* Override the const in proghdrs, we are the ones doing the loading. */\n\tstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\tconst char *pbuf;\n\tstruct elf_phdr *buf_phdr;\n\n\tpbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\n\tbuf_phdr = (struct elf_phdr *) pbuf;\n\n\tphdr->p_type   = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\n\tphdr->p_flags  = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tphdr->p_offset = elf64_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf64_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf64_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf64_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf64_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf64_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tphdr->p_offset = elf32_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf32_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf32_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf32_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf32_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf32_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_is_phdr_sane",
          "args": [
            "phdr",
            "len"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "elf_is_phdr_sane",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "185-200",
          "snippet": "static bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\n{\n\n\tif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\n\t\tpr_debug(\"ELF segment location wraps around.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\n\t\tpr_debug(\"ELF segment not in file.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\n\t\tpr_debug(\"ELF segment address wraps around.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\n{\n\n\tif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\n\t\tpr_debug(\"ELF segment location wraps around.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\n\t\tpr_debug(\"ELF segment not in file.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\n\t\tpr_debug(\"ELF segment address wraps around.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Unknown ELF class.\\n\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf32_to_cpu",
          "args": [
            "ehdr",
            "buf_phdr->p_align"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "elf32_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "39-47",
          "snippet": "static uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf64_to_cpu",
          "args": [
            "ehdr",
            "buf_phdr->p_align"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "elf64_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "29-37",
          "snippet": "static uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_phdr(const char *buf, size_t len,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t int idx)\n{\n\t/* Override the const in proghdrs, we are the ones doing the loading. */\n\tstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\tconst char *pbuf;\n\tstruct elf_phdr *buf_phdr;\n\n\tpbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\n\tbuf_phdr = (struct elf_phdr *) pbuf;\n\n\tphdr->p_type   = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\n\tphdr->p_flags  = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tphdr->p_offset = elf64_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf64_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf64_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf64_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf64_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf64_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tphdr->p_offset = elf32_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf32_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf32_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf32_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf32_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf32_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\n}"
  },
  {
    "function_name": "elf_is_phdr_sane",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "185-200",
    "snippet": "static bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\n{\n\n\tif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\n\t\tpr_debug(\"ELF segment location wraps around.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\n\t\tpr_debug(\"ELF segment not in file.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\n\t\tpr_debug(\"ELF segment address wraps around.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ELF segment address wraps around.\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ELF segment not in file.\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ELF segment location wraps around.\\n\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\n{\n\n\tif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\n\t\tpr_debug(\"ELF segment location wraps around.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\n\t\tpr_debug(\"ELF segment not in file.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\n\t\tpr_debug(\"ELF segment address wraps around.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "elf_read_ehdr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "119-179",
    "snippet": "static int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\n{\n\tstruct elfhdr *buf_ehdr;\n\n\tif (len < sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Buffer is too small to hold ELF header.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tmemset(ehdr, 0, sizeof(*ehdr));\n\tmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\n\tif (!elf_is_elf_file(ehdr)) {\n\t\tpr_debug(\"No ELF header magic.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tpr_debug(\"Not a supported ELF class.\\n\");\n\t\treturn -ENOEXEC;\n\t} else  if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\n\t\tehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n\t\tpr_debug(\"Not a supported ELF data format.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbuf_ehdr = (struct elfhdr *) buf;\n\tif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Bad ELF header size.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tehdr->e_type      = elf16_to_cpu(ehdr, buf_ehdr->e_type);\n\tehdr->e_machine   = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\n\tehdr->e_version   = elf32_to_cpu(ehdr, buf_ehdr->e_version);\n\tehdr->e_flags     = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\n\tehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\n\tehdr->e_phnum     = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\n\tehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\n\tehdr->e_shnum     = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\n\tehdr->e_shstrndx  = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tehdr->e_entry = elf64_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf64_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf64_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tehdr->e_entry = elf32_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf32_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf32_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elf_is_ehdr_sane",
          "args": [
            "ehdr",
            "len"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "elf_is_ehdr_sane",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "63-117",
          "snippet": "static bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\n{\n\tif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\n\t\tpr_debug(\"Bad program header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_shnum > 0 &&\n\t\t   ehdr->e_shentsize != sizeof(struct elf_shdr)) {\n\t\tpr_debug(\"Bad section header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\n\t\t   ehdr->e_version != EV_CURRENT) {\n\t\tpr_debug(\"Unknown ELF version.\\n\");\n\t\treturn false;\n\t}\n\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tsize_t phdr_size;\n\n\t\t/*\n\t\t * e_phnum is at most 65535 so calculating the size of the\n\t\t * program header cannot overflow.\n\t\t */\n\t\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\t\t/* Sanity check the program header table location. */\n\t\tif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\n\t\t\tpr_debug(\"Program headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_phoff + phdr_size > buf_len) {\n\t\t\tpr_debug(\"Program headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\n\t\tsize_t shdr_size;\n\n\t\t/*\n\t\t * e_shnum is at most 65536 so calculating\n\t\t * the size of the section header cannot overflow.\n\t\t */\n\t\tshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\n\n\t\t/* Sanity check the section header table location. */\n\t\tif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\n\t\t\tpr_debug(\"Section headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_shoff + shdr_size > buf_len) {\n\t\t\tpr_debug(\"Section headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\n{\n\tif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\n\t\tpr_debug(\"Bad program header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_shnum > 0 &&\n\t\t   ehdr->e_shentsize != sizeof(struct elf_shdr)) {\n\t\tpr_debug(\"Bad section header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\n\t\t   ehdr->e_version != EV_CURRENT) {\n\t\tpr_debug(\"Unknown ELF version.\\n\");\n\t\treturn false;\n\t}\n\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tsize_t phdr_size;\n\n\t\t/*\n\t\t * e_phnum is at most 65535 so calculating the size of the\n\t\t * program header cannot overflow.\n\t\t */\n\t\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\t\t/* Sanity check the program header table location. */\n\t\tif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\n\t\t\tpr_debug(\"Program headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_phoff + phdr_size > buf_len) {\n\t\t\tpr_debug(\"Program headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\n\t\tsize_t shdr_size;\n\n\t\t/*\n\t\t * e_shnum is at most 65536 so calculating\n\t\t * the size of the section header cannot overflow.\n\t\t */\n\t\tshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\n\n\t\t/* Sanity check the section header table location. */\n\t\tif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\n\t\t\tpr_debug(\"Section headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_shoff + shdr_size > buf_len) {\n\t\t\tpr_debug(\"Section headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Unknown ELF class.\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf32_to_cpu",
          "args": [
            "ehdr",
            "buf_ehdr->e_shoff"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "elf32_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "39-47",
          "snippet": "static uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf64_to_cpu",
          "args": [
            "ehdr",
            "buf_ehdr->e_shoff"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "elf64_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "29-37",
          "snippet": "static uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf16_to_cpu",
          "args": [
            "ehdr",
            "buf_ehdr->e_shstrndx"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "elf16_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "49-57",
          "snippet": "static uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le16_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be16_to_cpu(value);\n\n\treturn value;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le16_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be16_to_cpu(value);\n\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Bad ELF header size.\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Not a supported ELF data format.\\n\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Not a supported ELF class.\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"No ELF header magic.\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_is_elf_file",
          "args": [
            "ehdr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "elf_is_elf_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
          "lines": "24-27",
          "snippet": "static inline bool elf_is_elf_file(const struct elfhdr *ehdr)\n{\n\treturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kexec.h>",
            "#include <linux/elf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic inline bool elf_is_elf_file(const struct elfhdr *ehdr)\n{\n\treturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ehdr->e_ident",
            "buf",
            "sizeof(ehdr->e_ident)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ehdr",
            "0",
            "sizeof(*ehdr)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Buffer is too small to hold ELF header.\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\n{\n\tstruct elfhdr *buf_ehdr;\n\n\tif (len < sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Buffer is too small to hold ELF header.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tmemset(ehdr, 0, sizeof(*ehdr));\n\tmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\n\tif (!elf_is_elf_file(ehdr)) {\n\t\tpr_debug(\"No ELF header magic.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tpr_debug(\"Not a supported ELF class.\\n\");\n\t\treturn -ENOEXEC;\n\t} else  if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\n\t\tehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n\t\tpr_debug(\"Not a supported ELF data format.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbuf_ehdr = (struct elfhdr *) buf;\n\tif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Bad ELF header size.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tehdr->e_type      = elf16_to_cpu(ehdr, buf_ehdr->e_type);\n\tehdr->e_machine   = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\n\tehdr->e_version   = elf32_to_cpu(ehdr, buf_ehdr->e_version);\n\tehdr->e_flags     = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\n\tehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\n\tehdr->e_phnum     = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\n\tehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\n\tehdr->e_shnum     = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\n\tehdr->e_shstrndx  = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tehdr->e_entry = elf64_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf64_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf64_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tehdr->e_entry = elf32_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf32_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf32_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\n}"
  },
  {
    "function_name": "elf_is_ehdr_sane",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "63-117",
    "snippet": "static bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\n{\n\tif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\n\t\tpr_debug(\"Bad program header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_shnum > 0 &&\n\t\t   ehdr->e_shentsize != sizeof(struct elf_shdr)) {\n\t\tpr_debug(\"Bad section header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\n\t\t   ehdr->e_version != EV_CURRENT) {\n\t\tpr_debug(\"Unknown ELF version.\\n\");\n\t\treturn false;\n\t}\n\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tsize_t phdr_size;\n\n\t\t/*\n\t\t * e_phnum is at most 65535 so calculating the size of the\n\t\t * program header cannot overflow.\n\t\t */\n\t\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\t\t/* Sanity check the program header table location. */\n\t\tif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\n\t\t\tpr_debug(\"Program headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_phoff + phdr_size > buf_len) {\n\t\t\tpr_debug(\"Program headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\n\t\tsize_t shdr_size;\n\n\t\t/*\n\t\t * e_shnum is at most 65536 so calculating\n\t\t * the size of the section header cannot overflow.\n\t\t */\n\t\tshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\n\n\t\t/* Sanity check the section header table location. */\n\t\tif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\n\t\t\tpr_debug(\"Section headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_shoff + shdr_size > buf_len) {\n\t\t\tpr_debug(\"Section headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Section headers truncated.\\n\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Section headers at invalid location.\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Program headers truncated.\\n\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Program headers at invalid location.\\n\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Unknown ELF version.\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Bad section header size.\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Bad program header size.\\n\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\n{\n\tif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\n\t\tpr_debug(\"Bad program header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_shnum > 0 &&\n\t\t   ehdr->e_shentsize != sizeof(struct elf_shdr)) {\n\t\tpr_debug(\"Bad section header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\n\t\t   ehdr->e_version != EV_CURRENT) {\n\t\tpr_debug(\"Unknown ELF version.\\n\");\n\t\treturn false;\n\t}\n\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tsize_t phdr_size;\n\n\t\t/*\n\t\t * e_phnum is at most 65535 so calculating the size of the\n\t\t * program header cannot overflow.\n\t\t */\n\t\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\t\t/* Sanity check the program header table location. */\n\t\tif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\n\t\t\tpr_debug(\"Program headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_phoff + phdr_size > buf_len) {\n\t\t\tpr_debug(\"Program headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\n\t\tsize_t shdr_size;\n\n\t\t/*\n\t\t * e_shnum is at most 65536 so calculating\n\t\t * the size of the section header cannot overflow.\n\t\t */\n\t\tshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\n\n\t\t/* Sanity check the section header table location. */\n\t\tif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\n\t\t\tpr_debug(\"Section headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_shoff + shdr_size > buf_len) {\n\t\t\tpr_debug(\"Section headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "elf16_to_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "49-57",
    "snippet": "static uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le16_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be16_to_cpu(value);\n\n\treturn value;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "value"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "value"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le16_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be16_to_cpu(value);\n\n\treturn value;\n}"
  },
  {
    "function_name": "elf32_to_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "39-47",
    "snippet": "static uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "value"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "value"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}"
  },
  {
    "function_name": "elf64_to_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "29-37",
    "snippet": "static uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "value"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "value"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}"
  },
  {
    "function_name": "elf_is_elf_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_elf.c",
    "lines": "24-27",
    "snippet": "static inline bool elf_is_elf_file(const struct elfhdr *ehdr)\n{\n\treturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/kexec.h>",
      "#include <linux/elf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ehdr->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kexec.h>\n#include <linux/elf.h>\n\nstatic inline bool elf_is_elf_file(const struct elfhdr *ehdr)\n{\n\treturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\n}"
  }
]