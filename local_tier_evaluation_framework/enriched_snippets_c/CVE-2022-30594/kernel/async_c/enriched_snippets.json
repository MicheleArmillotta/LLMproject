[
  {
    "function_name": "current_is_async",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "302-307",
    "snippet": "bool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nbool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}"
  },
  {
    "function_name": "async_synchronize_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "291-294",
    "snippet": "void async_synchronize_cookie(async_cookie_t cookie)\n{\n\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ASYNC_DOMAIN(async_dfl_domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_cookie_domain",
          "args": [
            "cookie",
            "&async_dfl_domain"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_cookie_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "270-281",
          "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic ASYNC_DOMAIN(async_dfl_domain);\n\nvoid async_synchronize_cookie(async_cookie_t cookie)\n{\n\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);\n}"
  },
  {
    "function_name": "async_synchronize_cookie_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "270-281",
    "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"async_continuing @ %i after %lli usec\\n\"",
            "task_pid_nr(current)",
            "microseconds_since(starttime)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microseconds_since",
          "args": [
            "starttime"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "microseconds_since",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "81-85",
          "snippet": "static long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "async_done",
            "lowest_in_progress(domain) >= cookie"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowest_in_progress",
          "args": [
            "domain"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "lowest_in_progress",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "87-110",
          "snippet": "static async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
          ],
          "globals_used": [
            "static LIST_HEAD(async_global_pending);",
            "static DEFINE_SPINLOCK(async_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\n\nstatic async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"async_waiting @ %i\\n\"",
            "task_pid_nr(current)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}"
  },
  {
    "function_name": "async_synchronize_full_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "255-258",
    "snippet": "void async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_cookie_domain",
          "args": [
            "ASYNC_COOKIE_MAX",
            "domain"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_cookie_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "270-281",
          "snippet": "void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(async_done);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nvoid async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}"
  },
  {
    "function_name": "async_synchronize_full",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "242-245",
    "snippet": "void async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_synchronize_full_domain",
          "args": [
            "NULL"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_full_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "255-258",
          "snippet": "void async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nvoid async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}"
  },
  {
    "function_name": "async_schedule_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "231-234",
    "snippet": "async_cookie_t async_schedule_node(async_func_t func, void *data, int node)\n{\n\treturn async_schedule_node_domain(func, data, node, &async_dfl_domain);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ASYNC_DOMAIN(async_dfl_domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "async_schedule_node_domain",
          "args": [
            "func",
            "data",
            "node",
            "&async_dfl_domain"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "async_schedule_node_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "165-215",
          "snippet": "async_cookie_t async_schedule_node_domain(async_func_t func, void *data,\n\t\t\t\t\t  int node, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work_node(node, system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [
            "#define MAX_WORK\t\t32768"
          ],
          "globals_used": [
            "static async_cookie_t next_cookie = 1;",
            "static LIST_HEAD(async_global_pending);",
            "static DEFINE_SPINLOCK(async_lock);",
            "static atomic_t entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define MAX_WORK\t\t32768\n\nstatic async_cookie_t next_cookie = 1;\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\nstatic atomic_t entry_count;\n\nasync_cookie_t async_schedule_node_domain(async_func_t func, void *data,\n\t\t\t\t\t  int node, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work_node(node, system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic ASYNC_DOMAIN(async_dfl_domain);\n\nasync_cookie_t async_schedule_node(async_func_t func, void *data, int node)\n{\n\treturn async_schedule_node_domain(func, data, node, &async_dfl_domain);\n}"
  },
  {
    "function_name": "async_schedule_node_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "165-215",
    "snippet": "async_cookie_t async_schedule_node_domain(async_func_t func, void *data,\n\t\t\t\t\t  int node, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work_node(node, system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define MAX_WORK\t\t32768"
    ],
    "globals_used": [
      "static async_cookie_t next_cookie = 1;",
      "static LIST_HEAD(async_global_pending);",
      "static DEFINE_SPINLOCK(async_lock);",
      "static atomic_t entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work_node",
          "args": [
            "node",
            "system_unbound_wq",
            "&entry->work"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1624-1652",
          "snippet": "bool queue_work_node(int node, struct workqueue_struct *wq,\n\t\t     struct work_struct *work)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\t/*\n\t * This current implementation is specific to unbound workqueues.\n\t * Specifically we only return the first available CPU for a given\n\t * node instead of cycling through individual CPUs within the node.\n\t *\n\t * If this is used with a per-cpu workqueue then the logic in\n\t * workqueue_select_cpu_near would need to be updated to allow for\n\t * some round robin type logic.\n\t */\n\tWARN_ON_ONCE(!(wq->flags & WQ_UNBOUND));\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\tint cpu = workqueue_select_cpu_near(node);\n\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_node(int node, struct workqueue_struct *wq,\n\t\t     struct work_struct *work)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\t/*\n\t * This current implementation is specific to unbound workqueues.\n\t * Specifically we only return the first available CPU for a given\n\t * node instead of cycling through individual CPUs within the node.\n\t *\n\t * If this is used with a per-cpu workqueue then the logic in\n\t * workqueue_select_cpu_near would need to be updated to allow for\n\t * some round robin type logic.\n\t */\n\tWARN_ON_ONCE(!(wq->flags & WQ_UNBOUND));\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\tint cpu = workqueue_select_cpu_near(node);\n\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&entry_count"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->global_list",
            "&async_global_pending"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->domain_list",
            "&domain->pending"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&entry->work",
            "async_run_entry_fn"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->global_list"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->domain_list"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "data",
            "newcookie"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_func_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "101-104",
          "snippet": "static bool task_work_func_match(struct callback_head *cb, void *data)\n{\n\treturn cb->func == data;\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic bool task_work_func_match(struct callback_head *cb, void *data)\n{\n\treturn cb->func == data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&entry_count"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct async_entry)",
            "GFP_ATOMIC"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define MAX_WORK\t\t32768\n\nstatic async_cookie_t next_cookie = 1;\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\nstatic atomic_t entry_count;\n\nasync_cookie_t async_schedule_node_domain(async_func_t func, void *data,\n\t\t\t\t\t  int node, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t/* allow irq-off callers */\n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t/*\n\t * If we're out of memory or if there's too much work\n\t * pending already, we execute synchronously.\n\t */\n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t/* low on memory.. run synchronously */\n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t/* allocate cookie and queue */\n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* mark that this task has queued an async job, used by module init */\n\tcurrent->flags |= PF_USED_ASYNC;\n\n\t/* schedule for execution */\n\tqueue_work_node(node, system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}"
  },
  {
    "function_name": "async_run_entry_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "115-146",
    "snippet": "static void async_run_entry_fn(struct work_struct *work)\n{\n\tstruct async_entry *entry =\n\t\tcontainer_of(work, struct async_entry, work);\n\tunsigned long flags;\n\tktime_t calltime;\n\n\t/* 1) run (and print duration) */\n\tpr_debug(\"calling  %lli_%pS @ %i\\n\", (long long)entry->cookie,\n\t\t entry->func, task_pid_nr(current));\n\tcalltime = ktime_get();\n\n\tentry->func(entry->data, entry->cookie);\n\n\tpr_debug(\"initcall %lli_%pS returned after %lld usecs\\n\",\n\t\t (long long)entry->cookie, entry->func,\n\t\t microseconds_since(calltime));\n\n\t/* 2) remove self from the pending queues */\n\tspin_lock_irqsave(&async_lock, flags);\n\tlist_del_init(&entry->domain_list);\n\tlist_del_init(&entry->global_list);\n\n\t/* 3) free the entry */\n\tkfree(entry);\n\tatomic_dec(&entry_count);\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* 4) wake up any waiters */\n\twake_up(&async_done);\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(async_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(async_done);",
      "static atomic_t entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&async_done"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&entry_count"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->global_list"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&entry->domain_list"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"initcall %lli_%pS returned after %lld usecs\\n\"",
            "(long long)entry->cookie",
            "entry->func",
            "microseconds_since(calltime)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microseconds_since",
          "args": [
            "calltime"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "microseconds_since",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
          "lines": "81-85",
          "snippet": "static long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry->func",
          "args": [
            "entry->data",
            "entry->cookie"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "601-607",
          "snippet": "static struct bpf_func_state *func(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\n\treturn cur->frame[reg->frameno];\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic struct bpf_func_state *func(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\n\treturn cur->frame[reg->frameno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"calling  %lli_%pS @ %i\\n\"",
            "(long long)entry->cookie",
            "entry->func",
            "task_pid_nr(current)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structasync_entry",
            "work"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic DEFINE_SPINLOCK(async_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\nstatic atomic_t entry_count;\n\nstatic void async_run_entry_fn(struct work_struct *work)\n{\n\tstruct async_entry *entry =\n\t\tcontainer_of(work, struct async_entry, work);\n\tunsigned long flags;\n\tktime_t calltime;\n\n\t/* 1) run (and print duration) */\n\tpr_debug(\"calling  %lli_%pS @ %i\\n\", (long long)entry->cookie,\n\t\t entry->func, task_pid_nr(current));\n\tcalltime = ktime_get();\n\n\tentry->func(entry->data, entry->cookie);\n\n\tpr_debug(\"initcall %lli_%pS returned after %lld usecs\\n\",\n\t\t (long long)entry->cookie, entry->func,\n\t\t microseconds_since(calltime));\n\n\t/* 2) remove self from the pending queues */\n\tspin_lock_irqsave(&async_lock, flags);\n\tlist_del_init(&entry->domain_list);\n\tlist_del_init(&entry->global_list);\n\n\t/* 3) free the entry */\n\tkfree(entry);\n\tatomic_dec(&entry_count);\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t/* 4) wake up any waiters */\n\twake_up(&async_done);\n}"
  },
  {
    "function_name": "lowest_in_progress",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "87-110",
    "snippet": "static async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [
      "#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */"
    ],
    "globals_used": [
      "static LIST_HEAD(async_global_pending);",
      "static DEFINE_SPINLOCK(async_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&async_global_pending",
            "structasync_entry",
            "global_list"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&async_global_pending"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&domain->pending",
            "structasync_entry",
            "domain_list"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&async_lock",
            "flags"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t/* infinity cookie */\n\nstatic LIST_HEAD(async_global_pending);\nstatic DEFINE_SPINLOCK(async_lock);\n\nstatic async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "microseconds_since",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/async.c",
    "lines": "81-85",
    "snippet": "static long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}",
    "includes": [
      "#include \"workqueue_internal.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/wait.h>",
      "#include <linux/export.h>",
      "#include <linux/ktime.h>",
      "#include <linux/atomic.h>",
      "#include <linux/async.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(now, start)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "start"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nstatic long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}"
  }
]