[
  {
    "function_name": "trace_probe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1194-1209",
    "snippet": "int trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createfn",
          "args": [
            "argc",
            "(const char **)argv"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "raw_command",
            "&argc"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_probe_match_command_args",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1176-1192",
    "snippet": "bool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "argv[i]"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%s=%s\"",
            "tp->args[i].name",
            "tp->args[i].comm"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "trace_probe_compare_arg_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1155-1174",
    "snippet": "int trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->args[i].name",
            "b->args[i].name"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t/* In case of more arguments */\n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_probe_remove_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1133-1149",
    "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_TRACE"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tp->event->files"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree_rcu",
          "args": [
            "link"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&link->list"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_get_file_link",
          "args": [
            "tp",
            "file"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_get_file_link",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1120-1131",
          "snippet": "struct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_probe_get_file_link",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1120-1131",
    "snippet": "struct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_for_each_link",
          "args": [
            "link",
            "tp"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_probe_add_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1105-1118",
    "snippet": "int trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_set_flag",
          "args": [
            "tp",
            "TP_FLAG_TRACE"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_set_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "262-266",
          "snippet": "static inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&link->list",
            "&tp->event->files"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&link->list"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*link)",
            "GFP_KERNEL"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_probe_register_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1083-1103",
    "snippet": "int trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_add_event_call",
          "args": [
            "call"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "trace_add_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2747-2760",
          "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_trace_event_call",
          "args": [
            "trace_probe_group_name(tp)",
            "trace_probe_name(tp)"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "find_trace_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1064-1081",
          "snippet": "static struct trace_event_call *\nfind_trace_event_call(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\treturn tp_event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_event_call *\nfind_trace_event_call(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\treturn tp_event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "tp"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "tp"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "tp"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_trace_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1064-1081",
    "snippet": "static struct trace_event_call *\nfind_trace_event_call(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\treturn tp_event;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "name"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "tp_event"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_event",
            "&ftrace_events",
            "list"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_event_call *\nfind_trace_event_call(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\treturn tp_event;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_probe_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1020-1062",
    "snippet": "int trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_cleanup",
          "args": [
            "tp"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1009-1018",
          "snippet": "void trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "group",
            "GFP_KERNEL"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event",
            "GFP_KERNEL"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "tp"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tp->list",
            "&tp->event->probes"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->list"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->event->probes"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->event->class.fields"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->event->files"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_probe_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1009-1018",
    "snippet": "void trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_unlink",
          "args": [
            "tp"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1001-1007",
          "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_free_probe_arg",
          "args": [
            "&tp->args[i]"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_free_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "811-825",
          "snippet": "void traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t    code->op == FETCH_OP_DATA)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t    code->op == FETCH_OP_DATA)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}"
  },
  {
    "function_name": "trace_probe_unlink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "1001-1007",
    "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_event_free",
          "args": [
            "tp->event"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "979-985",
          "snippet": "static void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "trace_probe_probe_list(tp)"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tp->list"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
  },
  {
    "function_name": "trace_probe_append",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "987-999",
    "snippet": "int trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tp->list",
            "trace_probe_probe_list(to)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "to"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_event_free",
          "args": [
            "tp->event"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "979-985",
          "snippet": "static void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tp->list"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_has_sibling",
          "args": [
            "tp"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_sibling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "314-319",
          "snippet": "static inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_probe_event_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "979-985",
    "snippet": "static void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tpe"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}"
  },
  {
    "function_name": "traceprobe_define_arg_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "954-977",
    "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "event_call",
            "fmt",
            "parg->name",
            "offset + parg->offset",
            "size",
            "parg->type->is_signed",
            "FILTER_OTHER"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "134-146",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_set_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "935-952",
    "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_print_fmt",
          "args": [
            "tp",
            "print_fmt",
            "len + 1",
            "ptype"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "__set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "863-932",
          "snippet": "static int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   enum probe_print_type ptype)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tswitch (ptype) {\n\tcase PROBE_PRINT_NORMAL:\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t\tbreak;\n\tcase PROBE_PRINT_RETURN:\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t\tbreak;\n\tcase PROBE_PRINT_EVENT:\n\t\tfmt = \"(%u)\";\n\t\targ = \"REC->\" FIELD_STRING_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   enum probe_print_type ptype)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tswitch (ptype) {\n\tcase PROBE_PRINT_NORMAL:\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t\tbreak;\n\tcase PROBE_PRINT_RETURN:\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t\tbreak;\n\tcase PROBE_PRINT_EVENT:\n\t\tfmt = \"(%u)\";\n\t\targ = \"REC->\" FIELD_STRING_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "tp"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "863-932",
    "snippet": "static int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   enum probe_print_type ptype)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tswitch (ptype) {\n\tcase PROBE_PRINT_NORMAL:\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t\tbreak;\n\tcase PROBE_PRINT_RETURN:\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t\tbreak;\n\tcase PROBE_PRINT_EVENT:\n\t\tfmt = \"(%u)\";\n\t\targ = \"REC->\" FIELD_STRING_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "fmt",
            "parg->name"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->type->name",
            "\"ustring\""
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "fmt",
            "parg->name",
            "j"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\", %s\"",
            "arg"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s\"",
            "parg->type->fmt"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"}\""
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\",%s\"",
            "parg->type->fmt"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"{%s\"",
            "parg->type->fmt"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\" %s=\"",
            "parg->name"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"%s\"",
            "fmt"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   enum probe_print_type ptype)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tswitch (ptype) {\n\tcase PROBE_PRINT_NORMAL:\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t\tbreak;\n\tcase PROBE_PRINT_RETURN:\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t\tbreak;\n\tcase PROBE_PRINT_EVENT:\n\t\tfmt = \"(%u)\";\n\t\targ = \"REC->\" FIELD_STRING_TYPE;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif ((strcmp(parg->type->name, \"string\") == 0) ||\n\t\t\t    (strcmp(parg->type->name, \"ustring\") == 0))\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "traceprobe_update_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "827-859",
    "snippet": "int traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(code->data, \"+-\");\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "code->data"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_split_symbol_offset",
          "args": [
            "code->data",
            "&offset"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_split_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "208-226",
          "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "code->data",
            "\"+-\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(code->data, \"+-\");\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_free_probe_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "811-825",
    "snippet": "void traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t    code->op == FETCH_OP_DATA)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg->fmt"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t    code->op == FETCH_OP_DATA)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}"
  },
  {
    "function_name": "traceprobe_parse_probe_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "770-809",
    "snippet": "int traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg_body",
          "args": [
            "body",
            "&tp->size",
            "parg",
            "flags",
            "body - arg"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg_body",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "555-751",
          "snippet": "static int traceprobe_parse_probe_arg_body(const char *argv, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags, int offset)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2, *t3;\n\tchar *arg;\n\tint ret, len;\n\n\targ = kstrdup(argv, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tlen = strlen(arg);\n\tif (len > MAX_ARGSTR_LEN) {\n\t\ttrace_probe_log_err(offset, ARG_TOO_LONG);\n\t\tgoto out;\n\t} else if (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_ARG_BODY);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2++ = '\\0';\n\t\t\tt3 = strchr(t2, ']');\n\t\t\tif (!t3) {\n\t\t\t\toffset += t2 + strlen(t2) - arg;\n\t\t\t\ttrace_probe_log_err(offset,\n\t\t\t\t\t\t    ARRAY_NO_CLOSE);\n\t\t\t\tgoto out;\n\t\t\t} else if (t3[1] != '\\0') {\n\t\t\t\ttrace_probe_log_err(offset + t3 + 1 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_SUFFIX);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*t3 = '\\0';\n\t\t\tif (kstrtouint(t2, 0, &parg->count) || !parg->count) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_NUM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (parg->count > MAX_ARRAY_LEN) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    ARRAY_TOO_BIG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Since $comm and immediate string can not be dereferenced,\n\t * we can find those by strcmp.\n\t */\n\tif (strcmp(arg, \"$comm\") == 0 || strncmp(arg, \"\\\\\\\"\", 2) == 0) {\n\t\t/* The type of $comm must be \"string\", and not an array. */\n\t\tif (parg->count || (t && strcmp(t, \"string\")))\n\t\t\tgoto out;\n\t\tparg->type = find_fetch_type(\"string\");\n\t} else\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0), BAD_TYPE);\n\t\tgoto out;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tret = -ENOMEM;\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\tgoto out;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kcalloc(FETCH_INSN_MAX, sizeof(*code), GFP_KERNEL);\n\tif (!code)\n\t\tgoto out;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags, offset);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = -EINVAL;\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\") ||\n\t    !strcmp(parg->type->name, \"ustring\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_UDEREF &&\n\t\t    code->op != FETCH_OP_IMM && code->op != FETCH_OP_COMM &&\n\t\t    code->op != FETCH_OP_DATA && code->op != FETCH_OP_TP_ARG) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((code->op == FETCH_OP_IMM || code->op == FETCH_OP_COMM ||\n\t\t     code->op == FETCH_OP_DATA) || code->op == FETCH_OP_TP_ARG ||\n\t\t     parg->count) {\n\t\t\t/*\n\t\t\t * IMM, DATA and COMM is pointing actual address, those\n\t\t\t * must be kept, and if parg->count != 0, this is an\n\t\t\t * array of string pointers instead of string address\n\t\t\t * itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/* If op == DEREF, replace it with STRING */\n\t\tif (!strcmp(parg->type->name, \"ustring\") ||\n\t\t    code->op == FETCH_OP_UDEREF)\n\t\t\tcode->op = FETCH_OP_ST_USTRING;\n\t\telse\n\t\t\tcode->op = FETCH_OP_ST_STRING;\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\tcode->op = FETCH_OP_ST_UMEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offset + t - arg, BAD_BITFIELD);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = -EINVAL;\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING &&\n\t\t    scode->op != FETCH_OP_ST_USTRING) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\tret = 0;\n\t/* Shrink down the code buffer */\n\tparg->code = kcalloc(code - tmp + 1, sizeof(*code), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t\t    code->op == FETCH_OP_DATA)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\nout:\n\tkfree(arg);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int traceprobe_parse_probe_arg_body(const char *argv, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags, int offset)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2, *t3;\n\tchar *arg;\n\tint ret, len;\n\n\targ = kstrdup(argv, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tlen = strlen(arg);\n\tif (len > MAX_ARGSTR_LEN) {\n\t\ttrace_probe_log_err(offset, ARG_TOO_LONG);\n\t\tgoto out;\n\t} else if (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_ARG_BODY);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2++ = '\\0';\n\t\t\tt3 = strchr(t2, ']');\n\t\t\tif (!t3) {\n\t\t\t\toffset += t2 + strlen(t2) - arg;\n\t\t\t\ttrace_probe_log_err(offset,\n\t\t\t\t\t\t    ARRAY_NO_CLOSE);\n\t\t\t\tgoto out;\n\t\t\t} else if (t3[1] != '\\0') {\n\t\t\t\ttrace_probe_log_err(offset + t3 + 1 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_SUFFIX);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*t3 = '\\0';\n\t\t\tif (kstrtouint(t2, 0, &parg->count) || !parg->count) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_NUM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (parg->count > MAX_ARRAY_LEN) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    ARRAY_TOO_BIG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Since $comm and immediate string can not be dereferenced,\n\t * we can find those by strcmp.\n\t */\n\tif (strcmp(arg, \"$comm\") == 0 || strncmp(arg, \"\\\\\\\"\", 2) == 0) {\n\t\t/* The type of $comm must be \"string\", and not an array. */\n\t\tif (parg->count || (t && strcmp(t, \"string\")))\n\t\t\tgoto out;\n\t\tparg->type = find_fetch_type(\"string\");\n\t} else\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0), BAD_TYPE);\n\t\tgoto out;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tret = -ENOMEM;\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\tgoto out;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kcalloc(FETCH_INSN_MAX, sizeof(*code), GFP_KERNEL);\n\tif (!code)\n\t\tgoto out;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags, offset);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = -EINVAL;\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\") ||\n\t    !strcmp(parg->type->name, \"ustring\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_UDEREF &&\n\t\t    code->op != FETCH_OP_IMM && code->op != FETCH_OP_COMM &&\n\t\t    code->op != FETCH_OP_DATA && code->op != FETCH_OP_TP_ARG) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((code->op == FETCH_OP_IMM || code->op == FETCH_OP_COMM ||\n\t\t     code->op == FETCH_OP_DATA) || code->op == FETCH_OP_TP_ARG ||\n\t\t     parg->count) {\n\t\t\t/*\n\t\t\t * IMM, DATA and COMM is pointing actual address, those\n\t\t\t * must be kept, and if parg->count != 0, this is an\n\t\t\t * array of string pointers instead of string address\n\t\t\t * itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/* If op == DEREF, replace it with STRING */\n\t\tif (!strcmp(parg->type->name, \"ustring\") ||\n\t\t    code->op == FETCH_OP_UDEREF)\n\t\t\tcode->op = FETCH_OP_ST_USTRING;\n\t\telse\n\t\t\tcode->op = FETCH_OP_ST_STRING;\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\tcode->op = FETCH_OP_ST_UMEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offset + t - arg, BAD_BITFIELD);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = -EINVAL;\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING &&\n\t\t    scode->op != FETCH_OP_ST_USTRING) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\tret = 0;\n\t/* Shrink down the code buffer */\n\tparg->code = kcalloc(code - tmp + 1, sizeof(*code), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t\t    code->op == FETCH_OP_DATA)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\nout:\n\tkfree(arg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "USED_ARG_NAME"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_conflict_field_name",
          "args": [
            "parg->name",
            "tp->args",
            "i"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_conflict_field_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "754-768",
          "snippet": "static int traceprobe_conflict_field_name(const char *name,\n\t\t\t\t\t  struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\nstatic int traceprobe_conflict_field_name(const char *name,\n\t\t\t\t\t  struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "parg->name"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1976-1985",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"arg%d\"",
            "i + 1"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "arg",
            "body - arg",
            "GFP_KERNEL"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'='"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}"
  },
  {
    "function_name": "traceprobe_conflict_field_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "754-768",
    "snippet": "static int traceprobe_conflict_field_name(const char *name,\n\t\t\t\t\t  struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[i].name",
            "name"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "reserved_field_names"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\nstatic int traceprobe_conflict_field_name(const char *name,\n\t\t\t\t\t  struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_parse_probe_arg_body",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "555-751",
    "snippet": "static int traceprobe_parse_probe_arg_body(const char *argv, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags, int offset)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2, *t3;\n\tchar *arg;\n\tint ret, len;\n\n\targ = kstrdup(argv, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tlen = strlen(arg);\n\tif (len > MAX_ARGSTR_LEN) {\n\t\ttrace_probe_log_err(offset, ARG_TOO_LONG);\n\t\tgoto out;\n\t} else if (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_ARG_BODY);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2++ = '\\0';\n\t\t\tt3 = strchr(t2, ']');\n\t\t\tif (!t3) {\n\t\t\t\toffset += t2 + strlen(t2) - arg;\n\t\t\t\ttrace_probe_log_err(offset,\n\t\t\t\t\t\t    ARRAY_NO_CLOSE);\n\t\t\t\tgoto out;\n\t\t\t} else if (t3[1] != '\\0') {\n\t\t\t\ttrace_probe_log_err(offset + t3 + 1 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_SUFFIX);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*t3 = '\\0';\n\t\t\tif (kstrtouint(t2, 0, &parg->count) || !parg->count) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_NUM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (parg->count > MAX_ARRAY_LEN) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    ARRAY_TOO_BIG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Since $comm and immediate string can not be dereferenced,\n\t * we can find those by strcmp.\n\t */\n\tif (strcmp(arg, \"$comm\") == 0 || strncmp(arg, \"\\\\\\\"\", 2) == 0) {\n\t\t/* The type of $comm must be \"string\", and not an array. */\n\t\tif (parg->count || (t && strcmp(t, \"string\")))\n\t\t\tgoto out;\n\t\tparg->type = find_fetch_type(\"string\");\n\t} else\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0), BAD_TYPE);\n\t\tgoto out;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tret = -ENOMEM;\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\tgoto out;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kcalloc(FETCH_INSN_MAX, sizeof(*code), GFP_KERNEL);\n\tif (!code)\n\t\tgoto out;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags, offset);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = -EINVAL;\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\") ||\n\t    !strcmp(parg->type->name, \"ustring\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_UDEREF &&\n\t\t    code->op != FETCH_OP_IMM && code->op != FETCH_OP_COMM &&\n\t\t    code->op != FETCH_OP_DATA && code->op != FETCH_OP_TP_ARG) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((code->op == FETCH_OP_IMM || code->op == FETCH_OP_COMM ||\n\t\t     code->op == FETCH_OP_DATA) || code->op == FETCH_OP_TP_ARG ||\n\t\t     parg->count) {\n\t\t\t/*\n\t\t\t * IMM, DATA and COMM is pointing actual address, those\n\t\t\t * must be kept, and if parg->count != 0, this is an\n\t\t\t * array of string pointers instead of string address\n\t\t\t * itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/* If op == DEREF, replace it with STRING */\n\t\tif (!strcmp(parg->type->name, \"ustring\") ||\n\t\t    code->op == FETCH_OP_UDEREF)\n\t\t\tcode->op = FETCH_OP_ST_USTRING;\n\t\telse\n\t\t\tcode->op = FETCH_OP_ST_STRING;\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\tcode->op = FETCH_OP_ST_UMEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offset + t - arg, BAD_BITFIELD);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = -EINVAL;\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING &&\n\t\t    scode->op != FETCH_OP_ST_USTRING) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\tret = 0;\n\t/* Shrink down the code buffer */\n\tparg->code = kcalloc(code - tmp + 1, sizeof(*code), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t\t    code->op == FETCH_OP_DATA)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\nout:\n\tkfree(arg);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "parg->code",
            "tmp",
            "sizeof(*code) * (code - tmp + 1)"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "code - tmp + 1",
            "sizeof(*code)",
            "GFP_KERNEL"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "offset",
            "TOO_MANY_OPS"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_bitfield_probe_arg",
          "args": [
            "t",
            "parg->type",
            "&code"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_bitfield_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "520-552",
          "snippet": "static int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -EINVAL;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -EINVAL;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->type->name",
            "\"ustring\""
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_probe_arg",
          "args": [
            "arg",
            "parg->type",
            "&code",
            "&code[FETCH_INSN_MAX - 1]",
            "flags",
            "offset"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "365-515",
          "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags, int offs)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags, offs);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(offs, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(offs, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(offs, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offs, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\toffs += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags, offs);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(offs, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t/* Immediate value */\n\t\tif (arg[1] == '\"') {\t/* Immediate string */\n\t\t\tret = __parse_imm_string(arg + 2, &tmp, offs + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(offs + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\ttrace_probe_log_err(offs, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags, int offs)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags, offs);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(offs, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(offs, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(offs, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offs, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\toffs += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags, offs);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(offs, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t/* Immediate value */\n\t\tif (arg[1] == '\"') {\t/* Immediate string */\n\t\t\tret = __parse_imm_string(arg + 2, &tmp, offs + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(offs + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\ttrace_probe_log_err(offs, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "FETCH_INSN_MAX",
            "sizeof(*code)",
            "GFP_KERNEL"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "parg->fmt",
            "len",
            "\"%s[%d]\"",
            "parg->type->fmttype",
            "parg->count"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "parg->type->fmttype"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "t"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "101-141",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"\\\\\\\"\"",
            "2"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "t2",
            "0",
            "&parg->count"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "t2",
            "']'"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++t",
            "'['"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "':'"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg",
            "GFP_KERNEL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "argv",
            "GFP_KERNEL"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int traceprobe_parse_probe_arg_body(const char *argv, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags, int offset)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2, *t3;\n\tchar *arg;\n\tint ret, len;\n\n\targ = kstrdup(argv, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tlen = strlen(arg);\n\tif (len > MAX_ARGSTR_LEN) {\n\t\ttrace_probe_log_err(offset, ARG_TOO_LONG);\n\t\tgoto out;\n\t} else if (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_ARG_BODY);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2++ = '\\0';\n\t\t\tt3 = strchr(t2, ']');\n\t\t\tif (!t3) {\n\t\t\t\toffset += t2 + strlen(t2) - arg;\n\t\t\t\ttrace_probe_log_err(offset,\n\t\t\t\t\t\t    ARRAY_NO_CLOSE);\n\t\t\t\tgoto out;\n\t\t\t} else if (t3[1] != '\\0') {\n\t\t\t\ttrace_probe_log_err(offset + t3 + 1 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_SUFFIX);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*t3 = '\\0';\n\t\t\tif (kstrtouint(t2, 0, &parg->count) || !parg->count) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_NUM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (parg->count > MAX_ARRAY_LEN) {\n\t\t\t\ttrace_probe_log_err(offset + t2 - arg,\n\t\t\t\t\t\t    ARRAY_TOO_BIG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Since $comm and immediate string can not be dereferenced,\n\t * we can find those by strcmp.\n\t */\n\tif (strcmp(arg, \"$comm\") == 0 || strncmp(arg, \"\\\\\\\"\", 2) == 0) {\n\t\t/* The type of $comm must be \"string\", and not an array. */\n\t\tif (parg->count || (t && strcmp(t, \"string\")))\n\t\t\tgoto out;\n\t\tparg->type = find_fetch_type(\"string\");\n\t} else\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0), BAD_TYPE);\n\t\tgoto out;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tret = -ENOMEM;\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\tgoto out;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kcalloc(FETCH_INSN_MAX, sizeof(*code), GFP_KERNEL);\n\tif (!code)\n\t\tgoto out;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags, offset);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = -EINVAL;\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\") ||\n\t    !strcmp(parg->type->name, \"ustring\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_UDEREF &&\n\t\t    code->op != FETCH_OP_IMM && code->op != FETCH_OP_COMM &&\n\t\t    code->op != FETCH_OP_DATA && code->op != FETCH_OP_TP_ARG) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((code->op == FETCH_OP_IMM || code->op == FETCH_OP_COMM ||\n\t\t     code->op == FETCH_OP_DATA) || code->op == FETCH_OP_TP_ARG ||\n\t\t     parg->count) {\n\t\t\t/*\n\t\t\t * IMM, DATA and COMM is pointing actual address, those\n\t\t\t * must be kept, and if parg->count != 0, this is an\n\t\t\t * array of string pointers instead of string address\n\t\t\t * itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/* If op == DEREF, replace it with STRING */\n\t\tif (!strcmp(parg->type->name, \"ustring\") ||\n\t\t    code->op == FETCH_OP_UDEREF)\n\t\t\tcode->op = FETCH_OP_ST_USTRING;\n\t\telse\n\t\t\tcode->op = FETCH_OP_ST_STRING;\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\tcode->op = FETCH_OP_ST_UMEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offset + t - arg, BAD_BITFIELD);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tret = -EINVAL;\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING &&\n\t\t    scode->op != FETCH_OP_ST_USTRING) {\n\t\t\ttrace_probe_log_err(offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\tret = 0;\n\t/* Shrink down the code buffer */\n\tparg->code = kcalloc(code - tmp + 1, sizeof(*code), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t\t    code->op == FETCH_OP_DATA)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\nout:\n\tkfree(arg);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__parse_bitfield_probe_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "520-552",
    "snippet": "static int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -EINVAL;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "bf",
            "&tail",
            "0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "bf + 1",
            "&tail",
            "0"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -EINVAL;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}"
  },
  {
    "function_name": "parse_probe_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "365-515",
    "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags, int offs)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags, offs);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(offs, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(offs, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(offs, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offs, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\toffs += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags, offs);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(offs, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t/* Immediate value */\n\t\tif (arg[1] == '\"') {\t/* Immediate string */\n\t\t\tret = __parse_imm_string(arg + 2, &tmp, offs + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(offs + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\ttrace_probe_log_err(offs, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";",
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "offs",
            "BAD_FETCH_ARG"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_to_immediate",
          "args": [
            "arg + 1",
            "&code->immediate"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "str_to_immediate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "339-348",
          "snippet": "static int str_to_immediate(char *str, unsigned long *imm)\n{\n\tif (isdigit(str[0]))\n\t\treturn kstrtoul(str, 0, imm);\n\telse if (str[0] == '-')\n\t\treturn kstrtol(str, 0, (long *)imm);\n\telse if (str[0] == '+')\n\t\treturn kstrtol(str + 1, 0, (long *)imm);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int str_to_immediate(char *str, unsigned long *imm)\n{\n\tif (isdigit(str[0]))\n\t\treturn kstrtoul(str, 0, imm);\n\telse if (str[0] == '-')\n\t\treturn kstrtol(str, 0, (long *)imm);\n\telse if (str[0] == '+')\n\t\treturn kstrtol(str + 1, 0, (long *)imm);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_imm_string",
          "args": [
            "arg + 2",
            "&tmp",
            "offs + 2"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_imm_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "350-362",
          "snippet": "static int __parse_imm_string(char *str, char **pbuf, int offs)\n{\n\tsize_t len = strlen(str);\n\n\tif (str[len - 1] != '\"') {\n\t\ttrace_probe_log_err(offs + len, IMMSTR_NO_CLOSE);\n\t\treturn -EINVAL;\n\t}\n\t*pbuf = kstrndup(str, len - 1, GFP_KERNEL);\n\tif (!*pbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_imm_string(char *str, char **pbuf, int offs)\n{\n\tsize_t len = strlen(str);\n\n\tif (str[len - 1] != '\"') {\n\t\ttrace_probe_log_err(offs + len, IMMSTR_NO_CLOSE);\n\t\treturn -EINVAL;\n\t}\n\t*pbuf = kstrndup(str, len - 1, GFP_KERNEL);\n\tif (!*pbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_probe_arg",
          "args": [
            "arg",
            "t2",
            "&code",
            "end",
            "flags",
            "offs"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "365-515",
          "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags, int offs)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags, offs);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(offs, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(offs, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(offs, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offs, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\toffs += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags, offs);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(offs, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t/* Immediate value */\n\t\tif (arg[1] == '\"') {\t/* Immediate string */\n\t\t\tret = __parse_imm_string(arg + 2, &tmp, offs + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(offs + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\ttrace_probe_log_err(offs, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "NULL"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "101-141",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "arg",
            "')'"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "arg",
            "0",
            "&offset"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'('"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg + 1",
            "GFP_KERNEL"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "arg + 2",
            "0",
            "&offset"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + 1",
            "0",
            "&param"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[1]"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_query_register_offset",
          "args": [
            "arg + 1"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_probe_vars",
          "args": [
            "arg + 1",
            "type",
            "code",
            "flags",
            "offs"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_vars",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "275-337",
          "snippet": "static int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\tstruct fetch_insn *code, unsigned int flags, int offs)\n{\n\tunsigned long param;\n\tint ret = 0;\n\tint len;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN) {\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\t} else {\n\t\t\ttrace_probe_log_err(offs, RETVAL_ON_PROBE);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if ((len = str_has_prefix(arg, \"stack\"))) {\n\t\tif (arg[len] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[len])) {\n\t\t\tret = kstrtoul(arg + len, 10, &param);\n\t\t\tif (ret) {\n\t\t\t\tgoto inval_var;\n\t\t\t} else if ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_STACK_NUM);\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tgoto inval_var;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   (len = str_has_prefix(arg, \"arg\"))) {\n\t\tret = kstrtoul(arg + len, 10, &param);\n\t\tif (ret) {\n\t\t\tgoto inval_var;\n\t\t} else if (!param || param > PARAM_MAX_STACK) {\n\t\t\ttrace_probe_log_err(offs, BAD_ARG_NUM);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else if (flags & TPARG_FL_TPOINT) {\n\t\tif (code->data)\n\t\t\treturn -EFAULT;\n\t\tcode->data = kstrdup(arg, GFP_KERNEL);\n\t\tif (!code->data)\n\t\t\treturn -ENOMEM;\n\t\tcode->op = FETCH_OP_TP_ARG;\n\t} else\n\t\tgoto inval_var;\n\n\treturn ret;\n\ninval_var:\n\ttrace_probe_log_err(offs, BAD_VAR);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [
            "#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\n#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))\n\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\tstruct fetch_insn *code, unsigned int flags, int offs)\n{\n\tunsigned long param;\n\tint ret = 0;\n\tint len;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN) {\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\t} else {\n\t\t\ttrace_probe_log_err(offs, RETVAL_ON_PROBE);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if ((len = str_has_prefix(arg, \"stack\"))) {\n\t\tif (arg[len] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[len])) {\n\t\t\tret = kstrtoul(arg + len, 10, &param);\n\t\t\tif (ret) {\n\t\t\t\tgoto inval_var;\n\t\t\t} else if ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_STACK_NUM);\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tgoto inval_var;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   (len = str_has_prefix(arg, \"arg\"))) {\n\t\tret = kstrtoul(arg + len, 10, &param);\n\t\tif (ret) {\n\t\t\tgoto inval_var;\n\t\t} else if (!param || param > PARAM_MAX_STACK) {\n\t\t\ttrace_probe_log_err(offs, BAD_ARG_NUM);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else if (flags & TPARG_FL_TPOINT) {\n\t\tif (code->data)\n\t\t\treturn -EFAULT;\n\t\tcode->data = kstrdup(arg, GFP_KERNEL);\n\t\tif (!code->data)\n\t\t\treturn -ENOMEM;\n\t\tcode->op = FETCH_OP_TP_ARG;\n\t} else\n\t\tgoto inval_var;\n\n\treturn ret;\n\ninval_var:\n\ttrace_probe_log_err(offs, BAD_VAR);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags, int offs)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags, offs);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(offs, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(offs, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(offs, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(offs, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\toffs += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(offs + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags, offs);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(offs, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(offs, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t/* Immediate value */\n\t\tif (arg[1] == '\"') {\t/* Immediate string */\n\t\t\tret = __parse_imm_string(arg + 2, &tmp, offs + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(offs + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\ttrace_probe_log_err(offs, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__parse_imm_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "350-362",
    "snippet": "static int __parse_imm_string(char *str, char **pbuf, int offs)\n{\n\tsize_t len = strlen(str);\n\n\tif (str[len - 1] != '\"') {\n\t\ttrace_probe_log_err(offs + len, IMMSTR_NO_CLOSE);\n\t\treturn -EINVAL;\n\t}\n\t*pbuf = kstrndup(str, len - 1, GFP_KERNEL);\n\tif (!*pbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "str",
            "len - 1",
            "GFP_KERNEL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "offs + len",
            "IMMSTR_NO_CLOSE"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_imm_string(char *str, char **pbuf, int offs)\n{\n\tsize_t len = strlen(str);\n\n\tif (str[len - 1] != '\"') {\n\t\ttrace_probe_log_err(offs + len, IMMSTR_NO_CLOSE);\n\t\treturn -EINVAL;\n\t}\n\t*pbuf = kstrndup(str, len - 1, GFP_KERNEL);\n\tif (!*pbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "str_to_immediate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "339-348",
    "snippet": "static int str_to_immediate(char *str, unsigned long *imm)\n{\n\tif (isdigit(str[0]))\n\t\treturn kstrtoul(str, 0, imm);\n\telse if (str[0] == '-')\n\t\treturn kstrtol(str, 0, (long *)imm);\n\telse if (str[0] == '+')\n\t\treturn kstrtol(str + 1, 0, (long *)imm);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "str + 1",
            "0",
            "(long *)imm"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "str",
            "0",
            "(long *)imm"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "imm"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[0]"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int str_to_immediate(char *str, unsigned long *imm)\n{\n\tif (isdigit(str[0]))\n\t\treturn kstrtoul(str, 0, imm);\n\telse if (str[0] == '-')\n\t\treturn kstrtol(str, 0, (long *)imm);\n\telse if (str[0] == '+')\n\t\treturn kstrtol(str + 1, 0, (long *)imm);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "parse_probe_vars",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "275-337",
    "snippet": "static int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\tstruct fetch_insn *code, unsigned int flags, int offs)\n{\n\tunsigned long param;\n\tint ret = 0;\n\tint len;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN) {\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\t} else {\n\t\t\ttrace_probe_log_err(offs, RETVAL_ON_PROBE);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if ((len = str_has_prefix(arg, \"stack\"))) {\n\t\tif (arg[len] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[len])) {\n\t\t\tret = kstrtoul(arg + len, 10, &param);\n\t\t\tif (ret) {\n\t\t\t\tgoto inval_var;\n\t\t\t} else if ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_STACK_NUM);\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tgoto inval_var;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   (len = str_has_prefix(arg, \"arg\"))) {\n\t\tret = kstrtoul(arg + len, 10, &param);\n\t\tif (ret) {\n\t\t\tgoto inval_var;\n\t\t} else if (!param || param > PARAM_MAX_STACK) {\n\t\t\ttrace_probe_log_err(offs, BAD_ARG_NUM);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else if (flags & TPARG_FL_TPOINT) {\n\t\tif (code->data)\n\t\t\treturn -EFAULT;\n\t\tcode->data = kstrdup(arg, GFP_KERNEL);\n\t\tif (!code->data)\n\t\t\treturn -ENOMEM;\n\t\tcode->op = FETCH_OP_TP_ARG;\n\t} else\n\t\tgoto inval_var;\n\n\treturn ret;\n\ninval_var:\n\ttrace_probe_log_err(offs, BAD_VAR);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [
      "#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "offs",
            "BAD_VAR"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg",
            "GFP_KERNEL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + len",
            "10",
            "&param"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "arg",
            "\"arg\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"comm\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + len",
            "10",
            "&param"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[len]"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "arg",
            "\"stack\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\n#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))\n\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\tstruct fetch_insn *code, unsigned int flags, int offs)\n{\n\tunsigned long param;\n\tint ret = 0;\n\tint len;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN) {\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\t} else {\n\t\t\ttrace_probe_log_err(offs, RETVAL_ON_PROBE);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if ((len = str_has_prefix(arg, \"stack\"))) {\n\t\tif (arg[len] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[len])) {\n\t\t\tret = kstrtoul(arg + len, 10, &param);\n\t\t\tif (ret) {\n\t\t\t\tgoto inval_var;\n\t\t\t} else if ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK) {\n\t\t\t\ttrace_probe_log_err(offs, BAD_STACK_NUM);\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tgoto inval_var;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   (len = str_has_prefix(arg, \"arg\"))) {\n\t\tret = kstrtoul(arg + len, 10, &param);\n\t\tif (ret) {\n\t\t\tgoto inval_var;\n\t\t} else if (!param || param > PARAM_MAX_STACK) {\n\t\t\ttrace_probe_log_err(offs, BAD_ARG_NUM);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else if (flags & TPARG_FL_TPOINT) {\n\t\tif (code->data)\n\t\t\treturn -EFAULT;\n\t\tcode->data = kstrdup(arg, GFP_KERNEL);\n\t\tif (!code->data)\n\t\t\treturn -ENOMEM;\n\t\tcode->op = FETCH_OP_TP_ARG;\n\t} else\n\t\tgoto inval_var;\n\n\treturn ret;\n\ninval_var:\n\ttrace_probe_log_err(offs, BAD_VAR);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "traceprobe_parse_event_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "229-271",
    "snippet": "int traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "offset",
            "BAD_EVENT_NAME"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "event"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1976-1985",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "event",
            "slash - event + 1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "event",
            "'.'"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "event",
            "'/'"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_split_symbol_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "208-226",
    "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "tmp",
            "0",
            "offset"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "symbol",
            "\"+-\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_probe_log_err",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "163-205",
    "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *trace_probe_err_text[] = { ERRORS };",
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
      "static struct trace_probe_log trace_probe_log;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "command"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_log_err",
          "args": [
            "NULL",
            "trace_probe_log.subsystem",
            "command",
            "trace_probe_err_text",
            "err_type",
            "pos + offset"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7807-7833",
          "snippet": "void tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define CMD_PREFIX \"  Command: \"",
            "#define TRACING_LOG_LOC_MAX\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static DEFINE_MUTEX(tracing_err_log_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define CMD_PREFIX \"  Command: \"\n#define TRACING_LOG_LOC_MAX\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(tracing_err_log_lock);\n\nvoid tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "trace_probe_log.argv[i]"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "trace_probe_log.argv[i]"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
  },
  {
    "function_name": "trace_probe_log_set_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "158-161",
    "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_probe_log trace_probe_log;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
  },
  {
    "function_name": "trace_probe_log_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "153-156",
    "snippet": "void trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_probe_log trace_probe_log;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&trace_probe_log",
            "0",
            "sizeof(trace_probe_log)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}"
  },
  {
    "function_name": "trace_probe_log_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "145-151",
    "snippet": "void trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_probe_log trace_probe_log;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}"
  },
  {
    "function_name": "find_fetch_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "101-141",
    "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "probe_fetch_types[i].name"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "\"u64\""
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "101-141",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "type",
            "0",
            "&bs"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "'/'"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "PRINT_TYPE_FUNC_NAME",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "62-72",
    "snippet": "int PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s, void *data, void *ent)\n{\n\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_puts(s, \"(fault)\");\n\telse\n\t\ttrace_seq_printf(s, \"\\\"%s\\\"\",\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"\\\"%s\\\"\"",
            "(const char *)get_loc_data(data, ent)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "data",
            "ent"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"(fault)\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nint PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s, void *data, void *ent)\n{\n\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_puts(s, \"(fault)\");\n\telse\n\t\ttrace_seq_printf(s, \"\\\"%s\\\"\",\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "PRINT_TYPE_FUNC_NAME",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
    "lines": "54-58",
    "snippet": "int PRINT_TYPE_FUNC_NAME(symbol)(struct trace_seq *s, void *data, void *ent)\n{\n\ttrace_seq_printf(s, \"%pS\", (void *)*(unsigned long *)data);\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%pS\"",
            "(void *)*(unsigned long *)data"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint PRINT_TYPE_FUNC_NAME(symbol)(struct trace_seq *s, void *data, void *ent)\n{\n\ttrace_seq_printf(s, \"%pS\", (void *)*(unsigned long *)data);\n\treturn !trace_seq_has_overflowed(s);\n}"
  }
]