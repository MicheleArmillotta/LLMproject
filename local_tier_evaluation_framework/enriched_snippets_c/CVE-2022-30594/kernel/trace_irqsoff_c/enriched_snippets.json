[
  {
    "function_name": "init_irqsoff_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "736-749",
    "snippet": "__init static int init_irqsoff_tracer(void)\n{\n#ifdef CONFIG_IRQSOFF_TRACER\n\tregister_tracer(&irqsoff_tracer);\n#endif\n#ifdef CONFIG_PREEMPT_TRACER\n\tregister_tracer(&preemptoff_tracer);\n#endif\n#if defined(CONFIG_IRQSOFF_TRACER) && defined(CONFIG_PREEMPT_TRACER)\n\tregister_tracer(&preemptirqsoff_tracer);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&preemptirqsoff_tracer"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n__init static int init_irqsoff_tracer(void)\n{\n#ifdef CONFIG_IRQSOFF_TRACER\n\tregister_tracer(&irqsoff_tracer);\n#endif\n#ifdef CONFIG_PREEMPT_TRACER\n\tregister_tracer(&preemptoff_tracer);\n#endif\n#if defined(CONFIG_IRQSOFF_TRACER) && defined(CONFIG_PREEMPT_TRACER)\n\tregister_tracer(&preemptirqsoff_tracer);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "preemptirqsoff_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "710-713",
    "snippet": "static void preemptirqsoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_reset",
          "args": [
            "tr"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "578-592",
          "snippet": "static void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void preemptirqsoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}"
  },
  {
    "function_name": "preemptirqsoff_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "703-708",
    "snippet": "static int preemptirqsoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_IRQS_OFF | TRACER_PREEMPT_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_init",
          "args": [
            "tr"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "549-576",
          "snippet": "static int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int preemptirqsoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_IRQS_OFF | TRACER_PREEMPT_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}"
  },
  {
    "function_name": "preemptoff_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "675-678",
    "snippet": "static void preemptoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_reset",
          "args": [
            "tr"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "578-592",
          "snippet": "static void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void preemptoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}"
  },
  {
    "function_name": "preemptoff_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "668-673",
    "snippet": "static int preemptoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_PREEMPT_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_init",
          "args": [
            "tr"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "549-576",
          "snippet": "static int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int preemptoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_PREEMPT_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}"
  },
  {
    "function_name": "tracer_preempt_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "662-666",
    "snippet": "void tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_critical_timing",
          "args": [
            "a0",
            "a1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "370-401",
          "snippet": "static nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
  },
  {
    "function_name": "tracer_preempt_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "656-660",
    "snippet": "void tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_critical_timing",
          "args": [
            "a0",
            "a1"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (preempt_trace(preempt_count()) && !irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
  },
  {
    "function_name": "irqsoff_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "629-632",
    "snippet": "static void irqsoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_reset",
          "args": [
            "tr"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "578-592",
          "snippet": "static void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_tracer_reset(struct trace_array *tr)\n{\n\t__irqsoff_tracer_reset(tr);\n}"
  },
  {
    "function_name": "irqsoff_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "622-627",
    "snippet": "static int irqsoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_IRQS_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irqsoff_tracer_init",
          "args": [
            "tr"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__irqsoff_tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "549-576",
          "snippet": "static int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_tracer_init(struct trace_array *tr)\n{\n\ttrace_type = TRACER_IRQS_OFF;\n\n\treturn __irqsoff_tracer_init(tr);\n}"
  },
  {
    "function_name": "tracer_hardirqs_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "615-619",
    "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_critical_timing",
          "args": [
            "a0",
            "a1"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "370-401",
          "snippet": "static nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstart_critical_timing(a0, a1);\n}"
  },
  {
    "function_name": "tracer_hardirqs_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "608-612",
    "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_critical_timing",
          "args": [
            "a0",
            "a1"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tif (!preempt_trace(preempt_count()) && irq_trace())\n\t\tstop_critical_timing(a0, a1);\n}"
  },
  {
    "function_name": "irqsoff_tracer_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "599-602",
    "snippet": "static void irqsoff_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_tracer_stop(struct trace_array *tr)\n{\n\ttracer_enabled = 0;\n}"
  },
  {
    "function_name": "irqsoff_tracer_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "594-597",
    "snippet": "static void irqsoff_tracer_start(struct trace_array *tr)\n{\n\ttracer_enabled = 1;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_tracer_start(struct trace_array *tr)\n{\n\ttracer_enabled = 1;\n}"
  },
  {
    "function_name": "__irqsoff_tracer_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "578-592",
    "snippet": "static void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7225-7228",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_PAUSE_ON_TRACE",
            "pause_flag"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5267-5333",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;",
            "static size_t tgid_map_max;",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\nstatic size_t tgid_map_max;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_irqsoff_tracer",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "stop_irqsoff_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "540-545",
          "snippet": "static void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void __irqsoff_tracer_reset(struct trace_array *tr)\n{\n\tint lat_flag = save_flags & TRACE_ITER_LATENCY_FMT;\n\tint overwrite_flag = save_flags & TRACE_ITER_OVERWRITE;\n\tint pause_flag = save_flags & TRACE_ITER_PAUSE_ON_TRACE;\n\n\tstop_irqsoff_tracer(tr, is_graph(tr));\n\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, lat_flag);\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, overwrite_flag);\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, pause_flag);\n\tftrace_reset_array_ops(tr);\n\n\tirqsoff_busy = false;\n}"
  },
  {
    "function_name": "__irqsoff_tracer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "549-576",
    "snippet": "static int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"failed to start irqsoff tracer\\n\""
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_irqsoff_tracer",
          "args": [
            "tr",
            "(tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "start_irqsoff_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "526-538",
          "snippet": "static int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "irqsoff_tracer_call"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7213-7223",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tracer_flag",
          "args": [
            "tr",
            "TRACE_ITER_PAUSE_ON_TRACE",
            "1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "set_tracer_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5267-5333",
          "snippet": "int set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int *tgid_map;",
            "static size_t tgid_map_max;",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int *tgid_map;\nstatic size_t tgid_map_max;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tint *map;\n\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map) {\n\t\t\ttgid_map_max = pid_max;\n\t\t\tmap = kvcalloc(tgid_map_max + 1, sizeof(*tgid_map),\n\t\t\t\t       GFP_KERNEL);\n\n\t\t\t/*\n\t\t\t * Pairs with smp_load_acquire() in\n\t\t\t * trace_find_tgid_ptr() to ensure that if it observes\n\t\t\t * the tgid_map we just allocated then it also observes\n\t\t\t * the corresponding tgid_map_max value.\n\t\t\t */\n\t\t\tsmp_store_release(&tgid_map, map);\n\t\t}\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int __irqsoff_tracer_init(struct trace_array *tr)\n{\n\tif (irqsoff_busy)\n\t\treturn -EBUSY;\n\n\tsave_flags = tr->trace_flags;\n\n\t/* non overwrite screws up the latency tracers */\n\tset_tracer_flag(tr, TRACE_ITER_OVERWRITE, 1);\n\tset_tracer_flag(tr, TRACE_ITER_LATENCY_FMT, 1);\n\t/* without pause, we will produce garbage if another latency occurs */\n\tset_tracer_flag(tr, TRACE_ITER_PAUSE_ON_TRACE, 1);\n\n\ttr->max_latency = 0;\n\tirqsoff_trace = tr;\n\t/* make sure that the tracer is visible */\n\tsmp_wmb();\n\n\tftrace_init_array_ops(tr, irqsoff_tracer_call);\n\n\t/* Only toplevel instance supports graph tracing */\n\tif (start_irqsoff_tracer(tr, (tr->flags & TRACE_ARRAY_FL_GLOBAL &&\n\t\t\t\t      is_graph(tr))))\n\t\tprintk(KERN_ERR \"failed to start irqsoff tracer\\n\");\n\n\tirqsoff_busy = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "stop_irqsoff_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "540-545",
    "snippet": "static void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_irqsoff_function",
          "args": [
            "tr",
            "graph"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_irqsoff_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "504-504",
          "snippet": "static void unregister_irqsoff_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void unregister_irqsoff_function(struct trace_array *tr, int graph) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}"
  },
  {
    "function_name": "start_irqsoff_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "526-538",
    "snippet": "static int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_is_enabled",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "779-788",
          "snippet": "int tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_irqsoff_function",
          "args": [
            "tr",
            "graph",
            "0"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "register_irqsoff_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "500-503",
          "snippet": "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irqsoff_flag_changed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "511-524",
    "snippet": "static int irqsoff_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (irqsoff_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn irqsoff_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_keep_overwrite",
          "args": [
            "tracer",
            "mask",
            "set"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "trace_keep_overwrite",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "5259-5265",
          "snippet": "int trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqsoff_display_graph",
          "args": [
            "tr",
            "set"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "irqsoff_display_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "160-176",
          "snippet": "static int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\tint cpu;\n\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_irqsoff_tracer(irqsoff_trace, !set);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\n\ttr->max_latency = 0;\n\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);\n\n\treturn start_irqsoff_tracer(irqsoff_trace, set);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\tint cpu;\n\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_irqsoff_tracer(irqsoff_trace, !set);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\n\ttr->max_latency = 0;\n\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);\n\n\treturn start_irqsoff_tracer(irqsoff_trace, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqsoff_function_set",
          "args": [
            "tr",
            "mask",
            "set"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "irqsoff_function_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "505-508",
          "snippet": "static inline int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_flag_changed(struct trace_array *tr, u32 mask, int set)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\n\tif (irqsoff_function_set(tr, mask, set))\n\t\treturn 0;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (mask & TRACE_ITER_DISPLAY_GRAPH)\n\t\treturn irqsoff_display_graph(tr, set);\n#endif\n\n\treturn trace_keep_overwrite(tracer, mask, set);\n}"
  },
  {
    "function_name": "irqsoff_function_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "505-508",
    "snippet": "static inline int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_irqsoff_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "504-504",
    "snippet": "static void unregister_irqsoff_function(struct trace_array *tr, int graph) { }",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void unregister_irqsoff_function(struct trace_array *tr, int graph) { }"
  },
  {
    "function_name": "register_irqsoff_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "500-503",
    "snippet": "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "irqsoff_function_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "488-498",
    "snippet": "static int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_irqsoff_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_irqsoff_function(tr, is_graph(tr));\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_irqsoff_function",
          "args": [
            "tr",
            "is_graph(tr)"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_irqsoff_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "504-504",
          "snippet": "static void unregister_irqsoff_function(struct trace_array *tr, int graph) { }",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void unregister_irqsoff_function(struct trace_array *tr, int graph) { }"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_irqsoff_function",
          "args": [
            "tr",
            "is_graph(tr)",
            "1"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "register_irqsoff_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "500-503",
          "snippet": "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_function_set(struct trace_array *tr, u32 mask, int set)\n{\n\tif (!(mask & TRACE_ITER_FUNCTION))\n\t\treturn 0;\n\n\tif (set)\n\t\tregister_irqsoff_function(tr, is_graph(tr), 1);\n\telse\n\t\tunregister_irqsoff_function(tr, is_graph(tr));\n\treturn 1;\n}"
  },
  {
    "function_name": "unregister_irqsoff_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "475-486",
    "snippet": "static void unregister_irqsoff_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph(&fgraph_ops);\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [
            "&fgraph_ops"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void unregister_irqsoff_function(struct trace_array *tr, int graph)\n{\n\tif (!function_enabled)\n\t\treturn;\n\n\tif (graph)\n\t\tunregister_ftrace_graph(&fgraph_ops);\n\telse\n\t\tunregister_ftrace_function(tr->ops);\n\n\tfunction_enabled = false;\n}"
  },
  {
    "function_name": "register_irqsoff_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "456-473",
    "snippet": "static int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&fgraph_ops);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&fgraph_ops"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int register_irqsoff_function(struct trace_array *tr, int graph, int set)\n{\n\tint ret;\n\n\t/* 'set' is set if TRACE_ITER_FUNCTION is about to be set */\n\tif (function_enabled || (!set && !(tr->trace_flags & TRACE_ITER_FUNCTION)))\n\t\treturn 0;\n\n\tif (graph)\n\t\tret = register_ftrace_graph(&fgraph_ops);\n\telse\n\t\tret = register_ftrace_function(tr->ops);\n\n\tif (!ret)\n\t\tfunction_enabled = true;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "stop_critical_timings",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "445-449",
    "snippet": "void stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_critical_timing",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "403-434",
          "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
  },
  {
    "function_name": "start_critical_timings",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "437-441",
    "snippet": "void start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_critical_timing",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "370-401",
          "snippet": "static nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_trace",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "irq_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "54-59",
          "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_trace",
          "args": [
            "preempt_count()"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "44-48",
          "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tif (preempt_trace(preempt_count()) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1);\n}"
  },
  {
    "function_name": "stop_critical_timing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "403-434",
    "snippet": "static nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_critical_timing",
          "args": [
            "tr",
            "data",
            "parent_ip ? : ip",
            "cpu"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "check_critical_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "320-368",
          "snippet": "static void\ncheck_critical_timing(struct trace_array *tr,\n\t\t      struct trace_array_cpu *data,\n\t\t      unsigned long parent_ip,\n\t\t      int cpu)\n{\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tif (!report_latency(tr, delta))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&max_trace_lock, flags);\n\n\t/* check if we are still the max latency */\n\tif (!report_latency(tr, delta))\n\t\tgoto out_unlock;\n\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n\t/* Skip 5 functions to get to the irq/preempt enable function */\n\t__trace_stack(tr, trace_ctx, 5);\n\n\tif (data->critical_sequence != max_sequence)\n\t\tgoto out_unlock;\n\n\tdata->critical_end = parent_ip;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\ttr->max_latency = delta;\n\t\tupdate_max_tr_single(tr, current, cpu);\n\t}\n\n\tmax_sequence++;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&max_trace_lock, flags);\n\nout:\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\ncheck_critical_timing(struct trace_array *tr,\n\t\t      struct trace_array_cpu *data,\n\t\t      unsigned long parent_ip,\n\t\t      int cpu)\n{\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tif (!report_latency(tr, delta))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&max_trace_lock, flags);\n\n\t/* check if we are still the max latency */\n\tif (!report_latency(tr, delta))\n\t\tgoto out_unlock;\n\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n\t/* Skip 5 functions to get to the irq/preempt enable function */\n\t__trace_stack(tr, trace_ctx, 5);\n\n\tif (data->critical_sequence != max_sequence)\n\t\tgoto out_unlock;\n\n\tdata->critical_end = parent_ip;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\ttr->max_latency = delta;\n\t\tupdate_max_tr_single(tr, current, cpu);\n\t}\n\n\tmax_sequence++;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&max_trace_lock, flags);\n\nout:\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "270-279",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->disabled"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_is_enabled",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "779-788",
          "snippet": "int tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tracing_cpu",
            "cpu"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "per_cpu(tracing_cpu, cpu)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstop_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned int trace_ctx;\n\n\tcpu = raw_smp_processor_id();\n\t/* Always clear the tracing cpu on stopping the trace */\n\tif (unlikely(per_cpu(tracing_cpu, cpu)))\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\telse\n\t\treturn;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) ||\n\t    !data->critical_start || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\ttrace_ctx = tracing_gen_ctx();\n\t__trace_function(tr, ip, parent_ip, trace_ctx);\n\tcheck_critical_timing(tr, data, parent_ip ? : ip, cpu);\n\tdata->critical_start = 0;\n\tatomic_dec(&data->disabled);\n}"
  },
  {
    "function_name": "start_critical_timing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "370-401",
    "snippet": "static nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tracing_cpu",
            "cpu"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "tracing_gen_ctx()"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "270-279",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "765-768",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->disabled"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->disabled"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_is_enabled",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "779-788",
          "snippet": "int tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic nokprobe_inline void\nstart_critical_timing(unsigned long ip, unsigned long parent_ip)\n{\n\tint cpu;\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\n\tif (!tracer_enabled || !tracing_is_enabled())\n\t\treturn;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (per_cpu(tracing_cpu, cpu))\n\t\treturn;\n\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\n\tif (unlikely(!data) || atomic_read(&data->disabled))\n\t\treturn;\n\n\tatomic_inc(&data->disabled);\n\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\tdata->critical_start = parent_ip ? : ip;\n\n\t__trace_function(tr, ip, parent_ip, tracing_gen_ctx());\n\n\tper_cpu(tracing_cpu, cpu) = 1;\n\n\tatomic_dec(&data->disabled);\n}"
  },
  {
    "function_name": "check_critical_timing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "320-368",
    "snippet": "static void\ncheck_critical_timing(struct trace_array *tr,\n\t\t      struct trace_array_cpu *data,\n\t\t      unsigned long parent_ip,\n\t\t      int cpu)\n{\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tif (!report_latency(tr, delta))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&max_trace_lock, flags);\n\n\t/* check if we are still the max latency */\n\tif (!report_latency(tr, delta))\n\t\tgoto out_unlock;\n\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n\t/* Skip 5 functions to get to the irq/preempt enable function */\n\t__trace_stack(tr, trace_ctx, 5);\n\n\tif (data->critical_sequence != max_sequence)\n\t\tgoto out_unlock;\n\n\tdata->critical_end = parent_ip;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\ttr->max_latency = delta;\n\t\tupdate_max_tr_single(tr, current, cpu);\n\t}\n\n\tmax_sequence++;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&max_trace_lock, flags);\n\nout:\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_function",
          "args": [
            "tr",
            "CALLER_ADDR0",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "270-279",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_now",
          "args": [
            "cpu"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "765-768",
          "snippet": "u64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&max_trace_lock",
            "flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_max_tr_single",
          "args": [
            "tr",
            "current",
            "cpu"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_tracing_stopped()"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_tracing_stopped",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "is_tracing_stopped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2247-2250",
          "snippet": "int is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_stack",
          "args": [
            "tr",
            "trace_ctx",
            "5"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3078-3100",
          "snippet": "void __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nvoid __trace_stack(struct trace_array *tr, unsigned int trace_ctx,\n\t\t   int skip)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, trace_ctx, skip, NULL);\n\trcu_irq_exit_irqson();\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_latency",
          "args": [
            "tr",
            "delta"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "report_latency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "308-318",
          "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&max_trace_lock",
            "flags"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\ncheck_critical_timing(struct trace_array *tr,\n\t\t      struct trace_array_cpu *data,\n\t\t      unsigned long parent_ip,\n\t\t      int cpu)\n{\n\tu64 T0, T1, delta;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tT0 = data->preempt_timestamp;\n\tT1 = ftrace_now(cpu);\n\tdelta = T1-T0;\n\n\ttrace_ctx = tracing_gen_ctx();\n\n\tif (!report_latency(tr, delta))\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&max_trace_lock, flags);\n\n\t/* check if we are still the max latency */\n\tif (!report_latency(tr, delta))\n\t\tgoto out_unlock;\n\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n\t/* Skip 5 functions to get to the irq/preempt enable function */\n\t__trace_stack(tr, trace_ctx, 5);\n\n\tif (data->critical_sequence != max_sequence)\n\t\tgoto out_unlock;\n\n\tdata->critical_end = parent_ip;\n\n\tif (likely(!is_tracing_stopped())) {\n\t\ttr->max_latency = delta;\n\t\tupdate_max_tr_single(tr, current, cpu);\n\t}\n\n\tmax_sequence++;\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&max_trace_lock, flags);\n\nout:\n\tdata->critical_sequence = max_sequence;\n\tdata->preempt_timestamp = ftrace_now(cpu);\n\t__trace_function(tr, CALLER_ADDR0, parent_ip, trace_ctx);\n}"
  },
  {
    "function_name": "report_latency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "308-318",
    "snippet": "static bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic bool report_latency(struct trace_array *tr, u64 delta)\n{\n\tif (tracing_thresh) {\n\t\tif (delta < tracing_thresh)\n\t\t\treturn false;\n\t} else {\n\t\tif (delta <= tr->max_latency)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "irqsoff_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "298-301",
    "snippet": "static void irqsoff_print_header(struct seq_file *s)\n{\n\ttrace_latency_header(s);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_latency_header",
          "args": [
            "s"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "trace_latency_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4530-4544",
          "snippet": "void trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t/* print nothing if the buffers are empty */\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(tr->trace_flags & TRACE_ITER_VERBOSE))\n\t\tprint_lat_help_header(m);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t/* print nothing if the buffers are empty */\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(tr->trace_flags & TRACE_ITER_VERBOSE))\n\t\tprint_lat_help_header(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_print_header(struct seq_file *s)\n{\n\ttrace_latency_header(s);\n}"
  },
  {
    "function_name": "irqsoff_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "293-296",
    "snippet": "static void irqsoff_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4546-4572",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_print_header(struct seq_file *s)\n{\n\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "irqsoff_trace_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "290-290",
    "snippet": "static void irqsoff_trace_close(struct trace_iterator *iter) { }",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_trace_close(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "irqsoff_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "289-289",
    "snippet": "static void irqsoff_trace_open(struct trace_iterator *iter) { }",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_trace_open(struct trace_iterator *iter) { }"
  },
  {
    "function_name": "irqsoff_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "284-287",
    "snippet": "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic enum print_line_t irqsoff_print_line(struct trace_iterator *iter)\n{\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "__trace_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "270-279",
    "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define __trace_function trace_function"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "270-279",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_graph_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "208-214",
          "snippet": "void\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
  },
  {
    "function_name": "irqsoff_print_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "260-268",
    "snippet": "static void irqsoff_print_header(struct seq_file *s)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\n\tif (is_graph(tr))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_CPU | \\\n\t\t\t    TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_default_header",
          "args": [
            "s"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "trace_default_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4546-4572",
          "snippet": "void trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_headers_flags",
          "args": [
            "s",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_headers_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1179-1196",
          "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_CPU | \\\n\t\t\t    TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)\n\nstatic void irqsoff_print_header(struct seq_file *s)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\n\tif (is_graph(tr))\n\t\tprint_graph_headers_flags(s, GRAPH_TRACER_FLAGS);\n\telse\n\t\ttrace_default_header(s);\n}"
  },
  {
    "function_name": "irqsoff_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "248-258",
    "snippet": "static enum print_line_t irqsoff_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [
      "#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_CPU | \\\n\t\t\t    TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function_flags",
          "args": [
            "iter",
            "GRAPH_TRACER_FLAGS"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1036-1095",
          "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define GRAPH_TRACER_FLAGS (TRACE_GRAPH_PRINT_CPU | \\\n\t\t\t    TRACE_GRAPH_PRINT_PROC | \\\n\t\t\t    TRACE_GRAPH_PRINT_REL_TIME | \\\n\t\t\t    TRACE_GRAPH_PRINT_DURATION)\n\nstatic enum print_line_t irqsoff_print_line(struct trace_iterator *iter)\n{\n\t/*\n\t * In graph mode call the graph tracer output function,\n\t * otherwise go with the TRACE_FN event handler\n\t */\n\tif (is_graph(iter->tr))\n\t\treturn print_graph_function_flags(iter, GRAPH_TRACER_FLAGS);\n\n\treturn TRACE_TYPE_UNHANDLED;\n}"
  },
  {
    "function_name": "irqsoff_trace_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "237-241",
    "snippet": "static void irqsoff_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_close",
          "args": [
            "iter"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_close",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1240-1248",
          "snippet": "void graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_trace_close(struct trace_iterator *iter)\n{\n\tif (iter->private)\n\t\tgraph_trace_close(iter);\n}"
  },
  {
    "function_name": "irqsoff_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "230-235",
    "snippet": "static void irqsoff_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_open",
          "args": [
            "iter"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1198-1238",
          "snippet": "void graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "iter->tr"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_trace_open(struct trace_iterator *iter)\n{\n\tif (is_graph(iter->tr))\n\t\tgraph_trace_open(iter);\n\n}"
  },
  {
    "function_name": "irqsoff_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "208-223",
    "snippet": "static void irqsoff_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t__trace_graph_return(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "216-233",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_dec",
          "args": [
            "tr",
            "&data",
            "&flags"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "99-134",
          "snippet": "static int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_addr_finish",
          "args": [
            "trace"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_addr_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "947-948",
          "snippet": "static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void irqsoff_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t__trace_graph_return(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n}"
  },
  {
    "function_name": "irqsoff_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "178-206",
    "snippet": "static int irqsoff_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tint ret;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn 0;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "97-116",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_dec",
          "args": [
            "tr",
            "&data",
            "&flags"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "99-134",
          "snippet": "static int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "trace->func"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "943-946",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_func",
          "args": [
            "trace"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "953-960",
          "snippet": "static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tint ret;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn 0;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\tatomic_dec(&data->disabled);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "irqsoff_display_graph",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "160-176",
    "snippet": "static int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\tint cpu;\n\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_irqsoff_tracer(irqsoff_trace, !set);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\n\ttr->max_latency = 0;\n\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);\n\n\treturn start_irqsoff_tracer(irqsoff_trace, set);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_irqsoff_tracer",
          "args": [
            "irqsoff_trace",
            "set"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "start_irqsoff_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "526-538",
          "snippet": "static int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int start_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\tint ret;\n\n\tret = register_irqsoff_function(tr, graph, 0);\n\n\tif (!ret && tracing_is_enabled())\n\t\ttracer_enabled = 1;\n\telse\n\t\ttracer_enabled = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&irqsoff_trace->array_buffer"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2138-2155",
          "snippet": "void tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_irqsoff_tracer",
          "args": [
            "irqsoff_trace",
            "!set"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "stop_irqsoff_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "540-545",
          "snippet": "static void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void stop_irqsoff_tracer(struct trace_array *tr, int graph)\n{\n\ttracer_enabled = 0;\n\n\tunregister_irqsoff_function(tr, graph);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_graph",
          "args": [
            "tr"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\tint cpu;\n\n\tif (!(is_graph(tr) ^ set))\n\t\treturn 0;\n\n\tstop_irqsoff_tracer(irqsoff_trace, !set);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(tracing_cpu, cpu) = 0;\n\n\ttr->max_latency = 0;\n\ttracing_reset_online_cpus(&irqsoff_trace->array_buffer);\n\n\treturn start_irqsoff_tracer(irqsoff_trace, set);\n}"
  },
  {
    "function_name": "irqsoff_tracer_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "139-156",
    "snippet": "static void\nirqsoff_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\n\tatomic_dec(&data->disabled);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_function",
          "args": [
            "tr",
            "ip",
            "parent_ip",
            "trace_ctx"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "270-279",
          "snippet": "static void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [
            "#define __trace_function trace_function"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n#define __trace_function trace_function\n\nstatic void\n__trace_function(struct trace_array *tr,\n\t\t unsigned long ip, unsigned long parent_ip,\n\t\t unsigned int trace_ctx)\n{\n\tif (is_graph(tr))\n\t\ttrace_graph_function(tr, ip, parent_ip, trace_ctx);\n\telse\n\t\ttrace_function(tr, ip, parent_ip, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_prolog_dec",
          "args": [
            "tr",
            "&data",
            "&flags"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "func_prolog_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
          "lines": "99-134",
          "snippet": "static int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic void\nirqsoff_tracer_call(unsigned long ip, unsigned long parent_ip,\n\t\t    struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tstruct trace_array *tr = irqsoff_trace;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\n\tif (!func_prolog_dec(tr, &data, &flags))\n\t\treturn;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\n\ttrace_function(tr, ip, parent_ip, trace_ctx);\n\n\tatomic_dec(&data->disabled);\n}"
  },
  {
    "function_name": "func_prolog_dec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "99-134",
    "snippet": "static int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&(*data)->disabled"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "*flags"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "*flags"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!per_cpu(tracing_cpu, cpu)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tracing_cpu",
            "cpu"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t/*\n\t * Does not matter if we preempt. We test the flags\n\t * afterward, to see if irqs are disabled or not.\n\t * If we preempt and get a false positive, the flags\n\t * test will fail.\n\t */\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t/*\n\t * Slight chance to get a false positive on tracing_cpu,\n\t * although I'm starting to think there isn't a chance.\n\t * Leave this for now just to be paranoid.\n\t */\n\tif (!irqs_disabled_flags(*flags) && !preempt_count())\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&(*data)->disabled);\n\n\tif (likely(disabled == 1))\n\t\treturn 1;\n\n\tatomic_dec(&(*data)->disabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irqsoff_display_graph",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "68-71",
    "snippet": "static inline int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int irqsoff_display_graph(struct trace_array *tr, int set)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "irq_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "54-59",
    "snippet": "static inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & TRACER_IRQS_OFF) &&\n\t\tirqs_disabled());\n}"
  },
  {
    "function_name": "preempt_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_irqsoff.c",
    "lines": "44-48",
    "snippet": "static inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nstatic inline int\npreempt_trace(int pc)\n{\n\treturn ((trace_type & TRACER_PREEMPT_OFF) && pc);\n}"
  }
]