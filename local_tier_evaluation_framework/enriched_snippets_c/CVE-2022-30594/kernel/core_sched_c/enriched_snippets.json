[
  {
    "function_name": "__sched_core_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "287-296",
    "snippet": "void __sched_core_tick(struct rq *rq)\n{\n\tif (!rq->core->core_forceidle_count)\n\t\treturn;\n\n\tif (rq != rq->core)\n\t\tupdate_rq_clock(rq->core);\n\n\t__sched_core_account_forceidle(rq);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sched_core_account_forceidle",
          "args": [
            "rq"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_core_account_forceidle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "242-285",
          "snippet": "void __sched_core_account_forceidle(struct rq *rq)\n{\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));\n\tu64 delta, now = rq_clock(rq->core);\n\tstruct rq *rq_i;\n\tstruct task_struct *p;\n\tint i;\n\n\tlockdep_assert_rq_held(rq);\n\n\tWARN_ON_ONCE(!rq->core->core_forceidle_count);\n\n\tif (rq->core->core_forceidle_start == 0)\n\t\treturn;\n\n\tdelta = now - rq->core->core_forceidle_start;\n\tif (unlikely((s64)delta <= 0))\n\t\treturn;\n\n\trq->core->core_forceidle_start = now;\n\n\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {\n\t\t/* can't be forced idle without a running task */\n\t} else if (rq->core->core_forceidle_count > 1 ||\n\t\t   rq->core->core_forceidle_occupation > 1) {\n\t\t/*\n\t\t * For larger SMT configurations, we need to scale the charged\n\t\t * forced idle amount since there can be more than one forced\n\t\t * idle sibling and more than one running cookied task.\n\t\t */\n\t\tdelta *= rq->core->core_forceidle_count;\n\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);\n\t}\n\n\tfor_each_cpu(i, smt_mask) {\n\t\trq_i = cpu_rq(i);\n\t\tp = rq_i->core_pick ?: rq_i->curr;\n\n\t\tif (!p->core_cookie)\n\t\t\tcontinue;\n\n\t\t__schedstat_add(p->stats.core_forceidle_sum, delta);\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nvoid __sched_core_account_forceidle(struct rq *rq)\n{\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));\n\tu64 delta, now = rq_clock(rq->core);\n\tstruct rq *rq_i;\n\tstruct task_struct *p;\n\tint i;\n\n\tlockdep_assert_rq_held(rq);\n\n\tWARN_ON_ONCE(!rq->core->core_forceidle_count);\n\n\tif (rq->core->core_forceidle_start == 0)\n\t\treturn;\n\n\tdelta = now - rq->core->core_forceidle_start;\n\tif (unlikely((s64)delta <= 0))\n\t\treturn;\n\n\trq->core->core_forceidle_start = now;\n\n\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {\n\t\t/* can't be forced idle without a running task */\n\t} else if (rq->core->core_forceidle_count > 1 ||\n\t\t   rq->core->core_forceidle_occupation > 1) {\n\t\t/*\n\t\t * For larger SMT configurations, we need to scale the charged\n\t\t * forced idle amount since there can be more than one forced\n\t\t * idle sibling and more than one running cookied task.\n\t\t */\n\t\tdelta *= rq->core->core_forceidle_count;\n\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);\n\t}\n\n\tfor_each_cpu(i, smt_mask) {\n\t\trq_i = cpu_rq(i);\n\t\tp = rq_i->core_pick ?: rq_i->curr;\n\n\t\tif (!p->core_cookie)\n\t\t\tcontinue;\n\n\t\t__schedstat_add(p->stats.core_forceidle_sum, delta);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq->core"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nvoid __sched_core_tick(struct rq *rq)\n{\n\tif (!rq->core->core_forceidle_count)\n\t\treturn;\n\n\tif (rq != rq->core)\n\t\tupdate_rq_clock(rq->core);\n\n\t__sched_core_account_forceidle(rq);\n}"
  },
  {
    "function_name": "__sched_core_account_forceidle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "242-285",
    "snippet": "void __sched_core_account_forceidle(struct rq *rq)\n{\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));\n\tu64 delta, now = rq_clock(rq->core);\n\tstruct rq *rq_i;\n\tstruct task_struct *p;\n\tint i;\n\n\tlockdep_assert_rq_held(rq);\n\n\tWARN_ON_ONCE(!rq->core->core_forceidle_count);\n\n\tif (rq->core->core_forceidle_start == 0)\n\t\treturn;\n\n\tdelta = now - rq->core->core_forceidle_start;\n\tif (unlikely((s64)delta <= 0))\n\t\treturn;\n\n\trq->core->core_forceidle_start = now;\n\n\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {\n\t\t/* can't be forced idle without a running task */\n\t} else if (rq->core->core_forceidle_count > 1 ||\n\t\t   rq->core->core_forceidle_occupation > 1) {\n\t\t/*\n\t\t * For larger SMT configurations, we need to scale the charged\n\t\t * forced idle amount since there can be more than one forced\n\t\t * idle sibling and more than one running cookied task.\n\t\t */\n\t\tdelta *= rq->core->core_forceidle_count;\n\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);\n\t}\n\n\tfor_each_cpu(i, smt_mask) {\n\t\trq_i = cpu_rq(i);\n\t\tp = rq_i->core_pick ?: rq_i->curr;\n\n\t\tif (!p->core_cookie)\n\t\t\tcontinue;\n\n\t\t__schedstat_add(p->stats.core_forceidle_sum, delta);\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "p->stats.core_forceidle_sum",
            "delta"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "smt_mask"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "delta",
            "rq->core->core_forceidle_occupation"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rq->core->core_forceidle_occupation"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(s64)delta <= 0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rq->core->core_forceidle_count"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq->core"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpu_smt_mask",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1137-1144",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nvoid __sched_core_account_forceidle(struct rq *rq)\n{\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));\n\tu64 delta, now = rq_clock(rq->core);\n\tstruct rq *rq_i;\n\tstruct task_struct *p;\n\tint i;\n\n\tlockdep_assert_rq_held(rq);\n\n\tWARN_ON_ONCE(!rq->core->core_forceidle_count);\n\n\tif (rq->core->core_forceidle_start == 0)\n\t\treturn;\n\n\tdelta = now - rq->core->core_forceidle_start;\n\tif (unlikely((s64)delta <= 0))\n\t\treturn;\n\n\trq->core->core_forceidle_start = now;\n\n\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {\n\t\t/* can't be forced idle without a running task */\n\t} else if (rq->core->core_forceidle_count > 1 ||\n\t\t   rq->core->core_forceidle_occupation > 1) {\n\t\t/*\n\t\t * For larger SMT configurations, we need to scale the charged\n\t\t * forced idle amount since there can be more than one forced\n\t\t * idle sibling and more than one running cookied task.\n\t\t */\n\t\tdelta *= rq->core->core_forceidle_count;\n\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);\n\t}\n\n\tfor_each_cpu(i, smt_mask) {\n\t\trq_i = cpu_rq(i);\n\t\tp = rq_i->core_pick ?: rq_i->curr;\n\n\t\tif (!p->core_cookie)\n\t\t\tcontinue;\n\n\t\t__schedstat_add(p->stats.core_forceidle_sum, delta);\n\t}\n}"
  },
  {
    "function_name": "sched_core_share_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "131-237",
    "snippet": "int sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,\n\t\t\t unsigned long uaddr)\n{\n\tunsigned long cookie = 0, id = 0;\n\tstruct task_struct *task, *p;\n\tstruct pid *grp;\n\tint err = 0;\n\n\tif (!static_branch_likely(&sched_smt_present))\n\t\treturn -ENODEV;\n\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);\n\n\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||\n\t    (cmd != PR_SCHED_CORE_GET && uaddr))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (pid == 0) {\n\t\ttask = current;\n\t} else {\n\t\ttask = find_task_by_vpid(pid);\n\t\tif (!task) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\tget_task_struct(task);\n\trcu_read_unlock();\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase PR_SCHED_CORE_GET:\n\t\tif (type != PIDTYPE_PID || uaddr & 7) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\tif (cookie) {\n\t\t\t/* XXX improve ? */\n\t\t\tptr_to_hashval((void *)cookie, &id);\n\t\t}\n\t\terr = put_user(id, (u64 __user *)uaddr);\n\t\tgoto out;\n\n\tcase PR_SCHED_CORE_CREATE:\n\t\tcookie = sched_core_alloc_cookie();\n\t\tif (!cookie) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_TO:\n\t\tcookie = sched_core_clone_cookie(current);\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_FROM:\n\t\tif (type != PIDTYPE_PID) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\t__sched_core_set(current, cookie);\n\t\tgoto out;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t};\n\n\tif (type == PIDTYPE_PID) {\n\t\t__sched_core_set(task, cookie);\n\t\tgoto out;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tgrp = task_pid_type(task, type);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_tasklist;\n\t\t}\n\t} while_each_pid_thread(grp, type, p);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\t__sched_core_set(p, cookie);\n\t} while_each_pid_thread(grp, type, p);\nout_tasklist:\n\tread_unlock(&tasklist_lock);\n\nout:\n\tsched_core_put_cookie(cookie);\n\tput_task_struct(task);\n\treturn err;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_put_cookie",
          "args": [
            "cookie"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_put_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "26-34",
          "snippet": "static void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_pid_thread",
          "args": [
            "grp",
            "type",
            "p"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_core_set",
          "args": [
            "p",
            "cookie"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_core_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "123-128",
          "snippet": "static void __sched_core_set(struct task_struct *p, unsigned long cookie)\n{\n\tcookie = sched_core_get_cookie(cookie);\n\tcookie = sched_core_update_cookie(p, cookie);\n\tsched_core_put_cookie(cookie);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void __sched_core_set(struct task_struct *p, unsigned long cookie)\n{\n\tcookie = sched_core_get_cookie(cookie);\n\tcookie = sched_core_update_cookie(p, cookie);\n\tsched_core_put_cookie(cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_pid_thread",
          "args": [
            "grp",
            "type",
            "p"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_pid_thread",
          "args": [
            "grp",
            "type",
            "p"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "p",
            "PTRACE_MODE_READ_REALCREDS"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_may_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
          "lines": "365-372",
          "snippet": "bool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}",
          "includes": [
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <linux/minmax.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nbool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_pid_thread",
          "args": [
            "grp",
            "type",
            "p"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_type",
          "args": [
            "task",
            "type"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_clone_cookie",
          "args": [
            "task"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_clone_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "101-110",
          "snippet": "static unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_alloc_cookie",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_alloc_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "14-24",
          "snippet": "static unsigned long sched_core_alloc_cookie(void)\n{\n\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);\n\tif (!ck)\n\t\treturn 0;\n\n\trefcount_set(&ck->refcnt, 1);\n\tsched_core_get();\n\n\treturn (unsigned long)ck;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_alloc_cookie(void)\n{\n\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);\n\tif (!ck)\n\t\treturn 0;\n\n\trefcount_set(&ck->refcnt, 1);\n\tsched_core_get();\n\n\treturn (unsigned long)ck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "id",
            "(u64 __user *)uaddr"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_hashval",
          "args": [
            "(void *)cookie",
            "&id"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "420-423",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_smt_present"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nint sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,\n\t\t\t unsigned long uaddr)\n{\n\tunsigned long cookie = 0, id = 0;\n\tstruct task_struct *task, *p;\n\tstruct pid *grp;\n\tint err = 0;\n\n\tif (!static_branch_likely(&sched_smt_present))\n\t\treturn -ENODEV;\n\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);\n\n\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||\n\t    (cmd != PR_SCHED_CORE_GET && uaddr))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (pid == 0) {\n\t\ttask = current;\n\t} else {\n\t\ttask = find_task_by_vpid(pid);\n\t\tif (!task) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\tget_task_struct(task);\n\trcu_read_unlock();\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase PR_SCHED_CORE_GET:\n\t\tif (type != PIDTYPE_PID || uaddr & 7) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\tif (cookie) {\n\t\t\t/* XXX improve ? */\n\t\t\tptr_to_hashval((void *)cookie, &id);\n\t\t}\n\t\terr = put_user(id, (u64 __user *)uaddr);\n\t\tgoto out;\n\n\tcase PR_SCHED_CORE_CREATE:\n\t\tcookie = sched_core_alloc_cookie();\n\t\tif (!cookie) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_TO:\n\t\tcookie = sched_core_clone_cookie(current);\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_FROM:\n\t\tif (type != PIDTYPE_PID) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\t__sched_core_set(current, cookie);\n\t\tgoto out;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t};\n\n\tif (type == PIDTYPE_PID) {\n\t\t__sched_core_set(task, cookie);\n\t\tgoto out;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tgrp = task_pid_type(task, type);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_tasklist;\n\t\t}\n\t} while_each_pid_thread(grp, type, p);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\t__sched_core_set(p, cookie);\n\t} while_each_pid_thread(grp, type, p);\nout_tasklist:\n\tread_unlock(&tasklist_lock);\n\nout:\n\tsched_core_put_cookie(cookie);\n\tput_task_struct(task);\n\treturn err;\n}"
  },
  {
    "function_name": "__sched_core_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "123-128",
    "snippet": "static void __sched_core_set(struct task_struct *p, unsigned long cookie)\n{\n\tcookie = sched_core_get_cookie(cookie);\n\tcookie = sched_core_update_cookie(p, cookie);\n\tsched_core_put_cookie(cookie);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_core_put_cookie",
          "args": [
            "cookie"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_put_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "26-34",
          "snippet": "static void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_update_cookie",
          "args": [
            "p",
            "cookie"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_update_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "56-99",
          "snippet": "static unsigned long sched_core_update_cookie(struct task_struct *p,\n\t\t\t\t\t      unsigned long cookie)\n{\n\tunsigned long old_cookie;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tbool enqueued;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * Since creating a cookie implies sched_core_get(), and we cannot set\n\t * a cookie until after we've created it, similarly, we cannot destroy\n\t * a cookie until after we've removed it, we must have core scheduling\n\t * enabled here.\n\t */\n\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));\n\n\tenqueued = sched_core_enqueued(p);\n\tif (enqueued)\n\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);\n\n\told_cookie = p->core_cookie;\n\tp->core_cookie = cookie;\n\n\tif (enqueued)\n\t\tsched_core_enqueue(rq, p);\n\n\t/*\n\t * If task is currently running, it may not be compatible anymore after\n\t * the cookie change, so enter the scheduler on its CPU to schedule it\n\t * away.\n\t *\n\t * Note that it is possible that as a result of this cookie change, the\n\t * core has now entered/left forced idle state. Defer accounting to the\n\t * next scheduling edge, rather than always forcing a reschedule here.\n\t */\n\tif (task_running(rq, p))\n\t\tresched_curr(rq);\n\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn old_cookie;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_update_cookie(struct task_struct *p,\n\t\t\t\t\t      unsigned long cookie)\n{\n\tunsigned long old_cookie;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tbool enqueued;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * Since creating a cookie implies sched_core_get(), and we cannot set\n\t * a cookie until after we've created it, similarly, we cannot destroy\n\t * a cookie until after we've removed it, we must have core scheduling\n\t * enabled here.\n\t */\n\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));\n\n\tenqueued = sched_core_enqueued(p);\n\tif (enqueued)\n\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);\n\n\told_cookie = p->core_cookie;\n\tp->core_cookie = cookie;\n\n\tif (enqueued)\n\t\tsched_core_enqueue(rq, p);\n\n\t/*\n\t * If task is currently running, it may not be compatible anymore after\n\t * the cookie change, so enter the scheduler on its CPU to schedule it\n\t * away.\n\t *\n\t * Note that it is possible that as a result of this cookie change, the\n\t * core has now entered/left forced idle state. Defer accounting to the\n\t * next scheduling edge, rather than always forcing a reschedule here.\n\t */\n\tif (task_running(rq, p))\n\t\tresched_curr(rq);\n\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn old_cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_get_cookie",
          "args": [
            "cookie"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_get_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "36-44",
          "snippet": "static unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void __sched_core_set(struct task_struct *p, unsigned long cookie)\n{\n\tcookie = sched_core_get_cookie(cookie);\n\tcookie = sched_core_update_cookie(p, cookie);\n\tsched_core_put_cookie(cookie);\n}"
  },
  {
    "function_name": "sched_core_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "118-121",
    "snippet": "void sched_core_free(struct task_struct *p)\n{\n\tsched_core_put_cookie(p->core_cookie);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_core_put_cookie",
          "args": [
            "p->core_cookie"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_put_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "26-34",
          "snippet": "static void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nvoid sched_core_free(struct task_struct *p)\n{\n\tsched_core_put_cookie(p->core_cookie);\n}"
  },
  {
    "function_name": "sched_core_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "112-116",
    "snippet": "void sched_core_fork(struct task_struct *p)\n{\n\tRB_CLEAR_NODE(&p->core_node);\n\tp->core_cookie = sched_core_clone_cookie(current);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_core_clone_cookie",
          "args": [
            "current"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_clone_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "101-110",
          "snippet": "static unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&p->core_node"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nvoid sched_core_fork(struct task_struct *p)\n{\n\tRB_CLEAR_NODE(&p->core_node);\n\tp->core_cookie = sched_core_clone_cookie(current);\n}"
  },
  {
    "function_name": "sched_core_clone_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "101-110",
    "snippet": "static unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_get_cookie",
          "args": [
            "p->core_cookie"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_get_cookie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
          "lines": "36-44",
          "snippet": "static unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/prctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}"
  },
  {
    "function_name": "sched_core_update_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "56-99",
    "snippet": "static unsigned long sched_core_update_cookie(struct task_struct *p,\n\t\t\t\t\t      unsigned long cookie)\n{\n\tunsigned long old_cookie;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tbool enqueued;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * Since creating a cookie implies sched_core_get(), and we cannot set\n\t * a cookie until after we've created it, similarly, we cannot destroy\n\t * a cookie until after we've removed it, we must have core scheduling\n\t * enabled here.\n\t */\n\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));\n\n\tenqueued = sched_core_enqueued(p);\n\tif (enqueued)\n\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);\n\n\told_cookie = p->core_cookie;\n\tp->core_cookie = cookie;\n\n\tif (enqueued)\n\t\tsched_core_enqueue(rq, p);\n\n\t/*\n\t * If task is currently running, it may not be compatible anymore after\n\t * the cookie change, so enter the scheduler on its CPU to schedule it\n\t * away.\n\t *\n\t * Note that it is possible that as a result of this cookie change, the\n\t * core has now entered/left forced idle state. Defer accounting to the\n\t * next scheduling edge, rather than always forcing a reschedule here.\n\t */\n\tif (task_running(rq, p))\n\t\tresched_curr(rq);\n\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn old_cookie;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2035-2042",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_enqueue",
          "args": [
            "rq",
            "p"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "376-376",
          "snippet": "static inline void sched_core_enqueue(struct rq *rq, struct task_struct *p) { }",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void sched_core_enqueue(struct rq *rq, struct task_struct *p) { }"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_dequeue",
          "args": [
            "rq",
            "p",
            "DEQUEUE_SAVE"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "377-378",
          "snippet": "static inline void\nsched_core_dequeue(struct rq *rq, struct task_struct *p, int flags) { }",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void\nsched_core_dequeue(struct rq *rq, struct task_struct *p, int flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "sched_core_enqueued",
          "args": [
            "p"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_enqueued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1252-1255",
          "snippet": "static inline bool sched_core_enqueued(struct task_struct *p)\n{\n\treturn !RB_EMPTY_NODE(&p->core_node);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline bool sched_core_enqueued(struct task_struct *p)\n{\n\treturn !RB_EMPTY_NODE(&p->core_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "(p->core_cookie || cookie) && !sched_core_enabled(rq)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_core_enabled",
          "args": [
            "rq"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1265-1268",
          "snippet": "static inline bool sched_core_enabled(struct rq *rq)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline bool sched_core_enabled(struct rq *rq)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "582-619",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_update_cookie(struct task_struct *p,\n\t\t\t\t\t      unsigned long cookie)\n{\n\tunsigned long old_cookie;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tbool enqueued;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * Since creating a cookie implies sched_core_get(), and we cannot set\n\t * a cookie until after we've created it, similarly, we cannot destroy\n\t * a cookie until after we've removed it, we must have core scheduling\n\t * enabled here.\n\t */\n\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));\n\n\tenqueued = sched_core_enqueued(p);\n\tif (enqueued)\n\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);\n\n\told_cookie = p->core_cookie;\n\tp->core_cookie = cookie;\n\n\tif (enqueued)\n\t\tsched_core_enqueue(rq, p);\n\n\t/*\n\t * If task is currently running, it may not be compatible anymore after\n\t * the cookie change, so enter the scheduler on its CPU to schedule it\n\t * away.\n\t *\n\t * Note that it is possible that as a result of this cookie change, the\n\t * core has now entered/left forced idle state. Defer accounting to the\n\t * next scheduling edge, rather than always forcing a reschedule here.\n\t */\n\tif (task_running(rq, p))\n\t\tresched_curr(rq);\n\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn old_cookie;\n}"
  },
  {
    "function_name": "sched_core_get_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "36-44",
    "snippet": "static unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&ptr->refcnt"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}"
  },
  {
    "function_name": "sched_core_put_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "26-34",
    "snippet": "static void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_core_put",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "359-372",
          "snippet": "void sched_core_put(void)\n{\n\tstatic DECLARE_WORK(_work, __sched_core_put);\n\n\t/*\n\t * \"There can be only one\"\n\t *\n\t * Either this is the last one, or we don't actually need to do any\n\t * 'work'. If it is the last *again*, we rely on\n\t * WORK_STRUCT_PENDING_BIT.\n\t */\n\tif (!atomic_add_unless(&sched_core_count, -1, 1))\n\t\tschedule_work(&_work);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid sched_core_put(void)\n{\n\tstatic DECLARE_WORK(_work, __sched_core_put);\n\n\t/*\n\t * \"There can be only one\"\n\t *\n\t * Either this is the last one, or we don't actually need to do any\n\t * 'work'. If it is the last *again*, we rely on\n\t * WORK_STRUCT_PENDING_BIT.\n\t */\n\tif (!atomic_add_unless(&sched_core_count, -1, 1))\n\t\tschedule_work(&_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ptr"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&ptr->refcnt"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}"
  },
  {
    "function_name": "sched_core_alloc_cookie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core_sched.c",
    "lines": "14-24",
    "snippet": "static unsigned long sched_core_alloc_cookie(void)\n{\n\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);\n\tif (!ck)\n\t\treturn 0;\n\n\trefcount_set(&ck->refcnt, 1);\n\tsched_core_get();\n\n\treturn (unsigned long)ck;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/prctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_core_get",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "sched_core_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "337-349",
          "snippet": "void sched_core_get(void)\n{\n\tif (atomic_inc_not_zero(&sched_core_count))\n\t\treturn;\n\n\tmutex_lock(&sched_core_mutex);\n\tif (!atomic_read(&sched_core_count))\n\t\t__sched_core_enable();\n\n\tsmp_mb__before_atomic();\n\tatomic_inc(&sched_core_count);\n\tmutex_unlock(&sched_core_mutex);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid sched_core_get(void)\n{\n\tif (atomic_inc_not_zero(&sched_core_count))\n\t\treturn;\n\n\tmutex_lock(&sched_core_mutex);\n\tif (!atomic_read(&sched_core_count))\n\t\t__sched_core_enable();\n\n\tsmp_mb__before_atomic();\n\tatomic_inc(&sched_core_count);\n\tmutex_unlock(&sched_core_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&ck->refcnt",
            "1"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ck)",
            "GFP_KERNEL"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/prctl.h>\n\nstatic unsigned long sched_core_alloc_cookie(void)\n{\n\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);\n\tif (!ck)\n\t\treturn 0;\n\n\trefcount_set(&ck->refcnt, 1);\n\tsched_core_get();\n\n\treturn (unsigned long)ck;\n}"
  }
]