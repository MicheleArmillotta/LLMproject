[
  {
    "function_name": "bpf_base_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "1354-1459",
    "snippet": "const struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
      "const struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};",
      "const struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
      "const struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "const struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
      "const struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
      "const struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
      "const struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
      "const struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};",
      "static const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
      "const struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
      "const struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};",
      "const struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
      "static const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};",
      "static const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
      "static const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_trace_vprintk_proto",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_trace_vprintk_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2379-2382",
          "snippet": "const struct bpf_func_proto * __weak bpf_get_trace_vprintk_proto(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nconst struct bpf_func_proto * __weak bpf_get_trace_vprintk_proto(void)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_BPF_READ_KERNEL"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_BPF_READ_KERNEL"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_trace_printk_proto",
          "args": [],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_trace_printk_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2374-2377",
          "snippet": "const struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nconst struct bpf_func_proto * __weak bpf_get_trace_printk_proto(void)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perfmon_capable",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};\nstatic const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};\nconst struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};\nstatic const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};\n\nconst struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "bpf_timer_cancel_and_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "1302-1344",
    "snippet": "void bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&t->timer"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "hrtimer_running"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_spin_unlock_irqrestore",
          "args": [
            "&timer->lock"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_prog_refcnt",
          "args": [
            "t"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "drop_prog_refcnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "1250-1259",
          "snippet": "static void drop_prog_refcnt(struct bpf_hrtimer *t)\n{\n\tstruct bpf_prog *prog = t->prog;\n\n\tif (prog) {\n\t\tbpf_prog_put(prog);\n\t\tt->prog = NULL;\n\t\trcu_assign_pointer(t->callback_fn, NULL);\n\t}\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void drop_prog_refcnt(struct bpf_hrtimer *t)\n{\n\tstruct bpf_prog *prog = t->prog;\n\n\tif (prog) {\n\t\tbpf_prog_put(prog);\n\t\tt->prog = NULL;\n\t\trcu_assign_pointer(t->callback_fn, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_spin_lock_irqsave",
          "args": [
            "&timer->lock"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->timer"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);\n\nvoid bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}"
  },
  {
    "function_name": "drop_prog_refcnt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "1250-1259",
    "snippet": "static void drop_prog_refcnt(struct bpf_hrtimer *t)\n{\n\tstruct bpf_prog *prog = t->prog;\n\n\tif (prog) {\n\t\tbpf_prog_put(prog);\n\t\tt->prog = NULL;\n\t\trcu_assign_pointer(t->callback_fn, NULL);\n\t}\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "t->callback_fn",
            "NULL"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void drop_prog_refcnt(struct bpf_hrtimer *t)\n{\n\tstruct bpf_prog *prog = t->prog;\n\n\tif (prog) {\n\t\tbpf_prog_put(prog);\n\t\tt->prog = NULL;\n\t\trcu_assign_pointer(t->callback_fn, NULL);\n\t}\n}"
  },
  {
    "function_name": "bpf_timer_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "1069-1105",
    "snippet": "static enum hrtimer_restart bpf_timer_cb(struct hrtimer *hrtimer)\n{\n\tstruct bpf_hrtimer *t = container_of(hrtimer, struct bpf_hrtimer, timer);\n\tstruct bpf_map *map = t->map;\n\tvoid *value = t->value;\n\tbpf_callback_t callback_fn;\n\tvoid *key;\n\tu32 idx;\n\n\tcallback_fn = rcu_dereference_check(t->callback_fn, rcu_read_lock_bh_held());\n\tif (!callback_fn)\n\t\tgoto out;\n\n\t/* bpf_timer_cb() runs in hrtimer_run_softirq. It doesn't migrate and\n\t * cannot be preempted by another bpf_timer_cb() on the same cpu.\n\t * Remember the timer this callback is servicing to prevent\n\t * deadlock if callback_fn() calls bpf_timer_cancel() or\n\t * bpf_map_delete_elem() on the same timer.\n\t */\n\tthis_cpu_write(hrtimer_running, t);\n\tif (map->map_type == BPF_MAP_TYPE_ARRAY) {\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\t\t/* compute the key */\n\t\tidx = ((char *)value - array->value) / array->elem_size;\n\t\tkey = &idx;\n\t} else { /* hash or lru */\n\t\tkey = value - round_up(map->key_size, 8);\n\t}\n\n\tcallback_fn((u64)(long)map, (u64)(long)key, (u64)(long)value, 0, 0);\n\t/* The verifier checked that return value is zero. */\n\n\tthis_cpu_write(hrtimer_running, NULL);\nout:\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "hrtimer_running",
            "NULL"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback_fn",
          "args": [
            "(u64)(long)map",
            "(u64)(long)key",
            "(u64)(long)value",
            "0",
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "hrtimer_running",
            "t"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "t->callback_fn",
            "rcu_read_lock_bh_held()"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "hrtimer",
            "structbpf_hrtimer",
            "timer"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);\n\nstatic enum hrtimer_restart bpf_timer_cb(struct hrtimer *hrtimer)\n{\n\tstruct bpf_hrtimer *t = container_of(hrtimer, struct bpf_hrtimer, timer);\n\tstruct bpf_map *map = t->map;\n\tvoid *value = t->value;\n\tbpf_callback_t callback_fn;\n\tvoid *key;\n\tu32 idx;\n\n\tcallback_fn = rcu_dereference_check(t->callback_fn, rcu_read_lock_bh_held());\n\tif (!callback_fn)\n\t\tgoto out;\n\n\t/* bpf_timer_cb() runs in hrtimer_run_softirq. It doesn't migrate and\n\t * cannot be preempted by another bpf_timer_cb() on the same cpu.\n\t * Remember the timer this callback is servicing to prevent\n\t * deadlock if callback_fn() calls bpf_timer_cancel() or\n\t * bpf_map_delete_elem() on the same timer.\n\t */\n\tthis_cpu_write(hrtimer_running, t);\n\tif (map->map_type == BPF_MAP_TYPE_ARRAY) {\n\t\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\t\t/* compute the key */\n\t\tidx = ((char *)value - array->value) / array->elem_size;\n\t\tkey = &idx;\n\t} else { /* hash or lru */\n\t\tkey = value - round_up(map->key_size, 8);\n\t}\n\n\tcallback_fn((u64)(long)map, (u64)(long)key, (u64)(long)value, 0, 0);\n\t/* The verifier checked that return value is zero. */\n\n\tthis_cpu_write(hrtimer_running, NULL);\nout:\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "bpf_bprintf_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "778-995",
    "snippet": "int bpf_bprintf_prepare(char *fmt, u32 fmt_size, const u64 *raw_args,\n\t\t\tu32 **bin_args, u32 num_args)\n{\n\tchar *unsafe_ptr = NULL, *tmp_buf = NULL, *tmp_buf_end, *fmt_end;\n\tsize_t sizeof_cur_arg, sizeof_cur_ip;\n\tint err, i, num_spec = 0;\n\tu64 cur_arg;\n\tchar fmt_ptype, cur_ip[16], ip_spec[] = \"%pXX\";\n\n\tfmt_end = strnchr(fmt, fmt_size, 0);\n\tif (!fmt_end)\n\t\treturn -EINVAL;\n\tfmt_size = fmt_end - fmt;\n\n\tif (bin_args) {\n\t\tif (num_args && try_get_fmt_tmp_buf(&tmp_buf))\n\t\t\treturn -EBUSY;\n\n\t\ttmp_buf_end = tmp_buf + MAX_BPRINTF_BUF_LEN;\n\t\t*bin_args = (u32 *)tmp_buf;\n\t}\n\n\tfor (i = 0; i < fmt_size; i++) {\n\t\tif ((!isprint(fmt[i]) && !isspace(fmt[i])) || !isascii(fmt[i])) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fmt[i] != '%')\n\t\t\tcontinue;\n\n\t\tif (fmt[i + 1] == '%') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (num_spec >= num_args) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The string is zero-terminated so if fmt[i] != 0, we can\n\t\t * always access fmt[i + 1], in the worst case it will be a 0\n\t\t */\n\t\ti++;\n\n\t\t/* skip optional \"[0 +-][num]\" width formatting field */\n\t\twhile (fmt[i] == '0' || fmt[i] == '+'  || fmt[i] == '-' ||\n\t\t       fmt[i] == ' ')\n\t\t\ti++;\n\t\tif (fmt[i] >= '1' && fmt[i] <= '9') {\n\t\t\ti++;\n\t\t\twhile (fmt[i] >= '0' && fmt[i] <= '9')\n\t\t\t\ti++;\n\t\t}\n\n\t\tif (fmt[i] == 'p') {\n\t\t\tsizeof_cur_arg = sizeof(long);\n\n\t\t\tif ((fmt[i + 1] == 'k' || fmt[i + 1] == 'u') &&\n\t\t\t    fmt[i + 2] == 's') {\n\t\t\t\tfmt_ptype = fmt[i + 1];\n\t\t\t\ti += 2;\n\t\t\t\tgoto fmt_str;\n\t\t\t}\n\n\t\t\tif (fmt[i + 1] == 0 || isspace(fmt[i + 1]) ||\n\t\t\t    ispunct(fmt[i + 1]) || fmt[i + 1] == 'K' ||\n\t\t\t    fmt[i + 1] == 'x' || fmt[i + 1] == 's' ||\n\t\t\t    fmt[i + 1] == 'S') {\n\t\t\t\t/* just kernel pointers */\n\t\t\t\tif (tmp_buf)\n\t\t\t\t\tcur_arg = raw_args[num_spec];\n\t\t\t\ti++;\n\t\t\t\tgoto nocopy_fmt;\n\t\t\t}\n\n\t\t\tif (fmt[i + 1] == 'B') {\n\t\t\t\tif (tmp_buf)  {\n\t\t\t\t\terr = snprintf(tmp_buf,\n\t\t\t\t\t\t       (tmp_buf_end - tmp_buf),\n\t\t\t\t\t\t       \"%pB\",\n\t\t\t\t\t\t       (void *)(long)raw_args[num_spec]);\n\t\t\t\t\ttmp_buf += (err + 1);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t\tnum_spec++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* only support \"%pI4\", \"%pi4\", \"%pI6\" and \"%pi6\". */\n\t\t\tif ((fmt[i + 1] != 'i' && fmt[i + 1] != 'I') ||\n\t\t\t    (fmt[i + 2] != '4' && fmt[i + 2] != '6')) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ti += 2;\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tsizeof_cur_ip = (fmt[i] == '4') ? 4 : 16;\n\t\t\tif (tmp_buf_end - tmp_buf < sizeof_cur_ip) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tunsafe_ptr = (char *)(long)raw_args[num_spec];\n\t\t\terr = copy_from_kernel_nofault(cur_ip, unsafe_ptr,\n\t\t\t\t\t\t       sizeof_cur_ip);\n\t\t\tif (err < 0)\n\t\t\t\tmemset(cur_ip, 0, sizeof_cur_ip);\n\n\t\t\t/* hack: bstr_printf expects IP addresses to be\n\t\t\t * pre-formatted as strings, ironically, the easiest way\n\t\t\t * to do that is to call snprintf.\n\t\t\t */\n\t\t\tip_spec[2] = fmt[i - 1];\n\t\t\tip_spec[3] = fmt[i];\n\t\t\terr = snprintf(tmp_buf, tmp_buf_end - tmp_buf,\n\t\t\t\t       ip_spec, &cur_ip);\n\n\t\t\ttmp_buf += err + 1;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t} else if (fmt[i] == 's') {\n\t\t\tfmt_ptype = fmt[i];\nfmt_str:\n\t\t\tif (fmt[i + 1] != 0 &&\n\t\t\t    !isspace(fmt[i + 1]) &&\n\t\t\t    !ispunct(fmt[i + 1])) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tif (tmp_buf_end == tmp_buf) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tunsafe_ptr = (char *)(long)raw_args[num_spec];\n\t\t\terr = bpf_trace_copy_string(tmp_buf, unsafe_ptr,\n\t\t\t\t\t\t    fmt_ptype,\n\t\t\t\t\t\t    tmp_buf_end - tmp_buf);\n\t\t\tif (err < 0) {\n\t\t\t\ttmp_buf[0] = '\\0';\n\t\t\t\terr = 1;\n\t\t\t}\n\n\t\t\ttmp_buf += err;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t} else if (fmt[i] == 'c') {\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tif (tmp_buf_end == tmp_buf) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*tmp_buf = raw_args[num_spec];\n\t\t\ttmp_buf++;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tsizeof_cur_arg = sizeof(int);\n\n\t\tif (fmt[i] == 'l') {\n\t\t\tsizeof_cur_arg = sizeof(long);\n\t\t\ti++;\n\t\t}\n\t\tif (fmt[i] == 'l') {\n\t\t\tsizeof_cur_arg = sizeof(long long);\n\t\t\ti++;\n\t\t}\n\n\t\tif (fmt[i] != 'i' && fmt[i] != 'd' && fmt[i] != 'u' &&\n\t\t    fmt[i] != 'x' && fmt[i] != 'X') {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tmp_buf)\n\t\t\tcur_arg = raw_args[num_spec];\nnocopy_fmt:\n\t\tif (tmp_buf) {\n\t\t\ttmp_buf = PTR_ALIGN(tmp_buf, sizeof(u32));\n\t\t\tif (tmp_buf_end - tmp_buf < sizeof_cur_arg) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sizeof_cur_arg == 8) {\n\t\t\t\t*(u32 *)tmp_buf = *(u32 *)&cur_arg;\n\t\t\t\t*(u32 *)(tmp_buf + 4) = *((u32 *)&cur_arg + 1);\n\t\t\t} else {\n\t\t\t\t*(u32 *)tmp_buf = (u32)(long)cur_arg;\n\t\t\t}\n\t\t\ttmp_buf += sizeof_cur_arg;\n\t\t}\n\t\tnum_spec++;\n\t}\n\n\terr = 0;\nout:\n\tif (err)\n\t\tbpf_bprintf_cleanup();\n\treturn err;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define MAX_BPRINTF_BUF_LEN\t512"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_bprintf_cleanup",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_bprintf_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "756-762",
          "snippet": "void bpf_bprintf_cleanup(void)\n{\n\tif (this_cpu_read(bpf_bprintf_nest_level)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, bpf_bprintf_nest_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(int, bpf_bprintf_nest_level);\n\nvoid bpf_bprintf_cleanup(void)\n{\n\tif (this_cpu_read(bpf_bprintf_nest_level)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ALIGN",
          "args": [
            "tmp_buf",
            "sizeof(u32)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_trace_copy_string",
          "args": [
            "tmp_buf",
            "unsafe_ptr",
            "fmt_ptype",
            "tmp_buf_end - tmp_buf"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trace_copy_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "702-723",
          "snippet": "static int bpf_trace_copy_string(char *buf, void *unsafe_ptr, char fmt_ptype,\n\t\tsize_t bufsz)\n{\n\tvoid __user *user_ptr = (__force void __user *)unsafe_ptr;\n\n\tbuf[0] = 0;\n\n\tswitch (fmt_ptype) {\n\tcase 's':\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\t\tif ((unsigned long)unsafe_ptr < TASK_SIZE)\n\t\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t\tfallthrough;\n#endif\n\tcase 'k':\n\t\treturn strncpy_from_kernel_nofault(buf, unsafe_ptr, bufsz);\n\tcase 'u':\n\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_trace_copy_string(char *buf, void *unsafe_ptr, char fmt_ptype,\n\t\tsize_t bufsz)\n{\n\tvoid __user *user_ptr = (__force void __user *)unsafe_ptr;\n\n\tbuf[0] = 0;\n\n\tswitch (fmt_ptype) {\n\tcase 's':\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\t\tif ((unsigned long)unsafe_ptr < TASK_SIZE)\n\t\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t\tfallthrough;\n#endif\n\tcase 'k':\n\t\treturn strncpy_from_kernel_nofault(buf, unsafe_ptr, bufsz);\n\tcase 'u':\n\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t}\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ispunct",
          "args": [
            "fmt[i + 1]"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "fmt[i + 1]"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp_buf",
            "tmp_buf_end - tmp_buf",
            "ip_spec",
            "&cur_ip"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cur_ip",
            "0",
            "sizeof_cur_ip"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "cur_ip",
            "unsafe_ptr",
            "sizeof_cur_ip"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp_buf",
            "(tmp_buf_end - tmp_buf)",
            "\"%pB\"",
            "(void *)(long)raw_args[num_spec]"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispunct",
          "args": [
            "fmt[i + 1]"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "fmt[i + 1]"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "fmt[i]"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "fmt[i]"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "fmt[i]"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_fmt_tmp_buf",
          "args": [
            "&tmp_buf"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "try_get_fmt_tmp_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "738-754",
          "snippet": "static int try_get_fmt_tmp_buf(char **tmp_buf)\n{\n\tstruct bpf_bprintf_buffers *bufs;\n\tint nest_level;\n\n\tpreempt_disable();\n\tnest_level = this_cpu_inc_return(bpf_bprintf_nest_level);\n\tif (WARN_ON_ONCE(nest_level > MAX_BPRINTF_NEST_LEVEL)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t\treturn -EBUSY;\n\t}\n\tbufs = this_cpu_ptr(&bpf_bprintf_bufs);\n\t*tmp_buf = bufs->tmp_bufs[nest_level - 1];\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define MAX_BPRINTF_NEST_LEVEL\t3"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bpf_bprintf_buffers, bpf_bprintf_bufs);",
            "static DEFINE_PER_CPU(int, bpf_bprintf_nest_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define MAX_BPRINTF_NEST_LEVEL\t3\n\nstatic DEFINE_PER_CPU(struct bpf_bprintf_buffers, bpf_bprintf_bufs);\nstatic DEFINE_PER_CPU(int, bpf_bprintf_nest_level);\n\nstatic int try_get_fmt_tmp_buf(char **tmp_buf)\n{\n\tstruct bpf_bprintf_buffers *bufs;\n\tint nest_level;\n\n\tpreempt_disable();\n\tnest_level = this_cpu_inc_return(bpf_bprintf_nest_level);\n\tif (WARN_ON_ONCE(nest_level > MAX_BPRINTF_NEST_LEVEL)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t\treturn -EBUSY;\n\t}\n\tbufs = this_cpu_ptr(&bpf_bprintf_bufs);\n\t*tmp_buf = bufs->tmp_bufs[nest_level - 1];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnchr",
          "args": [
            "fmt",
            "fmt_size",
            "0"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define MAX_BPRINTF_BUF_LEN\t512\n\nint bpf_bprintf_prepare(char *fmt, u32 fmt_size, const u64 *raw_args,\n\t\t\tu32 **bin_args, u32 num_args)\n{\n\tchar *unsafe_ptr = NULL, *tmp_buf = NULL, *tmp_buf_end, *fmt_end;\n\tsize_t sizeof_cur_arg, sizeof_cur_ip;\n\tint err, i, num_spec = 0;\n\tu64 cur_arg;\n\tchar fmt_ptype, cur_ip[16], ip_spec[] = \"%pXX\";\n\n\tfmt_end = strnchr(fmt, fmt_size, 0);\n\tif (!fmt_end)\n\t\treturn -EINVAL;\n\tfmt_size = fmt_end - fmt;\n\n\tif (bin_args) {\n\t\tif (num_args && try_get_fmt_tmp_buf(&tmp_buf))\n\t\t\treturn -EBUSY;\n\n\t\ttmp_buf_end = tmp_buf + MAX_BPRINTF_BUF_LEN;\n\t\t*bin_args = (u32 *)tmp_buf;\n\t}\n\n\tfor (i = 0; i < fmt_size; i++) {\n\t\tif ((!isprint(fmt[i]) && !isspace(fmt[i])) || !isascii(fmt[i])) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fmt[i] != '%')\n\t\t\tcontinue;\n\n\t\tif (fmt[i + 1] == '%') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (num_spec >= num_args) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The string is zero-terminated so if fmt[i] != 0, we can\n\t\t * always access fmt[i + 1], in the worst case it will be a 0\n\t\t */\n\t\ti++;\n\n\t\t/* skip optional \"[0 +-][num]\" width formatting field */\n\t\twhile (fmt[i] == '0' || fmt[i] == '+'  || fmt[i] == '-' ||\n\t\t       fmt[i] == ' ')\n\t\t\ti++;\n\t\tif (fmt[i] >= '1' && fmt[i] <= '9') {\n\t\t\ti++;\n\t\t\twhile (fmt[i] >= '0' && fmt[i] <= '9')\n\t\t\t\ti++;\n\t\t}\n\n\t\tif (fmt[i] == 'p') {\n\t\t\tsizeof_cur_arg = sizeof(long);\n\n\t\t\tif ((fmt[i + 1] == 'k' || fmt[i + 1] == 'u') &&\n\t\t\t    fmt[i + 2] == 's') {\n\t\t\t\tfmt_ptype = fmt[i + 1];\n\t\t\t\ti += 2;\n\t\t\t\tgoto fmt_str;\n\t\t\t}\n\n\t\t\tif (fmt[i + 1] == 0 || isspace(fmt[i + 1]) ||\n\t\t\t    ispunct(fmt[i + 1]) || fmt[i + 1] == 'K' ||\n\t\t\t    fmt[i + 1] == 'x' || fmt[i + 1] == 's' ||\n\t\t\t    fmt[i + 1] == 'S') {\n\t\t\t\t/* just kernel pointers */\n\t\t\t\tif (tmp_buf)\n\t\t\t\t\tcur_arg = raw_args[num_spec];\n\t\t\t\ti++;\n\t\t\t\tgoto nocopy_fmt;\n\t\t\t}\n\n\t\t\tif (fmt[i + 1] == 'B') {\n\t\t\t\tif (tmp_buf)  {\n\t\t\t\t\terr = snprintf(tmp_buf,\n\t\t\t\t\t\t       (tmp_buf_end - tmp_buf),\n\t\t\t\t\t\t       \"%pB\",\n\t\t\t\t\t\t       (void *)(long)raw_args[num_spec]);\n\t\t\t\t\ttmp_buf += (err + 1);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t\tnum_spec++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* only support \"%pI4\", \"%pi4\", \"%pI6\" and \"%pi6\". */\n\t\t\tif ((fmt[i + 1] != 'i' && fmt[i + 1] != 'I') ||\n\t\t\t    (fmt[i + 2] != '4' && fmt[i + 2] != '6')) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ti += 2;\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tsizeof_cur_ip = (fmt[i] == '4') ? 4 : 16;\n\t\t\tif (tmp_buf_end - tmp_buf < sizeof_cur_ip) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tunsafe_ptr = (char *)(long)raw_args[num_spec];\n\t\t\terr = copy_from_kernel_nofault(cur_ip, unsafe_ptr,\n\t\t\t\t\t\t       sizeof_cur_ip);\n\t\t\tif (err < 0)\n\t\t\t\tmemset(cur_ip, 0, sizeof_cur_ip);\n\n\t\t\t/* hack: bstr_printf expects IP addresses to be\n\t\t\t * pre-formatted as strings, ironically, the easiest way\n\t\t\t * to do that is to call snprintf.\n\t\t\t */\n\t\t\tip_spec[2] = fmt[i - 1];\n\t\t\tip_spec[3] = fmt[i];\n\t\t\terr = snprintf(tmp_buf, tmp_buf_end - tmp_buf,\n\t\t\t\t       ip_spec, &cur_ip);\n\n\t\t\ttmp_buf += err + 1;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t} else if (fmt[i] == 's') {\n\t\t\tfmt_ptype = fmt[i];\nfmt_str:\n\t\t\tif (fmt[i + 1] != 0 &&\n\t\t\t    !isspace(fmt[i + 1]) &&\n\t\t\t    !ispunct(fmt[i + 1])) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tif (tmp_buf_end == tmp_buf) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tunsafe_ptr = (char *)(long)raw_args[num_spec];\n\t\t\terr = bpf_trace_copy_string(tmp_buf, unsafe_ptr,\n\t\t\t\t\t\t    fmt_ptype,\n\t\t\t\t\t\t    tmp_buf_end - tmp_buf);\n\t\t\tif (err < 0) {\n\t\t\t\ttmp_buf[0] = '\\0';\n\t\t\t\terr = 1;\n\t\t\t}\n\n\t\t\ttmp_buf += err;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t} else if (fmt[i] == 'c') {\n\t\t\tif (!tmp_buf)\n\t\t\t\tgoto nocopy_fmt;\n\n\t\t\tif (tmp_buf_end == tmp_buf) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*tmp_buf = raw_args[num_spec];\n\t\t\ttmp_buf++;\n\t\t\tnum_spec++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tsizeof_cur_arg = sizeof(int);\n\n\t\tif (fmt[i] == 'l') {\n\t\t\tsizeof_cur_arg = sizeof(long);\n\t\t\ti++;\n\t\t}\n\t\tif (fmt[i] == 'l') {\n\t\t\tsizeof_cur_arg = sizeof(long long);\n\t\t\ti++;\n\t\t}\n\n\t\tif (fmt[i] != 'i' && fmt[i] != 'd' && fmt[i] != 'u' &&\n\t\t    fmt[i] != 'x' && fmt[i] != 'X') {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tmp_buf)\n\t\t\tcur_arg = raw_args[num_spec];\nnocopy_fmt:\n\t\tif (tmp_buf) {\n\t\t\ttmp_buf = PTR_ALIGN(tmp_buf, sizeof(u32));\n\t\t\tif (tmp_buf_end - tmp_buf < sizeof_cur_arg) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sizeof_cur_arg == 8) {\n\t\t\t\t*(u32 *)tmp_buf = *(u32 *)&cur_arg;\n\t\t\t\t*(u32 *)(tmp_buf + 4) = *((u32 *)&cur_arg + 1);\n\t\t\t} else {\n\t\t\t\t*(u32 *)tmp_buf = (u32)(long)cur_arg;\n\t\t\t}\n\t\t\ttmp_buf += sizeof_cur_arg;\n\t\t}\n\t\tnum_spec++;\n\t}\n\n\terr = 0;\nout:\n\tif (err)\n\t\tbpf_bprintf_cleanup();\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_bprintf_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "756-762",
    "snippet": "void bpf_bprintf_cleanup(void)\n{\n\tif (this_cpu_read(bpf_bprintf_nest_level)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, bpf_bprintf_nest_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "bpf_bprintf_nest_level"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "bpf_bprintf_nest_level"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(int, bpf_bprintf_nest_level);\n\nvoid bpf_bprintf_cleanup(void)\n{\n\tif (this_cpu_read(bpf_bprintf_nest_level)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "try_get_fmt_tmp_buf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "738-754",
    "snippet": "static int try_get_fmt_tmp_buf(char **tmp_buf)\n{\n\tstruct bpf_bprintf_buffers *bufs;\n\tint nest_level;\n\n\tpreempt_disable();\n\tnest_level = this_cpu_inc_return(bpf_bprintf_nest_level);\n\tif (WARN_ON_ONCE(nest_level > MAX_BPRINTF_NEST_LEVEL)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t\treturn -EBUSY;\n\t}\n\tbufs = this_cpu_ptr(&bpf_bprintf_bufs);\n\t*tmp_buf = bufs->tmp_bufs[nest_level - 1];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define MAX_BPRINTF_NEST_LEVEL\t3"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bpf_bprintf_buffers, bpf_bprintf_bufs);",
      "static DEFINE_PER_CPU(int, bpf_bprintf_nest_level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bpf_bprintf_bufs"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "bpf_bprintf_nest_level"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nest_level > MAX_BPRINTF_NEST_LEVEL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc_return",
          "args": [
            "bpf_bprintf_nest_level"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define MAX_BPRINTF_NEST_LEVEL\t3\n\nstatic DEFINE_PER_CPU(struct bpf_bprintf_buffers, bpf_bprintf_bufs);\nstatic DEFINE_PER_CPU(int, bpf_bprintf_nest_level);\n\nstatic int try_get_fmt_tmp_buf(char **tmp_buf)\n{\n\tstruct bpf_bprintf_buffers *bufs;\n\tint nest_level;\n\n\tpreempt_disable();\n\tnest_level = this_cpu_inc_return(bpf_bprintf_nest_level);\n\tif (WARN_ON_ONCE(nest_level > MAX_BPRINTF_NEST_LEVEL)) {\n\t\tthis_cpu_dec(bpf_bprintf_nest_level);\n\t\tpreempt_enable();\n\t\treturn -EBUSY;\n\t}\n\tbufs = this_cpu_ptr(&bpf_bprintf_bufs);\n\t*tmp_buf = bufs->tmp_bufs[nest_level - 1];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_trace_copy_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "702-723",
    "snippet": "static int bpf_trace_copy_string(char *buf, void *unsafe_ptr, char fmt_ptype,\n\t\tsize_t bufsz)\n{\n\tvoid __user *user_ptr = (__force void __user *)unsafe_ptr;\n\n\tbuf[0] = 0;\n\n\tswitch (fmt_ptype) {\n\tcase 's':\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\t\tif ((unsigned long)unsafe_ptr < TASK_SIZE)\n\t\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t\tfallthrough;\n#endif\n\tcase 'k':\n\t\treturn strncpy_from_kernel_nofault(buf, unsafe_ptr, bufsz);\n\tcase 'u':\n\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy_from_user_nofault",
          "args": [
            "buf",
            "user_ptr",
            "bufsz"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_kernel_nofault",
          "args": [
            "buf",
            "unsafe_ptr",
            "bufsz"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user_nofault",
          "args": [
            "buf",
            "user_ptr",
            "bufsz"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_trace_copy_string(char *buf, void *unsafe_ptr, char fmt_ptype,\n\t\tsize_t bufsz)\n{\n\tvoid __user *user_ptr = (__force void __user *)unsafe_ptr;\n\n\tbuf[0] = 0;\n\n\tswitch (fmt_ptype) {\n\tcase 's':\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\t\tif ((unsigned long)unsafe_ptr < TASK_SIZE)\n\t\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t\tfallthrough;\n#endif\n\tcase 'k':\n\t\treturn strncpy_from_kernel_nofault(buf, unsafe_ptr, bufsz);\n\tcase 'u':\n\t\treturn strncpy_from_user_nofault(buf, user_ptr, bufsz);\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__bpf_strtoll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "493-513",
    "snippet": "static int __bpf_strtoll(const char *buf, size_t buf_len, u64 flags,\n\t\t\t long long *res)\n{\n\tunsigned long long _res;\n\tbool is_negative;\n\tint err;\n\n\terr = __bpf_strtoull(buf, buf_len, flags, &_res, &is_negative);\n\tif (err < 0)\n\t\treturn err;\n\tif (is_negative) {\n\t\tif ((long long)-_res > 0)\n\t\t\treturn -ERANGE;\n\t\t*res = -_res;\n\t} else {\n\t\tif ((long long)_res < 0)\n\t\t\treturn -ERANGE;\n\t\t*res = _res;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_strtoull",
          "args": [
            "buf",
            "buf_len",
            "flags",
            "&_res",
            "&is_negative"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_strtoull",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "442-491",
          "snippet": "static int __bpf_strtoull(const char *buf, size_t buf_len, u64 flags,\n\t\t\t  unsigned long long *res, bool *is_negative)\n{\n\tunsigned int base = flags & BPF_STRTOX_BASE_MASK;\n\tconst char *cur_buf = buf;\n\tsize_t cur_len = buf_len;\n\tunsigned int consumed;\n\tsize_t val_len;\n\tchar str[64];\n\n\tif (!buf || !buf_len || !res || !is_negative)\n\t\treturn -EINVAL;\n\n\tif (base != 0 && base != 8 && base != 10 && base != 16)\n\t\treturn -EINVAL;\n\n\tif (flags & ~BPF_STRTOX_BASE_MASK)\n\t\treturn -EINVAL;\n\n\twhile (cur_buf < buf + buf_len && isspace(*cur_buf))\n\t\t++cur_buf;\n\n\t*is_negative = (cur_buf < buf + buf_len && *cur_buf == '-');\n\tif (*is_negative)\n\t\t++cur_buf;\n\n\tconsumed = cur_buf - buf;\n\tcur_len -= consumed;\n\tif (!cur_len)\n\t\treturn -EINVAL;\n\n\tcur_len = min(cur_len, sizeof(str) - 1);\n\tmemcpy(str, cur_buf, cur_len);\n\tstr[cur_len] = '\\0';\n\tcur_buf = str;\n\n\tcur_buf = _parse_integer_fixup_radix(cur_buf, &base);\n\tval_len = _parse_integer(cur_buf, base, res);\n\n\tif (val_len & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tcur_buf += val_len;\n\tconsumed += cur_buf - str;\n\n\treturn consumed;\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_STRTOX_BASE_MASK 0x1F"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_STRTOX_BASE_MASK 0x1F\n\nstatic int __bpf_strtoull(const char *buf, size_t buf_len, u64 flags,\n\t\t\t  unsigned long long *res, bool *is_negative)\n{\n\tunsigned int base = flags & BPF_STRTOX_BASE_MASK;\n\tconst char *cur_buf = buf;\n\tsize_t cur_len = buf_len;\n\tunsigned int consumed;\n\tsize_t val_len;\n\tchar str[64];\n\n\tif (!buf || !buf_len || !res || !is_negative)\n\t\treturn -EINVAL;\n\n\tif (base != 0 && base != 8 && base != 10 && base != 16)\n\t\treturn -EINVAL;\n\n\tif (flags & ~BPF_STRTOX_BASE_MASK)\n\t\treturn -EINVAL;\n\n\twhile (cur_buf < buf + buf_len && isspace(*cur_buf))\n\t\t++cur_buf;\n\n\t*is_negative = (cur_buf < buf + buf_len && *cur_buf == '-');\n\tif (*is_negative)\n\t\t++cur_buf;\n\n\tconsumed = cur_buf - buf;\n\tcur_len -= consumed;\n\tif (!cur_len)\n\t\treturn -EINVAL;\n\n\tcur_len = min(cur_len, sizeof(str) - 1);\n\tmemcpy(str, cur_buf, cur_len);\n\tstr[cur_len] = '\\0';\n\tcur_buf = str;\n\n\tcur_buf = _parse_integer_fixup_radix(cur_buf, &base);\n\tval_len = _parse_integer(cur_buf, base, res);\n\n\tif (val_len & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tcur_buf += val_len;\n\tconsumed += cur_buf - str;\n\n\treturn consumed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int __bpf_strtoll(const char *buf, size_t buf_len, u64 flags,\n\t\t\t long long *res)\n{\n\tunsigned long long _res;\n\tbool is_negative;\n\tint err;\n\n\terr = __bpf_strtoull(buf, buf_len, flags, &_res, &is_negative);\n\tif (err < 0)\n\t\treturn err;\n\tif (is_negative) {\n\t\tif ((long long)-_res > 0)\n\t\t\treturn -ERANGE;\n\t\t*res = -_res;\n\t} else {\n\t\tif ((long long)_res < 0)\n\t\t\treturn -ERANGE;\n\t\t*res = _res;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "__bpf_strtoull",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "442-491",
    "snippet": "static int __bpf_strtoull(const char *buf, size_t buf_len, u64 flags,\n\t\t\t  unsigned long long *res, bool *is_negative)\n{\n\tunsigned int base = flags & BPF_STRTOX_BASE_MASK;\n\tconst char *cur_buf = buf;\n\tsize_t cur_len = buf_len;\n\tunsigned int consumed;\n\tsize_t val_len;\n\tchar str[64];\n\n\tif (!buf || !buf_len || !res || !is_negative)\n\t\treturn -EINVAL;\n\n\tif (base != 0 && base != 8 && base != 10 && base != 16)\n\t\treturn -EINVAL;\n\n\tif (flags & ~BPF_STRTOX_BASE_MASK)\n\t\treturn -EINVAL;\n\n\twhile (cur_buf < buf + buf_len && isspace(*cur_buf))\n\t\t++cur_buf;\n\n\t*is_negative = (cur_buf < buf + buf_len && *cur_buf == '-');\n\tif (*is_negative)\n\t\t++cur_buf;\n\n\tconsumed = cur_buf - buf;\n\tcur_len -= consumed;\n\tif (!cur_len)\n\t\treturn -EINVAL;\n\n\tcur_len = min(cur_len, sizeof(str) - 1);\n\tmemcpy(str, cur_buf, cur_len);\n\tstr[cur_len] = '\\0';\n\tcur_buf = str;\n\n\tcur_buf = _parse_integer_fixup_radix(cur_buf, &base);\n\tval_len = _parse_integer(cur_buf, base, res);\n\n\tif (val_len & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tcur_buf += val_len;\n\tconsumed += cur_buf - str;\n\n\treturn consumed;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_STRTOX_BASE_MASK 0x1F"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_parse_integer",
          "args": [
            "cur_buf",
            "base",
            "res"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parse_integer_fixup_radix",
          "args": [
            "cur_buf",
            "&base"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "cur_buf",
            "cur_len"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cur_len",
            "sizeof(str) - 1"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cur_buf"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_STRTOX_BASE_MASK 0x1F\n\nstatic int __bpf_strtoull(const char *buf, size_t buf_len, u64 flags,\n\t\t\t  unsigned long long *res, bool *is_negative)\n{\n\tunsigned int base = flags & BPF_STRTOX_BASE_MASK;\n\tconst char *cur_buf = buf;\n\tsize_t cur_len = buf_len;\n\tunsigned int consumed;\n\tsize_t val_len;\n\tchar str[64];\n\n\tif (!buf || !buf_len || !res || !is_negative)\n\t\treturn -EINVAL;\n\n\tif (base != 0 && base != 8 && base != 10 && base != 16)\n\t\treturn -EINVAL;\n\n\tif (flags & ~BPF_STRTOX_BASE_MASK)\n\t\treturn -EINVAL;\n\n\twhile (cur_buf < buf + buf_len && isspace(*cur_buf))\n\t\t++cur_buf;\n\n\t*is_negative = (cur_buf < buf + buf_len && *cur_buf == '-');\n\tif (*is_negative)\n\t\t++cur_buf;\n\n\tconsumed = cur_buf - buf;\n\tcur_len -= consumed;\n\tif (!cur_len)\n\t\treturn -EINVAL;\n\n\tcur_len = min(cur_len, sizeof(str) - 1);\n\tmemcpy(str, cur_buf, cur_len);\n\tstr[cur_len] = '\\0';\n\tcur_buf = str;\n\n\tcur_buf = _parse_integer_fixup_radix(cur_buf, &base);\n\tval_len = _parse_integer(cur_buf, base, res);\n\n\tif (val_len & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\n\tif (val_len == 0)\n\t\treturn -EINVAL;\n\n\tcur_buf += val_len;\n\tconsumed += cur_buf - str;\n\n\treturn consumed;\n}"
  },
  {
    "function_name": "copy_map_value_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "337-351",
    "snippet": "void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_spin_unlock_irqrestore",
          "args": [
            "lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_map_value",
          "args": [
            "map",
            "dst",
            "src"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_spin_lock_irqsave",
          "args": [
            "lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "BPF_CALL_1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "324-328",
    "snippet": "notrace BPF_CALL_1(bpf_spin_unlock, struct bpf_spin_lock *, lock)\n{\n\t__bpf_spin_unlock_irqrestore(lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_spin_unlock_irqrestore",
          "args": [
            "lock"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nnotrace BPF_CALL_1(bpf_spin_unlock, struct bpf_spin_lock *, lock)\n{\n\t__bpf_spin_unlock_irqrestore(lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_spin_unlock_irqrestore",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "315-322",
    "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_spin_unlock",
          "args": [
            "lock"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "irqsave_flags"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "BPF_CALL_1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "302-306",
    "snippet": "notrace BPF_CALL_1(bpf_spin_lock, struct bpf_spin_lock *, lock)\n{\n\t__bpf_spin_lock_irqsave(lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_spin_lock_irqsave",
          "args": [
            "lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nnotrace BPF_CALL_1(bpf_spin_lock, struct bpf_spin_lock *, lock)\n{\n\t__bpf_spin_lock_irqsave(lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_spin_lock_irqsave",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "293-300",
    "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "irqsave_flags",
            "flags"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_spin_lock",
          "args": [
            "lock"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
  },
  {
    "function_name": "__bpf_spin_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "282-287",
    "snippet": "static inline void __bpf_spin_unlock(struct bpf_spin_lock *lock)\n{\n\tatomic_t *l = (void *)lock;\n\n\tatomic_set_release(l, 0);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "l",
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic inline void __bpf_spin_unlock(struct bpf_spin_lock *lock)\n{\n\tatomic_t *l = (void *)lock;\n\n\tatomic_set_release(l, 0);\n}"
  },
  {
    "function_name": "__bpf_spin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "272-280",
    "snippet": "static inline void __bpf_spin_lock(struct bpf_spin_lock *lock)\n{\n\tatomic_t *l = (void *)lock;\n\n\tBUILD_BUG_ON(sizeof(*l) != sizeof(*lock));\n\tdo {\n\t\tatomic_cond_read_relaxed(l, !VAL);\n\t} while (atomic_xchg(l, 1));\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "l",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cond_read_relaxed",
          "args": [
            "l",
            "!VAL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(*l) != sizeof(*lock)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic inline void __bpf_spin_lock(struct bpf_spin_lock *lock)\n{\n\tatomic_t *l = (void *)lock;\n\n\tBUILD_BUG_ON(sizeof(*l) != sizeof(*lock));\n\tdo {\n\t\tatomic_cond_read_relaxed(l, !VAL);\n\t} while (atomic_xchg(l, 1));\n}"
  },
  {
    "function_name": "__bpf_spin_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "263-268",
    "snippet": "static inline void __bpf_spin_unlock(struct bpf_spin_lock *lock)\n{\n\tarch_spinlock_t *l = (void *)lock;\n\n\tarch_spin_unlock(l);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "l"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic inline void __bpf_spin_unlock(struct bpf_spin_lock *lock)\n{\n\tarch_spinlock_t *l = (void *)lock;\n\n\tarch_spin_unlock(l);\n}"
  },
  {
    "function_name": "__bpf_spin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
    "lines": "249-261",
    "snippet": "static inline void __bpf_spin_lock(struct bpf_spin_lock *lock)\n{\n\tarch_spinlock_t *l = (void *)lock;\n\tunion {\n\t\t__u32 val;\n\t\tarch_spinlock_t lock;\n\t} u = { .lock = __ARCH_SPIN_LOCK_UNLOCKED };\n\n\tcompiletime_assert(u.val == 0, \"__ARCH_SPIN_LOCK_UNLOCKED not 0\");\n\tBUILD_BUG_ON(sizeof(*l) != sizeof(__u32));\n\tBUILD_BUG_ON(sizeof(*lock) != sizeof(__u32));\n\tarch_spin_lock(l);\n}",
    "includes": [
      "#include \"../../lib/kstrtox.h\"",
      "#include <linux/security.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/ctype.h>",
      "#include <linux/filter.h>",
      "#include <linux/uidgid.h>",
      "#include <linux/sched.h>",
      "#include <linux/ktime.h>",
      "#include <linux/topology.h>",
      "#include <linux/smp.h>",
      "#include <linux/random.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "l"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(*lock) != sizeof(__u32)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(*l) != sizeof(__u32)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiletime_assert",
          "args": [
            "u.val == 0",
            "\"__ARCH_SPIN_LOCK_UNLOCKED not 0\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic inline void __bpf_spin_lock(struct bpf_spin_lock *lock)\n{\n\tarch_spinlock_t *l = (void *)lock;\n\tunion {\n\t\t__u32 val;\n\t\tarch_spinlock_t lock;\n\t} u = { .lock = __ARCH_SPIN_LOCK_UNLOCKED };\n\n\tcompiletime_assert(u.val == 0, \"__ARCH_SPIN_LOCK_UNLOCKED not 0\");\n\tBUILD_BUG_ON(sizeof(*l) != sizeof(__u32));\n\tBUILD_BUG_ON(sizeof(*lock) != sizeof(__u32));\n\tarch_spin_lock(l);\n}"
  }
]