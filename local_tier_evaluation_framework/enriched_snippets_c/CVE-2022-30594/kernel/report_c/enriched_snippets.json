[
  {
    "function_name": "kcsan_report_unknown_origin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "701-716",
    "snippet": "void kcsan_report_unknown_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t\t unsigned long ip, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off(); /* See kcsan_report_known_origin(). */\n\n\traw_spin_lock_irqsave(&report_lock, flags);\n\tprint_report(KCSAN_VALUE_CHANGE_TRUE, &ai, NULL, old, new, mask);\n\traw_spin_unlock_irqrestore(&report_lock, flags);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&report_lock",
            "flags"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_report",
          "args": [
            "KCSAN_VALUE_CHANGE_TRUE",
            "&ai",
            "NULL",
            "old",
            "new",
            "mask"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "print_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "388-497",
          "snippet": "static void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define NUM_STACK_ENTRIES 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define NUM_STACK_ENTRIES 64\n\nstatic void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&report_lock",
            "flags"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_off",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_access_info",
          "args": [
            "ptr",
            "size",
            "access_type",
            "ip"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_access_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "638-650",
          "snippet": "static struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nvoid kcsan_report_unknown_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t\t unsigned long ip, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off(); /* See kcsan_report_known_origin(). */\n\n\traw_spin_lock_irqsave(&report_lock, flags);\n\tprint_report(KCSAN_VALUE_CHANGE_TRUE, &ai, NULL, old, new, mask);\n\traw_spin_unlock_irqrestore(&report_lock, flags);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}"
  },
  {
    "function_name": "kcsan_report_known_origin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "667-699",
    "snippet": "void kcsan_report_known_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t       unsigned long ip, enum kcsan_value_change value_change,\n\t\t\t       int watchpoint_idx, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tstruct other_info *other_info = &other_infos[watchpoint_idx];\n\tunsigned long flags = 0;\n\n\tkcsan_disable_current();\n\t/*\n\t * Because we may generate reports when we're in scheduler code, the use\n\t * of printk() could deadlock. Until such time that all printing code\n\t * called in print_report() is scheduler-safe, accept the risk, and just\n\t * get our message out. As such, also disable lockdep to hide the\n\t * warning, and avoid disabling lockdep for the rest of the kernel.\n\t */\n\tlockdep_off();\n\n\tif (!prepare_report_consumer(&flags, &ai, other_info))\n\t\tgoto out;\n\t/*\n\t * Never report if value_change is FALSE, only when it is\n\t * either TRUE or MAYBE. In case of MAYBE, further filtering may\n\t * be done once we know the full stack trace in print_report().\n\t */\n\tif (value_change != KCSAN_VALUE_CHANGE_FALSE)\n\t\tprint_report(value_change, &ai, other_info, old, new, mask);\n\n\trelease_report(&flags, other_info);\nout:\n\tlockdep_on();\n\tkcsan_enable_current();\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_report",
          "args": [
            "&flags",
            "other_info"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "release_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "499-507",
          "snippet": "static void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_report",
          "args": [
            "value_change",
            "&ai",
            "other_info",
            "old",
            "new",
            "mask"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "print_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "388-497",
          "snippet": "static void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define NUM_STACK_ENTRIES 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define NUM_STACK_ENTRIES 64\n\nstatic void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_report_consumer",
          "args": [
            "&flags",
            "&ai",
            "other_info"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_report_consumer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "604-636",
          "snippet": "static bool prepare_report_consumer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\twhile (!other_info->ai.size) { /* Await valid @other_info. */\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\tcpu_relax();\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t}\n\n\t/* Should always have a matching access based on watchpoint encoding. */\n\tif (WARN_ON(!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)))\n\t\tgoto discard;\n\n\tif (!matching_access((unsigned long)other_info->ai.ptr, other_info->ai.size,\n\t\t\t     (unsigned long)ai->ptr, ai->size)) {\n\t\t/*\n\t\t * If the actual accesses to not match, this was a false\n\t\t * positive due to watchpoint encoding.\n\t\t */\n\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\trelease_report(flags, other_info);\n\treturn false;\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic bool prepare_report_consumer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\twhile (!other_info->ai.size) { /* Await valid @other_info. */\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\tcpu_relax();\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t}\n\n\t/* Should always have a matching access based on watchpoint encoding. */\n\tif (WARN_ON(!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)))\n\t\tgoto discard;\n\n\tif (!matching_access((unsigned long)other_info->ai.ptr, other_info->ai.size,\n\t\t\t     (unsigned long)ai->ptr, ai->size)) {\n\t\t/*\n\t\t * If the actual accesses to not match, this was a false\n\t\t * positive due to watchpoint encoding.\n\t\t */\n\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\trelease_report(flags, other_info);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_off",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_access_info",
          "args": [
            "ptr",
            "size",
            "access_type",
            "ip"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_access_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "638-650",
          "snippet": "static struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];\n\nvoid kcsan_report_known_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t       unsigned long ip, enum kcsan_value_change value_change,\n\t\t\t       int watchpoint_idx, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tstruct other_info *other_info = &other_infos[watchpoint_idx];\n\tunsigned long flags = 0;\n\n\tkcsan_disable_current();\n\t/*\n\t * Because we may generate reports when we're in scheduler code, the use\n\t * of printk() could deadlock. Until such time that all printing code\n\t * called in print_report() is scheduler-safe, accept the risk, and just\n\t * get our message out. As such, also disable lockdep to hide the\n\t * warning, and avoid disabling lockdep for the rest of the kernel.\n\t */\n\tlockdep_off();\n\n\tif (!prepare_report_consumer(&flags, &ai, other_info))\n\t\tgoto out;\n\t/*\n\t * Never report if value_change is FALSE, only when it is\n\t * either TRUE or MAYBE. In case of MAYBE, further filtering may\n\t * be done once we know the full stack trace in print_report().\n\t */\n\tif (value_change != KCSAN_VALUE_CHANGE_FALSE)\n\t\tprint_report(value_change, &ai, other_info, old, new, mask);\n\n\trelease_report(&flags, other_info);\nout:\n\tlockdep_on();\n\tkcsan_enable_current();\n}"
  },
  {
    "function_name": "kcsan_report_set_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "652-665",
    "snippet": "void kcsan_report_set_info(const volatile void *ptr, size_t size, int access_type,\n\t\t\t   unsigned long ip, int watchpoint_idx)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off(); /* See kcsan_report_known_origin(). */\n\n\tprepare_report_producer(&flags, &ai, &other_infos[watchpoint_idx]);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_enable_current",
          "args": [],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_enable_current_nowarn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "835-839",
          "snippet": "void kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_enable_current_nowarn(void)\n{\n\tif (get_ctx()->disable_count-- == 0)\n\t\tkcsan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_on",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_report_producer",
          "args": [
            "&flags",
            "&ai",
            "&other_infos[watchpoint_idx]"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_report_producer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "573-601",
          "snippet": "static void prepare_report_producer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\n\t/*\n\t * The same @other_infos entry cannot be used concurrently, because\n\t * there is a one-to-one mapping to watchpoint slots (@watchpoints in\n\t * core.c), and a watchpoint is only released for reuse after reporting\n\t * is done by the consumer of @other_info. Therefore, it is impossible\n\t * for another concurrent prepare_report_producer() to set the same\n\t * @other_info, and are guaranteed exclusivity for the @other_infos\n\t * entry pointed to by @other_info.\n\t *\n\t * To check this property holds, size should never be non-zero here,\n\t * because every consumer of struct other_info resets size to 0 in\n\t * release_report().\n\t */\n\tWARN_ON(other_info->ai.size);\n\n\tother_info->ai = *ai;\n\tother_info->num_stack_entries = stack_trace_save(other_info->stack_entries, NUM_STACK_ENTRIES, 2);\n\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tset_other_info_task_blocking(flags, ai, other_info);\n\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define NUM_STACK_ENTRIES 64"
          ],
          "globals_used": [
            "static struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];",
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define NUM_STACK_ENTRIES 64\n\nstatic struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void prepare_report_producer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\n\t/*\n\t * The same @other_infos entry cannot be used concurrently, because\n\t * there is a one-to-one mapping to watchpoint slots (@watchpoints in\n\t * core.c), and a watchpoint is only released for reuse after reporting\n\t * is done by the consumer of @other_info. Therefore, it is impossible\n\t * for another concurrent prepare_report_producer() to set the same\n\t * @other_info, and are guaranteed exclusivity for the @other_infos\n\t * entry pointed to by @other_info.\n\t *\n\t * To check this property holds, size should never be non-zero here,\n\t * because every consumer of struct other_info resets size to 0 in\n\t * release_report().\n\t */\n\tWARN_ON(other_info->ai.size);\n\n\tother_info->ai = *ai;\n\tother_info->num_stack_entries = stack_trace_save(other_info->stack_entries, NUM_STACK_ENTRIES, 2);\n\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tset_other_info_task_blocking(flags, ai, other_info);\n\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_off",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_disable_current",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_disable_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "813-816",
          "snippet": "void kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_disable_current(void)\n{\n\t++get_ctx()->disable_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_access_info",
          "args": [
            "ptr",
            "size",
            "access_type",
            "ip"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_access_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "638-650",
          "snippet": "static struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];\n\nvoid kcsan_report_set_info(const volatile void *ptr, size_t size, int access_type,\n\t\t\t   unsigned long ip, int watchpoint_idx)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off(); /* See kcsan_report_known_origin(). */\n\n\tprepare_report_producer(&flags, &ai, &other_infos[watchpoint_idx]);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}"
  },
  {
    "function_name": "prepare_access_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "638-650",
    "snippet": "static struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t/* Only replace stack entry with @ip if scoped access. */\n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}"
  },
  {
    "function_name": "prepare_report_consumer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "604-636",
    "snippet": "static bool prepare_report_consumer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\twhile (!other_info->ai.size) { /* Await valid @other_info. */\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\tcpu_relax();\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t}\n\n\t/* Should always have a matching access based on watchpoint encoding. */\n\tif (WARN_ON(!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)))\n\t\tgoto discard;\n\n\tif (!matching_access((unsigned long)other_info->ai.ptr, other_info->ai.size,\n\t\t\t     (unsigned long)ai->ptr, ai->size)) {\n\t\t/*\n\t\t * If the actual accesses to not match, this was a false\n\t\t * positive due to watchpoint encoding.\n\t\t */\n\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\trelease_report(flags, other_info);\n\treturn false;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_report",
          "args": [
            "flags",
            "other_info"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "release_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "499-507",
          "snippet": "static void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matching_access",
          "args": [
            "(unsigned long)other_info->ai.ptr",
            "other_info->ai.size",
            "(unsigned long)ai->ptr",
            "ai->size"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "matching_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/encoding.h",
          "lines": "93-100",
          "snippet": "static __always_inline bool matching_access(unsigned long addr1, size_t size1,\n\t\t\t\t\t    unsigned long addr2, size_t size2)\n{\n\tunsigned long end_range1 = addr1 + size1 - 1;\n\tunsigned long end_range2 = addr2 + size2 - 1;\n\n\treturn addr1 <= end_range2 && addr2 <= end_range1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/bits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/bits.h>\n\nstatic __always_inline bool matching_access(unsigned long addr1, size_t size1,\n\t\t\t\t\t    unsigned long addr2, size_t size2)\n{\n\tunsigned long end_range1 = addr1 + size1 - 1;\n\tunsigned long end_range2 = addr2 + size2 - 1;\n\n\treturn addr1 <= end_range2 && addr2 <= end_range1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic bool prepare_report_consumer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\twhile (!other_info->ai.size) { /* Await valid @other_info. */\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\tcpu_relax();\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t}\n\n\t/* Should always have a matching access based on watchpoint encoding. */\n\tif (WARN_ON(!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)))\n\t\tgoto discard;\n\n\tif (!matching_access((unsigned long)other_info->ai.ptr, other_info->ai.size,\n\t\t\t     (unsigned long)ai->ptr, ai->size)) {\n\t\t/*\n\t\t * If the actual accesses to not match, this was a false\n\t\t * positive due to watchpoint encoding.\n\t\t */\n\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\trelease_report(flags, other_info);\n\treturn false;\n}"
  },
  {
    "function_name": "prepare_report_producer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "573-601",
    "snippet": "static void prepare_report_producer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\n\t/*\n\t * The same @other_infos entry cannot be used concurrently, because\n\t * there is a one-to-one mapping to watchpoint slots (@watchpoints in\n\t * core.c), and a watchpoint is only released for reuse after reporting\n\t * is done by the consumer of @other_info. Therefore, it is impossible\n\t * for another concurrent prepare_report_producer() to set the same\n\t * @other_info, and are guaranteed exclusivity for the @other_infos\n\t * entry pointed to by @other_info.\n\t *\n\t * To check this property holds, size should never be non-zero here,\n\t * because every consumer of struct other_info resets size to 0 in\n\t * release_report().\n\t */\n\tWARN_ON(other_info->ai.size);\n\n\tother_info->ai = *ai;\n\tother_info->num_stack_entries = stack_trace_save(other_info->stack_entries, NUM_STACK_ENTRIES, 2);\n\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tset_other_info_task_blocking(flags, ai, other_info);\n\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [
      "#define NUM_STACK_ENTRIES 64"
    ],
    "globals_used": [
      "static struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];",
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_other_info_task_blocking",
          "args": [
            "flags",
            "ai",
            "other_info"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "set_other_info_task_blocking",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "515-570",
          "snippet": "static void set_other_info_task_blocking(unsigned long *flags,\n\t\t\t\t\t const struct access_info *ai,\n\t\t\t\t\t struct other_info *other_info)\n{\n\t/*\n\t * We may be instrumenting a code-path where current->state is already\n\t * something other than TASK_RUNNING.\n\t */\n\tconst bool is_running = task_is_running(current);\n\t/*\n\t * To avoid deadlock in case we are in an interrupt here and this is a\n\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a\n\t * timeout to ensure this works in all contexts.\n\t *\n\t * Await approximately the worst case delay of the reporting thread (if\n\t * we are not interrupted).\n\t */\n\tint timeout = max(kcsan_udelay_task, kcsan_udelay_interrupt);\n\n\tother_info->task = current;\n\tdo {\n\t\tif (is_running) {\n\t\t\t/*\n\t\t\t * Let lockdep know the real task is sleeping, to print\n\t\t\t * the held locks (recall we turned lockdep off, so\n\t\t\t * locking/unlocking @report_lock won't be recorded).\n\t\t\t */\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\t/*\n\t\t * We cannot call schedule() since we also cannot reliably\n\t\t * determine if sleeping here is permitted -- see in_atomic().\n\t\t */\n\n\t\tudelay(1);\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t\tif (timeout-- < 0) {\n\t\t\t/*\n\t\t\t * Abort. Reset @other_info->task to NULL, since it\n\t\t\t * appears the other thread is still going to consume\n\t\t\t * it. It will result in no verbose info printed for\n\t\t\t * this task.\n\t\t\t */\n\t\t\tother_info->task = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If invalid, or @ptr nor @current matches, then @other_info\n\t\t * has been consumed and we may continue. If not, retry.\n\t\t */\n\t} while (other_info->ai.size && other_info->ai.ptr == ai->ptr &&\n\t\t other_info->task == current);\n\tif (is_running)\n\t\tset_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void set_other_info_task_blocking(unsigned long *flags,\n\t\t\t\t\t const struct access_info *ai,\n\t\t\t\t\t struct other_info *other_info)\n{\n\t/*\n\t * We may be instrumenting a code-path where current->state is already\n\t * something other than TASK_RUNNING.\n\t */\n\tconst bool is_running = task_is_running(current);\n\t/*\n\t * To avoid deadlock in case we are in an interrupt here and this is a\n\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a\n\t * timeout to ensure this works in all contexts.\n\t *\n\t * Await approximately the worst case delay of the reporting thread (if\n\t * we are not interrupted).\n\t */\n\tint timeout = max(kcsan_udelay_task, kcsan_udelay_interrupt);\n\n\tother_info->task = current;\n\tdo {\n\t\tif (is_running) {\n\t\t\t/*\n\t\t\t * Let lockdep know the real task is sleeping, to print\n\t\t\t * the held locks (recall we turned lockdep off, so\n\t\t\t * locking/unlocking @report_lock won't be recorded).\n\t\t\t */\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\t/*\n\t\t * We cannot call schedule() since we also cannot reliably\n\t\t * determine if sleeping here is permitted -- see in_atomic().\n\t\t */\n\n\t\tudelay(1);\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t\tif (timeout-- < 0) {\n\t\t\t/*\n\t\t\t * Abort. Reset @other_info->task to NULL, since it\n\t\t\t * appears the other thread is still going to consume\n\t\t\t * it. It will result in no verbose info printed for\n\t\t\t * this task.\n\t\t\t */\n\t\t\tother_info->task = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If invalid, or @ptr nor @current matches, then @other_info\n\t\t * has been consumed and we may continue. If not, retry.\n\t\t */\n\t} while (other_info->ai.size && other_info->ai.ptr == ai->ptr &&\n\t\t other_info->task == current);\n\tif (is_running)\n\t\tset_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_VERBOSE"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "other_info->stack_entries",
            "NUM_STACK_ENTRIES",
            "2"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "other_info->ai.size"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define NUM_STACK_ENTRIES 64\n\nstatic struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void prepare_report_producer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\n\t/*\n\t * The same @other_infos entry cannot be used concurrently, because\n\t * there is a one-to-one mapping to watchpoint slots (@watchpoints in\n\t * core.c), and a watchpoint is only released for reuse after reporting\n\t * is done by the consumer of @other_info. Therefore, it is impossible\n\t * for another concurrent prepare_report_producer() to set the same\n\t * @other_info, and are guaranteed exclusivity for the @other_infos\n\t * entry pointed to by @other_info.\n\t *\n\t * To check this property holds, size should never be non-zero here,\n\t * because every consumer of struct other_info resets size to 0 in\n\t * release_report().\n\t */\n\tWARN_ON(other_info->ai.size);\n\n\tother_info->ai = *ai;\n\tother_info->num_stack_entries = stack_trace_save(other_info->stack_entries, NUM_STACK_ENTRIES, 2);\n\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tset_other_info_task_blocking(flags, ai, other_info);\n\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}"
  },
  {
    "function_name": "set_other_info_task_blocking",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "515-570",
    "snippet": "static void set_other_info_task_blocking(unsigned long *flags,\n\t\t\t\t\t const struct access_info *ai,\n\t\t\t\t\t struct other_info *other_info)\n{\n\t/*\n\t * We may be instrumenting a code-path where current->state is already\n\t * something other than TASK_RUNNING.\n\t */\n\tconst bool is_running = task_is_running(current);\n\t/*\n\t * To avoid deadlock in case we are in an interrupt here and this is a\n\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a\n\t * timeout to ensure this works in all contexts.\n\t *\n\t * Await approximately the worst case delay of the reporting thread (if\n\t * we are not interrupted).\n\t */\n\tint timeout = max(kcsan_udelay_task, kcsan_udelay_interrupt);\n\n\tother_info->task = current;\n\tdo {\n\t\tif (is_running) {\n\t\t\t/*\n\t\t\t * Let lockdep know the real task is sleeping, to print\n\t\t\t * the held locks (recall we turned lockdep off, so\n\t\t\t * locking/unlocking @report_lock won't be recorded).\n\t\t\t */\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\t/*\n\t\t * We cannot call schedule() since we also cannot reliably\n\t\t * determine if sleeping here is permitted -- see in_atomic().\n\t\t */\n\n\t\tudelay(1);\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t\tif (timeout-- < 0) {\n\t\t\t/*\n\t\t\t * Abort. Reset @other_info->task to NULL, since it\n\t\t\t * appears the other thread is still going to consume\n\t\t\t * it. It will result in no verbose info printed for\n\t\t\t * this task.\n\t\t\t */\n\t\t\tother_info->task = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If invalid, or @ptr nor @current matches, then @other_info\n\t\t * has been consumed and we may continue. If not, retry.\n\t\t */\n\t} while (other_info->ai.size && other_info->ai.ptr == ai->ptr &&\n\t\t other_info->task == current);\n\tif (is_running)\n\t\tset_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "kcsan_udelay_task",
            "kcsan_udelay_interrupt"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_running",
          "args": [
            "current"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void set_other_info_task_blocking(unsigned long *flags,\n\t\t\t\t\t const struct access_info *ai,\n\t\t\t\t\t struct other_info *other_info)\n{\n\t/*\n\t * We may be instrumenting a code-path where current->state is already\n\t * something other than TASK_RUNNING.\n\t */\n\tconst bool is_running = task_is_running(current);\n\t/*\n\t * To avoid deadlock in case we are in an interrupt here and this is a\n\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a\n\t * timeout to ensure this works in all contexts.\n\t *\n\t * Await approximately the worst case delay of the reporting thread (if\n\t * we are not interrupted).\n\t */\n\tint timeout = max(kcsan_udelay_task, kcsan_udelay_interrupt);\n\n\tother_info->task = current;\n\tdo {\n\t\tif (is_running) {\n\t\t\t/*\n\t\t\t * Let lockdep know the real task is sleeping, to print\n\t\t\t * the held locks (recall we turned lockdep off, so\n\t\t\t * locking/unlocking @report_lock won't be recorded).\n\t\t\t */\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\t/*\n\t\t * We cannot call schedule() since we also cannot reliably\n\t\t * determine if sleeping here is permitted -- see in_atomic().\n\t\t */\n\n\t\tudelay(1);\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t\tif (timeout-- < 0) {\n\t\t\t/*\n\t\t\t * Abort. Reset @other_info->task to NULL, since it\n\t\t\t * appears the other thread is still going to consume\n\t\t\t * it. It will result in no verbose info printed for\n\t\t\t * this task.\n\t\t\t */\n\t\t\tother_info->task = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If invalid, or @ptr nor @current matches, then @other_info\n\t\t * has been consumed and we may continue. If not, retry.\n\t\t */\n\t} while (other_info->ai.size && other_info->ai.ptr == ai->ptr &&\n\t\t other_info->task == current);\n\tif (is_running)\n\t\tset_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "release_report",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "499-507",
    "snippet": "static void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&report_lock",
            "*flags"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t/*\n\t * Use size to denote valid/invalid, since KCSAN entirely ignores\n\t * 0-sized accesses.\n\t */\n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}"
  },
  {
    "function_name": "print_report",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "388-497",
    "snippet": "static void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [
      "#define NUM_STACK_ENTRIES 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"panic_on_warn set ...\\n\""
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"==================================================================\\n\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack_print_info",
          "args": [
            "KERN_DEFAULT"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Reported by Kernel Concurrency Sanitizer on:\\n\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\"",
            "hex_len",
            "diff",
            "hex_len",
            "mask"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"value changed: 0x%0*llx -> 0x%0*llx\\n\"",
            "hex_len",
            "old",
            "hex_len",
            "new"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_verbose_info",
          "args": [
            "current"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "print_verbose_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "375-386",
          "snippet": "static void print_verbose_info(struct task_struct *task)\n{\n\tif (!task)\n\t\treturn;\n\n\t/* Restore IRQ state trace for printing. */\n\tkcsan_restore_irqtrace(task);\n\n\tpr_err(\"\\n\");\n\tdebug_show_held_locks(task);\n\tprint_irqtrace_events(task);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic void print_verbose_info(struct task_struct *task)\n{\n\tif (!task)\n\t\treturn;\n\n\t/* Restore IRQ state trace for printing. */\n\tkcsan_restore_irqtrace(task);\n\n\tpr_err(\"\\n\");\n\tdebug_show_held_locks(task);\n\tprint_irqtrace_events(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_VERBOSE"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "stack_entries + skipnr",
            "num_stack_entries - skipnr",
            "reordered_to"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "367-373",
          "snippet": "static void\nprint_stack_trace(unsigned long stack_entries[], int num_entries, unsigned long reordered_to)\n{\n\tstack_trace_print(stack_entries, num_entries, 0);\n\tif (reordered_to)\n\t\tpr_err(\"  |\\n  +-> reordered to: %pS\\n\", (void *)reordered_to);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic void\nprint_stack_trace(unsigned long stack_entries[], int num_entries, unsigned long reordered_to)\n{\n\tstack_trace_print(stack_entries, num_entries, 0);\n\tif (reordered_to)\n\t\tpr_err(\"  |\\n  +-> reordered to: %pS\\n\", (void *)reordered_to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\"",
            "get_access_type(ai->access_type)",
            "ai->ptr",
            "ai->size",
            "get_thread_desc(ai->task_pid)",
            "ai->cpu_id"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_thread_desc",
          "args": [
            "ai->task_pid"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "get_thread_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "265-274",
          "snippet": "static const char *get_thread_desc(int task_id)\n{\n\tif (task_id != -1) {\n\t\tstatic char buf[32]; /* safe: protected by report_lock */\n\n\t\tsnprintf(buf, sizeof(buf), \"task %i\", task_id);\n\t\treturn buf;\n\t}\n\treturn \"interrupt\";\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(report_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic const char *get_thread_desc(int task_id)\n{\n\tif (task_id != -1) {\n\t\tstatic char buf[32]; /* safe: protected by report_lock */\n\n\t\tsnprintf(buf, sizeof(buf), \"task %i\", task_id);\n\t\treturn buf;\n\t}\n\treturn \"interrupt\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_access_type",
          "args": [
            "ai->access_type"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "get_access_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "213-257",
          "snippet": "static const char *get_access_type(int type)\n{\n\tif (type & KCSAN_ACCESS_ASSERT) {\n\t\tif (type & KCSAN_ACCESS_SCOPED) {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses (reordered)\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes (reordered)\";\n\t\t} else {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes\";\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"read\";\n\tcase KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked)\";\n\tcase KCSAN_ACCESS_WRITE:\n\t\treturn \"write\";\n\tcase KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked)\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked)\";\n\tcase KCSAN_ACCESS_SCOPED:\n\t\treturn \"read (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE:\n\t\treturn \"write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked, reordered)\";\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic const char *get_access_type(int type)\n{\n\tif (type & KCSAN_ACCESS_ASSERT) {\n\t\tif (type & KCSAN_ACCESS_SCOPED) {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses (reordered)\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes (reordered)\";\n\t\t} else {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes\";\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"read\";\n\tcase KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked)\";\n\tcase KCSAN_ACCESS_WRITE:\n\t\treturn \"write\";\n\tcase KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked)\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked)\";\n\tcase KCSAN_ACCESS_SCOPED:\n\t\treturn \"read (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE:\n\t\treturn \"write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked, reordered)\";\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\"",
            "get_access_type(ai->access_type)",
            "ai->ptr",
            "ai->size",
            "get_thread_desc(ai->task_pid)",
            "ai->cpu_id"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_VERBOSE"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\"",
            "get_access_type(other_info->ai.access_type)",
            "other_info->ai.ptr",
            "other_info->ai.size",
            "get_thread_desc(other_info->ai.task_pid)",
            "other_info->ai.cpu_id"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: KCSAN: %s in %pS\\n\"",
            "get_bug_type(ai->access_type)",
            "(void *)this_frame"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bug_type",
          "args": [
            "ai->access_type"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "get_bug_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "259-262",
          "snippet": "static const char *get_bug_type(int type)\n{\n\treturn (type & KCSAN_ACCESS_ASSERT) != 0 ? \"assert: race\" : \"data-race\";\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic const char *get_bug_type(int type)\n{\n\treturn (type & KCSAN_ACCESS_ASSERT) != 0 ? \"assert: race\" : \"data-race\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: KCSAN: %s in %ps / %ps\\n\"",
            "get_bug_type(ai->access_type | other_info->ai.access_type)",
            "(void *)(cmp < 0 ? other_frame : this_frame)",
            "(void *)(cmp < 0 ? this_frame : other_frame)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_strcmp",
          "args": [
            "(void *)other_frame",
            "(void *)this_frame"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"==================================================================\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rate_limit_report",
          "args": [
            "this_frame",
            "other_frame"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "rate_limit_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "118-165",
          "snippet": "static bool rate_limit_report(unsigned long frame1, unsigned long frame2)\n{\n\tstruct report_time *use_entry = &report_times[0];\n\tunsigned long invalid_before;\n\tint i;\n\n\tBUILD_BUG_ON(CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0);\n\n\tif (CONFIG_KCSAN_REPORT_ONCE_IN_MS == 0)\n\t\treturn false;\n\n\tinvalid_before = jiffies - msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS);\n\n\t/* Check if a matching race report exists. */\n\tfor (i = 0; i < REPORT_TIMES_SIZE; ++i) {\n\t\tstruct report_time *rt = &report_times[i];\n\n\t\t/*\n\t\t * Must always select an entry for use to store info as we\n\t\t * cannot resize report_times; at the end of the scan, use_entry\n\t\t * will be the oldest entry, which ideally also happened before\n\t\t * KCSAN_REPORT_ONCE_IN_MS ago.\n\t\t */\n\t\tif (time_before(rt->time, use_entry->time))\n\t\t\tuse_entry = rt;\n\n\t\t/*\n\t\t * Initially, no need to check any further as this entry as well\n\t\t * as following entries have never been used.\n\t\t */\n\t\tif (rt->time == 0)\n\t\t\tbreak;\n\n\t\t/* Check if entry expired. */\n\t\tif (time_before(rt->time, invalid_before))\n\t\t\tcontinue; /* before KCSAN_REPORT_ONCE_IN_MS ago */\n\n\t\t/* Reported recently, check if race matches. */\n\t\tif ((rt->frame1 == frame1 && rt->frame2 == frame2) ||\n\t\t    (rt->frame1 == frame2 && rt->frame2 == frame1))\n\t\t\treturn true;\n\t}\n\n\tuse_entry->time = jiffies;\n\tuse_entry->frame1 = frame1;\n\tuse_entry->frame2 = frame2;\n\treturn false;\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define REPORT_TIMES_SIZE                                                      \\\n\t(CONFIG_KCSAN_REPORT_ONCE_IN_MS > REPORT_TIMES_MAX ?                   \\\n\t\t REPORT_TIMES_MAX :                                            \\\n\t\t CONFIG_KCSAN_REPORT_ONCE_IN_MS)"
          ],
          "globals_used": [
            "static struct report_time report_times[REPORT_TIMES_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define REPORT_TIMES_SIZE                                                      \\\n\t(CONFIG_KCSAN_REPORT_ONCE_IN_MS > REPORT_TIMES_MAX ?                   \\\n\t\t REPORT_TIMES_MAX :                                            \\\n\t\t CONFIG_KCSAN_REPORT_ONCE_IN_MS)\n\nstatic struct report_time report_times[REPORT_TIMES_SIZE];\n\nstatic bool rate_limit_report(unsigned long frame1, unsigned long frame2)\n{\n\tstruct report_time *use_entry = &report_times[0];\n\tunsigned long invalid_before;\n\tint i;\n\n\tBUILD_BUG_ON(CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0);\n\n\tif (CONFIG_KCSAN_REPORT_ONCE_IN_MS == 0)\n\t\treturn false;\n\n\tinvalid_before = jiffies - msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS);\n\n\t/* Check if a matching race report exists. */\n\tfor (i = 0; i < REPORT_TIMES_SIZE; ++i) {\n\t\tstruct report_time *rt = &report_times[i];\n\n\t\t/*\n\t\t * Must always select an entry for use to store info as we\n\t\t * cannot resize report_times; at the end of the scan, use_entry\n\t\t * will be the oldest entry, which ideally also happened before\n\t\t * KCSAN_REPORT_ONCE_IN_MS ago.\n\t\t */\n\t\tif (time_before(rt->time, use_entry->time))\n\t\t\tuse_entry = rt;\n\n\t\t/*\n\t\t * Initially, no need to check any further as this entry as well\n\t\t * as following entries have never been used.\n\t\t */\n\t\tif (rt->time == 0)\n\t\t\tbreak;\n\n\t\t/* Check if entry expired. */\n\t\tif (time_before(rt->time, invalid_before))\n\t\t\tcontinue; /* before KCSAN_REPORT_ONCE_IN_MS ago */\n\n\t\t/* Reported recently, check if race matches. */\n\t\tif ((rt->frame1 == frame1 && rt->frame2 == frame2) ||\n\t\t    (rt->frame1 == frame2 && rt->frame2 == frame1))\n\t\t\treturn true;\n\t}\n\n\tuse_entry->time = jiffies;\n\tuse_entry->frame1 = frame1;\n\tuse_entry->frame2 = frame2;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_report",
          "args": [
            "value_change",
            "other_frame"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "skip_report",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "170-211",
          "snippet": "static bool\nskip_report(enum kcsan_value_change value_change, unsigned long top_frame)\n{\n\t/* Should never get here if value_change==FALSE. */\n\tWARN_ON_ONCE(value_change == KCSAN_VALUE_CHANGE_FALSE);\n\n\t/*\n\t * The first call to skip_report always has value_change==TRUE, since we\n\t * cannot know the value written of an instrumented access. For the 2nd\n\t * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:\n\t *\n\t * 1. read watchpoint, conflicting write (value_change==TRUE): report;\n\t * 2. read watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 3. write watchpoint, conflicting write (value_change==TRUE): report;\n\t * 4. write watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 5. write watchpoint, conflicting read (value_change==MAYBE): skip;\n\t * 6. write watchpoint, conflicting read (value_change==TRUE): report;\n\t *\n\t * Cases 1-4 are intuitive and expected; case 5 ensures we do not report\n\t * data races where the write may have rewritten the same value; case 6\n\t * is possible either if the size is larger than what we check value\n\t * changes for or the access type is KCSAN_ACCESS_ASSERT.\n\t */\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&\n\t    value_change == KCSAN_VALUE_CHANGE_MAYBE) {\n\t\t/*\n\t\t * The access is a write, but the data value did not change.\n\t\t *\n\t\t * We opt-out of this filter for certain functions at request of\n\t\t * maintainers.\n\t\t */\n\t\tchar buf[64];\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)top_frame);\n\n\t\tif (!strnstr(buf, \"rcu_\", len) &&\n\t\t    !strnstr(buf, \"_rcu\", len) &&\n\t\t    !strnstr(buf, \"_srcu\", len))\n\t\t\treturn true;\n\t}\n\n\treturn kcsan_skip_report_debugfs(top_frame);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic bool\nskip_report(enum kcsan_value_change value_change, unsigned long top_frame)\n{\n\t/* Should never get here if value_change==FALSE. */\n\tWARN_ON_ONCE(value_change == KCSAN_VALUE_CHANGE_FALSE);\n\n\t/*\n\t * The first call to skip_report always has value_change==TRUE, since we\n\t * cannot know the value written of an instrumented access. For the 2nd\n\t * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:\n\t *\n\t * 1. read watchpoint, conflicting write (value_change==TRUE): report;\n\t * 2. read watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 3. write watchpoint, conflicting write (value_change==TRUE): report;\n\t * 4. write watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 5. write watchpoint, conflicting read (value_change==MAYBE): skip;\n\t * 6. write watchpoint, conflicting read (value_change==TRUE): report;\n\t *\n\t * Cases 1-4 are intuitive and expected; case 5 ensures we do not report\n\t * data races where the write may have rewritten the same value; case 6\n\t * is possible either if the size is larger than what we check value\n\t * changes for or the access type is KCSAN_ACCESS_ASSERT.\n\t */\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&\n\t    value_change == KCSAN_VALUE_CHANGE_MAYBE) {\n\t\t/*\n\t\t * The access is a write, but the data value did not change.\n\t\t *\n\t\t * We opt-out of this filter for certain functions at request of\n\t\t * maintainers.\n\t\t */\n\t\tchar buf[64];\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)top_frame);\n\n\t\tif (!strnstr(buf, \"rcu_\", len) &&\n\t\t    !strnstr(buf, \"_rcu\", len) &&\n\t\t    !strnstr(buf, \"_srcu\", len))\n\t\t\treturn true;\n\t}\n\n\treturn kcsan_skip_report_debugfs(top_frame);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_stack_entries",
          "args": [
            "other_info->stack_entries",
            "other_info->num_stack_entries",
            "other_info->ai.ip",
            "&other_reordered_to"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_stack_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "347-353",
          "snippet": "static int\nsanitize_stack_entries(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t       unsigned long *replaced)\n{\n\treturn ip ? replace_stack_entry(stack_entries, num_entries, ip, replaced) :\n\t\t\t  get_stack_skipnr(stack_entries, num_entries);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int\nsanitize_stack_entries(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t       unsigned long *replaced)\n{\n\treturn ip ? replace_stack_entry(stack_entries, num_entries, ip, replaced) :\n\t\t\t  get_stack_skipnr(stack_entries, num_entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "stack_entries",
            "NUM_STACK_ENTRIES",
            "1"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define NUM_STACK_ENTRIES 64\n\nstatic void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0; /* silence uninit warnings */\n\n\t/*\n\t * Must check report filter rules before starting to print.\n\t */\n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t/* @value_change is only known for the other thread */\n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t/* Print report header. */\n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t/*\n\t\t * Order functions lexographically for consistent bug titles.\n\t\t * Do not print offset of functions to keep title short.\n\t\t */\n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t/* Print information about the racing accesses. */\n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t/* Print the other thread's stack trace. */\n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t/* Print stack trace of this thread. */\n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t/* Print observed value change. */\n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Print report footer. */\n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tif (panic_on_warn)\n\t\tpanic(\"panic_on_warn set ...\\n\");\n}"
  },
  {
    "function_name": "print_verbose_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "375-386",
    "snippet": "static void print_verbose_info(struct task_struct *task)\n{\n\tif (!task)\n\t\treturn;\n\n\t/* Restore IRQ state trace for printing. */\n\tkcsan_restore_irqtrace(task);\n\n\tpr_err(\"\\n\");\n\tdebug_show_held_locks(task);\n\tprint_irqtrace_events(task);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "task"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "task"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6486-6493",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_restore_irqtrace",
          "args": [
            "task"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_restore_irqtrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "354-359",
          "snippet": "void kcsan_restore_irqtrace(struct task_struct *task)\n{\n#ifdef CONFIG_TRACE_IRQFLAGS\n\ttask->irqtrace = task->kcsan_save_irqtrace;\n#endif\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid kcsan_restore_irqtrace(struct task_struct *task)\n{\n#ifdef CONFIG_TRACE_IRQFLAGS\n\ttask->irqtrace = task->kcsan_save_irqtrace;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic void print_verbose_info(struct task_struct *task)\n{\n\tif (!task)\n\t\treturn;\n\n\t/* Restore IRQ state trace for printing. */\n\tkcsan_restore_irqtrace(task);\n\n\tpr_err(\"\\n\");\n\tdebug_show_held_locks(task);\n\tprint_irqtrace_events(task);\n}"
  },
  {
    "function_name": "print_stack_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "367-373",
    "snippet": "static void\nprint_stack_trace(unsigned long stack_entries[], int num_entries, unsigned long reordered_to)\n{\n\tstack_trace_print(stack_entries, num_entries, 0);\n\tif (reordered_to)\n\t\tpr_err(\"  |\\n  +-> reordered to: %pS\\n\", (void *)reordered_to);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"  |\\n  +-> reordered to: %pS\\n\"",
            "(void *)reordered_to"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_print",
          "args": [
            "stack_entries",
            "num_entries",
            "0"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "24-34",
          "snippet": "void stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nvoid stack_trace_print(const unsigned long *entries, unsigned int nr_entries,\n\t\t       int spaces)\n{\n\tunsigned int i;\n\n\tif (WARN_ON(!entries))\n\t\treturn;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)entries[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic void\nprint_stack_trace(unsigned long stack_entries[], int num_entries, unsigned long reordered_to)\n{\n\tstack_trace_print(stack_entries, num_entries, 0);\n\tif (reordered_to)\n\t\tpr_err(\"  |\\n  +-> reordered to: %pS\\n\", (void *)reordered_to);\n}"
  },
  {
    "function_name": "sym_strcmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "356-365",
    "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf1",
            "buf2",
            "sizeof(buf1)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf2",
            "sizeof(buf2)",
            "\"%pS\"",
            "addr2"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf1",
            "sizeof(buf1)",
            "\"%pS\"",
            "addr1"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
  },
  {
    "function_name": "sanitize_stack_entries",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "347-353",
    "snippet": "static int\nsanitize_stack_entries(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t       unsigned long *replaced)\n{\n\treturn ip ? replace_stack_entry(stack_entries, num_entries, ip, replaced) :\n\t\t\t  get_stack_skipnr(stack_entries, num_entries);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stack_skipnr",
          "args": [
            "stack_entries",
            "num_entries"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "get_stack_skipnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "277-307",
          "snippet": "static int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_stack_entry",
          "args": [
            "stack_entries",
            "num_entries",
            "ip",
            "replaced"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "replace_stack_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "314-345",
          "snippet": "static int\nreplace_stack_entry(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t    unsigned long *replaced)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long target_func;\n\tint skip;\n\n\tif (kallsyms_lookup_size_offset(ip, &symbolsize, &offset))\n\t\ttarget_func = ip - offset;\n\telse\n\t\tgoto fallback;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tunsigned long func = stack_entries[skip];\n\n\t\tif (!kallsyms_lookup_size_offset(func, &symbolsize, &offset))\n\t\t\tgoto fallback;\n\t\tfunc -= offset;\n\n\t\tif (func == target_func) {\n\t\t\t*replaced = stack_entries[skip];\n\t\t\tstack_entries[skip] = ip;\n\t\t\treturn skip;\n\t\t}\n\t}\n\nfallback:\n\t/* Should not happen; the resulting stack trace is likely misleading. */\n\tWARN_ONCE(1, \"Cannot find frame for %pS in stack trace\", (void *)ip);\n\treturn get_stack_skipnr(stack_entries, num_entries);\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int\nreplace_stack_entry(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t    unsigned long *replaced)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long target_func;\n\tint skip;\n\n\tif (kallsyms_lookup_size_offset(ip, &symbolsize, &offset))\n\t\ttarget_func = ip - offset;\n\telse\n\t\tgoto fallback;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tunsigned long func = stack_entries[skip];\n\n\t\tif (!kallsyms_lookup_size_offset(func, &symbolsize, &offset))\n\t\t\tgoto fallback;\n\t\tfunc -= offset;\n\n\t\tif (func == target_func) {\n\t\t\t*replaced = stack_entries[skip];\n\t\t\tstack_entries[skip] = ip;\n\t\t\treturn skip;\n\t\t}\n\t}\n\nfallback:\n\t/* Should not happen; the resulting stack trace is likely misleading. */\n\tWARN_ONCE(1, \"Cannot find frame for %pS in stack trace\", (void *)ip);\n\treturn get_stack_skipnr(stack_entries, num_entries);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int\nsanitize_stack_entries(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t       unsigned long *replaced)\n{\n\treturn ip ? replace_stack_entry(stack_entries, num_entries, ip, replaced) :\n\t\t\t  get_stack_skipnr(stack_entries, num_entries);\n}"
  },
  {
    "function_name": "replace_stack_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "314-345",
    "snippet": "static int\nreplace_stack_entry(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t    unsigned long *replaced)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long target_func;\n\tint skip;\n\n\tif (kallsyms_lookup_size_offset(ip, &symbolsize, &offset))\n\t\ttarget_func = ip - offset;\n\telse\n\t\tgoto fallback;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tunsigned long func = stack_entries[skip];\n\n\t\tif (!kallsyms_lookup_size_offset(func, &symbolsize, &offset))\n\t\t\tgoto fallback;\n\t\tfunc -= offset;\n\n\t\tif (func == target_func) {\n\t\t\t*replaced = stack_entries[skip];\n\t\t\tstack_entries[skip] = ip;\n\t\t\treturn skip;\n\t\t}\n\t}\n\nfallback:\n\t/* Should not happen; the resulting stack trace is likely misleading. */\n\tWARN_ONCE(1, \"Cannot find frame for %pS in stack trace\", (void *)ip);\n\treturn get_stack_skipnr(stack_entries, num_entries);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stack_skipnr",
          "args": [
            "stack_entries",
            "num_entries"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "get_stack_skipnr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "277-307",
          "snippet": "static int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Cannot find frame for %pS in stack trace\"",
            "(void *)ip"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "func",
            "&symbolsize",
            "&offset"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "315-326",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int\nreplace_stack_entry(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t    unsigned long *replaced)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long target_func;\n\tint skip;\n\n\tif (kallsyms_lookup_size_offset(ip, &symbolsize, &offset))\n\t\ttarget_func = ip - offset;\n\telse\n\t\tgoto fallback;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tunsigned long func = stack_entries[skip];\n\n\t\tif (!kallsyms_lookup_size_offset(func, &symbolsize, &offset))\n\t\t\tgoto fallback;\n\t\tfunc -= offset;\n\n\t\tif (func == target_func) {\n\t\t\t*replaced = stack_entries[skip];\n\t\t\tstack_entries[skip] = ip;\n\t\t\treturn skip;\n\t\t}\n\t}\n\nfallback:\n\t/* Should not happen; the resulting stack trace is likely misleading. */\n\tWARN_ONCE(1, \"Cannot find frame for %pS in stack trace\", (void *)ip);\n\treturn get_stack_skipnr(stack_entries, num_entries);\n}"
  },
  {
    "function_name": "get_stack_skipnr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "277-307",
    "snippet": "static int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "cur",
            "\"test\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"kcsan_\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"kcsan_\"",
            "len"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"_once_size\"",
            "len"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"tsan_\"",
            "len"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%ps\"",
            "(void *)stack_entries[skip]"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t/* Never show tsan_* or {read,write}_once_size. */\n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue; /* KCSAN runtime function. */\n\t\t\t/* KCSAN related test. */\n\t\t}\n\n\t\t/*\n\t\t * No match for runtime functions -- @skip entries to skip to\n\t\t * get to first frame of interest.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn skip;\n}"
  },
  {
    "function_name": "get_thread_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "265-274",
    "snippet": "static const char *get_thread_desc(int task_id)\n{\n\tif (task_id != -1) {\n\t\tstatic char buf[32]; /* safe: protected by report_lock */\n\n\t\tsnprintf(buf, sizeof(buf), \"task %i\", task_id);\n\t\treturn buf;\n\t}\n\treturn \"interrupt\";\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(report_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"task %i\"",
            "task_id"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\nstatic const char *get_thread_desc(int task_id)\n{\n\tif (task_id != -1) {\n\t\tstatic char buf[32]; /* safe: protected by report_lock */\n\n\t\tsnprintf(buf, sizeof(buf), \"task %i\", task_id);\n\t\treturn buf;\n\t}\n\treturn \"interrupt\";\n}"
  },
  {
    "function_name": "get_bug_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "259-262",
    "snippet": "static const char *get_bug_type(int type)\n{\n\treturn (type & KCSAN_ACCESS_ASSERT) != 0 ? \"assert: race\" : \"data-race\";\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic const char *get_bug_type(int type)\n{\n\treturn (type & KCSAN_ACCESS_ASSERT) != 0 ? \"assert: race\" : \"data-race\";\n}"
  },
  {
    "function_name": "get_access_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "213-257",
    "snippet": "static const char *get_access_type(int type)\n{\n\tif (type & KCSAN_ACCESS_ASSERT) {\n\t\tif (type & KCSAN_ACCESS_SCOPED) {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses (reordered)\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes (reordered)\";\n\t\t} else {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes\";\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"read\";\n\tcase KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked)\";\n\tcase KCSAN_ACCESS_WRITE:\n\t\treturn \"write\";\n\tcase KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked)\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked)\";\n\tcase KCSAN_ACCESS_SCOPED:\n\t\treturn \"read (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE:\n\t\treturn \"write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked, reordered)\";\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic const char *get_access_type(int type)\n{\n\tif (type & KCSAN_ACCESS_ASSERT) {\n\t\tif (type & KCSAN_ACCESS_SCOPED) {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses (reordered)\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes (reordered)\";\n\t\t} else {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes\";\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"read\";\n\tcase KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked)\";\n\tcase KCSAN_ACCESS_WRITE:\n\t\treturn \"write\";\n\tcase KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked)\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked)\";\n\tcase KCSAN_ACCESS_SCOPED:\n\t\treturn \"read (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE:\n\t\treturn \"write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked, reordered)\";\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "skip_report",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "170-211",
    "snippet": "static bool\nskip_report(enum kcsan_value_change value_change, unsigned long top_frame)\n{\n\t/* Should never get here if value_change==FALSE. */\n\tWARN_ON_ONCE(value_change == KCSAN_VALUE_CHANGE_FALSE);\n\n\t/*\n\t * The first call to skip_report always has value_change==TRUE, since we\n\t * cannot know the value written of an instrumented access. For the 2nd\n\t * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:\n\t *\n\t * 1. read watchpoint, conflicting write (value_change==TRUE): report;\n\t * 2. read watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 3. write watchpoint, conflicting write (value_change==TRUE): report;\n\t * 4. write watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 5. write watchpoint, conflicting read (value_change==MAYBE): skip;\n\t * 6. write watchpoint, conflicting read (value_change==TRUE): report;\n\t *\n\t * Cases 1-4 are intuitive and expected; case 5 ensures we do not report\n\t * data races where the write may have rewritten the same value; case 6\n\t * is possible either if the size is larger than what we check value\n\t * changes for or the access type is KCSAN_ACCESS_ASSERT.\n\t */\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&\n\t    value_change == KCSAN_VALUE_CHANGE_MAYBE) {\n\t\t/*\n\t\t * The access is a write, but the data value did not change.\n\t\t *\n\t\t * We opt-out of this filter for certain functions at request of\n\t\t * maintainers.\n\t\t */\n\t\tchar buf[64];\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)top_frame);\n\n\t\tif (!strnstr(buf, \"rcu_\", len) &&\n\t\t    !strnstr(buf, \"_rcu\", len) &&\n\t\t    !strnstr(buf, \"_srcu\", len))\n\t\t\treturn true;\n\t}\n\n\treturn kcsan_skip_report_debugfs(top_frame);\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_skip_report_debugfs",
          "args": [
            "top_frame"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_skip_report_debugfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "103-132",
          "snippet": "bool kcsan_skip_report_debugfs(unsigned long func_addr)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))\n\t\treturn false;\n\tfunc_addr -= offset; /* Get function start */\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tif (report_filterlist.used == 0)\n\t\tgoto out;\n\n\t/* Sort array if it is unsorted, and then do a binary search. */\n\tif (!report_filterlist.sorted) {\n\t\tsort(report_filterlist.addrs, report_filterlist.used,\n\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);\n\t\treport_filterlist.sorted = true;\n\t}\n\tret = !!bsearch(&func_addr, report_filterlist.addrs,\n\t\t\treport_filterlist.used, sizeof(unsigned long),\n\t\t\tcmp_filterlist_addrs);\n\tif (report_filterlist.whitelist)\n\t\tret = !ret;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};",
            "static DEFINE_SPINLOCK(report_filterlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic struct {\n\tunsigned long\t*addrs;\t\t/* array of addresses */\n\tsize_t\t\tsize;\t\t/* current size */\n\tint\t\tused;\t\t/* number of elements used */\n\tbool\t\tsorted;\t\t/* if elements are sorted */\n\tbool\t\twhitelist;\t/* if list is a blacklist or whitelist */\n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t/* small initial size */\n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t/* default is blacklist */\n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\nbool kcsan_skip_report_debugfs(unsigned long func_addr)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))\n\t\treturn false;\n\tfunc_addr -= offset; /* Get function start */\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tif (report_filterlist.used == 0)\n\t\tgoto out;\n\n\t/* Sort array if it is unsorted, and then do a binary search. */\n\tif (!report_filterlist.sorted) {\n\t\tsort(report_filterlist.addrs, report_filterlist.used,\n\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);\n\t\treport_filterlist.sorted = true;\n\t}\n\tret = !!bsearch(&func_addr, report_filterlist.addrs,\n\t\t\treport_filterlist.used, sizeof(unsigned long),\n\t\t\tcmp_filterlist_addrs);\n\tif (report_filterlist.whitelist)\n\t\tret = !ret;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"_srcu\"",
            "len"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"_rcu\"",
            "len"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnstr",
          "args": [
            "buf",
            "\"rcu_\"",
            "len"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%ps\"",
            "(void *)top_frame"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "value_change == KCSAN_VALUE_CHANGE_FALSE"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic bool\nskip_report(enum kcsan_value_change value_change, unsigned long top_frame)\n{\n\t/* Should never get here if value_change==FALSE. */\n\tWARN_ON_ONCE(value_change == KCSAN_VALUE_CHANGE_FALSE);\n\n\t/*\n\t * The first call to skip_report always has value_change==TRUE, since we\n\t * cannot know the value written of an instrumented access. For the 2nd\n\t * call there are 6 cases with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY:\n\t *\n\t * 1. read watchpoint, conflicting write (value_change==TRUE): report;\n\t * 2. read watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 3. write watchpoint, conflicting write (value_change==TRUE): report;\n\t * 4. write watchpoint, conflicting write (value_change==MAYBE): skip;\n\t * 5. write watchpoint, conflicting read (value_change==MAYBE): skip;\n\t * 6. write watchpoint, conflicting read (value_change==TRUE): report;\n\t *\n\t * Cases 1-4 are intuitive and expected; case 5 ensures we do not report\n\t * data races where the write may have rewritten the same value; case 6\n\t * is possible either if the size is larger than what we check value\n\t * changes for or the access type is KCSAN_ACCESS_ASSERT.\n\t */\n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&\n\t    value_change == KCSAN_VALUE_CHANGE_MAYBE) {\n\t\t/*\n\t\t * The access is a write, but the data value did not change.\n\t\t *\n\t\t * We opt-out of this filter for certain functions at request of\n\t\t * maintainers.\n\t\t */\n\t\tchar buf[64];\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)top_frame);\n\n\t\tif (!strnstr(buf, \"rcu_\", len) &&\n\t\t    !strnstr(buf, \"_rcu\", len) &&\n\t\t    !strnstr(buf, \"_srcu\", len))\n\t\t\treturn true;\n\t}\n\n\treturn kcsan_skip_report_debugfs(top_frame);\n}"
  },
  {
    "function_name": "rate_limit_report",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
    "lines": "118-165",
    "snippet": "static bool rate_limit_report(unsigned long frame1, unsigned long frame2)\n{\n\tstruct report_time *use_entry = &report_times[0];\n\tunsigned long invalid_before;\n\tint i;\n\n\tBUILD_BUG_ON(CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0);\n\n\tif (CONFIG_KCSAN_REPORT_ONCE_IN_MS == 0)\n\t\treturn false;\n\n\tinvalid_before = jiffies - msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS);\n\n\t/* Check if a matching race report exists. */\n\tfor (i = 0; i < REPORT_TIMES_SIZE; ++i) {\n\t\tstruct report_time *rt = &report_times[i];\n\n\t\t/*\n\t\t * Must always select an entry for use to store info as we\n\t\t * cannot resize report_times; at the end of the scan, use_entry\n\t\t * will be the oldest entry, which ideally also happened before\n\t\t * KCSAN_REPORT_ONCE_IN_MS ago.\n\t\t */\n\t\tif (time_before(rt->time, use_entry->time))\n\t\t\tuse_entry = rt;\n\n\t\t/*\n\t\t * Initially, no need to check any further as this entry as well\n\t\t * as following entries have never been used.\n\t\t */\n\t\tif (rt->time == 0)\n\t\t\tbreak;\n\n\t\t/* Check if entry expired. */\n\t\tif (time_before(rt->time, invalid_before))\n\t\t\tcontinue; /* before KCSAN_REPORT_ONCE_IN_MS ago */\n\n\t\t/* Reported recently, check if race matches. */\n\t\tif ((rt->frame1 == frame1 && rt->frame2 == frame2) ||\n\t\t    (rt->frame1 == frame2 && rt->frame2 == frame1))\n\t\t\treturn true;\n\t}\n\n\tuse_entry->time = jiffies;\n\tuse_entry->frame1 = frame1;\n\tuse_entry->frame2 = frame2;\n\treturn false;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include \"kcsan.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/printk.h>",
      "#include <linux/preempt.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>"
    ],
    "macros_used": [
      "#define REPORT_TIMES_SIZE                                                      \\\n\t(CONFIG_KCSAN_REPORT_ONCE_IN_MS > REPORT_TIMES_MAX ?                   \\\n\t\t REPORT_TIMES_MAX :                                            \\\n\t\t CONFIG_KCSAN_REPORT_ONCE_IN_MS)"
    ],
    "globals_used": [
      "static struct report_time report_times[REPORT_TIMES_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "rt->time",
            "invalid_before"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "rt->time",
            "use_entry->time"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "CONFIG_KCSAN_REPORT_ONCE_IN_MS"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\n#define REPORT_TIMES_SIZE                                                      \\\n\t(CONFIG_KCSAN_REPORT_ONCE_IN_MS > REPORT_TIMES_MAX ?                   \\\n\t\t REPORT_TIMES_MAX :                                            \\\n\t\t CONFIG_KCSAN_REPORT_ONCE_IN_MS)\n\nstatic struct report_time report_times[REPORT_TIMES_SIZE];\n\nstatic bool rate_limit_report(unsigned long frame1, unsigned long frame2)\n{\n\tstruct report_time *use_entry = &report_times[0];\n\tunsigned long invalid_before;\n\tint i;\n\n\tBUILD_BUG_ON(CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0);\n\n\tif (CONFIG_KCSAN_REPORT_ONCE_IN_MS == 0)\n\t\treturn false;\n\n\tinvalid_before = jiffies - msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS);\n\n\t/* Check if a matching race report exists. */\n\tfor (i = 0; i < REPORT_TIMES_SIZE; ++i) {\n\t\tstruct report_time *rt = &report_times[i];\n\n\t\t/*\n\t\t * Must always select an entry for use to store info as we\n\t\t * cannot resize report_times; at the end of the scan, use_entry\n\t\t * will be the oldest entry, which ideally also happened before\n\t\t * KCSAN_REPORT_ONCE_IN_MS ago.\n\t\t */\n\t\tif (time_before(rt->time, use_entry->time))\n\t\t\tuse_entry = rt;\n\n\t\t/*\n\t\t * Initially, no need to check any further as this entry as well\n\t\t * as following entries have never been used.\n\t\t */\n\t\tif (rt->time == 0)\n\t\t\tbreak;\n\n\t\t/* Check if entry expired. */\n\t\tif (time_before(rt->time, invalid_before))\n\t\t\tcontinue; /* before KCSAN_REPORT_ONCE_IN_MS ago */\n\n\t\t/* Reported recently, check if race matches. */\n\t\tif ((rt->frame1 == frame1 && rt->frame2 == frame2) ||\n\t\t    (rt->frame1 == frame2 && rt->frame2 == frame1))\n\t\t\treturn true;\n\t}\n\n\tuse_entry->time = jiffies;\n\tuse_entry->frame1 = frame1;\n\tuse_entry->frame2 = frame2;\n\treturn false;\n}"
  }
]