[
  {
    "function_name": "tick_check_oneshot_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1525-1543",
    "snippet": "int tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_switch_to_nohz",
          "args": [],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_switch_to_nohz",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1391-1391",
          "snippet": "static inline void tick_nohz_switch_to_nohz(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_switch_to_nohz(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_oneshot_available",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_oneshot_available",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "71-80",
          "snippet": "int tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_valid_for_hres",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_valid_for_hres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1518-1532",
          "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&ts->check_clocks"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nint tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_oneshot_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1510-1515",
    "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "&ts->check_clocks"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
  },
  {
    "function_name": "tick_clock_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1499-1505",
    "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
  },
  {
    "function_name": "tick_cancel_sched_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1483-1493",
    "snippet": "void tick_cancel_sched_timer(int cpu)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\n# ifdef CONFIG_HIGH_RES_TIMERS\n\tif (ts->sched_timer.base)\n\t\thrtimer_cancel(&ts->sched_timer);\n# endif\n\n\tmemset(ts, 0, sizeof(*ts));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ts",
            "0",
            "sizeof(*ts)"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_cancel_sched_timer(int cpu)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\n# ifdef CONFIG_HIGH_RES_TIMERS\n\tif (ts->sched_timer.base)\n\t\thrtimer_cancel(&ts->sched_timer);\n# endif\n\n\tmemset(ts, 0, sizeof(*ts));\n}"
  },
  {
    "function_name": "tick_setup_sched_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1454-1479",
    "snippet": "void tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = TICK_NSEC >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_activate",
          "args": [
            "ts",
            "NOHZ_MODE_HIGHRES"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1393-1393",
          "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&ts->sched_timer",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "TICK_NSEC"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "&ts->sched_timer",
            "offset"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "offset",
            "num_possible_cpus()"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "tick_init_jiffy_update()"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_jiffy_update",
          "args": [],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_jiffy_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "157-170",
          "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&ts->sched_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = TICK_NSEC >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}"
  },
  {
    "function_name": "skew_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1443-1448",
    "snippet": "static int __init skew_tick(char *str)\n{\n\tget_option(&str, &sched_skew_tick);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&sched_skew_tick"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int __init skew_tick(char *str)\n{\n\tget_option(&str, &sched_skew_tick);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_sched_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1414-1439",
    "snippet": "static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)\n{\n\tstruct tick_sched *ts =\n\t\tcontainer_of(timer, struct tick_sched, sched_timer);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\ttick_sched_do_timer(ts, now);\n\n\t/*\n\t * Do not call, when we are not in irq context and have\n\t * no valid regs pointer\n\t */\n\tif (regs)\n\t\ttick_sched_handle(ts, regs);\n\telse\n\t\tts->next_tick = 0;\n\n\t/* No need to reprogram if we are in idle or full dynticks mode */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn HRTIMER_NORESTART;\n\n\thrtimer_forward(timer, now, TICK_NSEC);\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "TICK_NSEC"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tick_stopped"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_sched_handle",
          "args": [
            "ts",
            "regs"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "203-228",
          "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_sched_do_timer",
          "args": [
            "ts",
            "now"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_do_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "172-201",
          "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structtick_sched",
            "sched_timer"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)\n{\n\tstruct tick_sched *ts =\n\t\tcontainer_of(timer, struct tick_sched, sched_timer);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\ttick_sched_do_timer(ts, now);\n\n\t/*\n\t * Do not call, when we are not in irq context and have\n\t * no valid regs pointer\n\t */\n\tif (regs)\n\t\ttick_sched_handle(ts, regs);\n\telse\n\t\tts->next_tick = 0;\n\n\t/* No need to reprogram if we are in idle or full dynticks mode */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn HRTIMER_NORESTART;\n\n\thrtimer_forward(timer, now, TICK_NSEC);\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "tick_irq_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1400-1404",
    "snippet": "void tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_irq_enter",
          "args": [],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_irq_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1392-1392",
          "snippet": "static inline void tick_nohz_irq_enter(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_irq_enter(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_oneshot_broadcast_this_cpu",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_oneshot_broadcast_this_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "665-680",
          "snippet": "void tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_irq_enter(void)\n{\n\ttick_check_oneshot_broadcast_this_cpu();\n\ttick_nohz_irq_enter();\n}"
  },
  {
    "function_name": "tick_nohz_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1393-1393",
    "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
  },
  {
    "function_name": "tick_nohz_irq_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1392-1392",
    "snippet": "static inline void tick_nohz_irq_enter(void) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_irq_enter(void) { }"
  },
  {
    "function_name": "tick_nohz_switch_to_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1391-1391",
    "snippet": "static inline void tick_nohz_switch_to_nohz(void) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_switch_to_nohz(void) { }"
  },
  {
    "function_name": "tick_nohz_irq_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1368-1387",
    "snippet": "static inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->idle_active && !ts->tick_stopped)\n\t\treturn;\n\tnow = ktime_get();\n\tif (ts->idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\t/*\n\t * If all CPUs are idle. We may need to update a stale jiffies value.\n\t * Note nohz_full is a special case: a timekeeper is guaranteed to stay\n\t * alive but it might be busy looping with interrupts disabled in some\n\t * rare case (typically stop machine). So we must make sure we have a\n\t * last resort.\n\t */\n\tif (ts->tick_stopped)\n\t\ttick_nohz_update_jiffies(now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_update_jiffies",
          "args": [
            "now"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_update_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "611-622",
          "snippet": "static void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_idle",
          "args": [
            "ts",
            "now"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "646-652",
          "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->idle_active && !ts->tick_stopped)\n\t\treturn;\n\tnow = ktime_get();\n\tif (ts->idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\t/*\n\t * If all CPUs are idle. We may need to update a stale jiffies value.\n\t * Note nohz_full is a special case: a timekeeper is guaranteed to stay\n\t * alive but it might be busy looping with interrupts disabled in some\n\t * rare case (typically stop machine). So we must make sure we have a\n\t * last resort.\n\t */\n\tif (ts->tick_stopped)\n\t\ttick_nohz_update_jiffies(now);\n}"
  },
  {
    "function_name": "tick_nohz_switch_to_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1343-1366",
    "snippet": "static void tick_nohz_switch_to_nohz(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t next;\n\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\n\tif (tick_switch_to_oneshot(tick_nohz_handler))\n\t\treturn;\n\n\t/*\n\t * Recycle the hrtimer in ts, so we can share the\n\t * hrtimer_forward with the highres code.\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\t/* Get the next period */\n\tnext = tick_init_jiffy_update();\n\n\thrtimer_set_expires(&ts->sched_timer, next);\n\thrtimer_forward_now(&ts->sched_timer, TICK_NSEC);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\ttick_nohz_activate(ts, NOHZ_MODE_LOWRES);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_activate",
          "args": [
            "ts",
            "NOHZ_MODE_LOWRES"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1393-1393",
          "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "&ts->sched_timer",
            "TICK_NSEC"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "next"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_jiffy_update",
          "args": [],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_jiffy_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "157-170",
          "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&ts->sched_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_switch_to_oneshot",
          "args": [
            "tick_nohz_handler"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "tick_switch_to_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "73-99",
          "snippet": "int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||\n\t\t    !tick_device_is_functional(dev)) {\n\n\t\tpr_info(\"Clockevents: could not switch to one-shot mode:\");\n\t\tif (!dev) {\n\t\t\tpr_cont(\" no tick device\\n\");\n\t\t} else {\n\t\t\tif (!tick_device_is_functional(dev))\n\t\t\t\tpr_cont(\" %s is not functional.\\n\", dev->name);\n\t\t\telse\n\t\t\t\tpr_cont(\" %s does not support one-shot mode.\\n\",\n\t\t\t\t\tdev->name);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\ttd->mode = TICKDEV_MODE_ONESHOT;\n\tdev->event_handler = handler;\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\ttick_broadcast_switch_to_oneshot();\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||\n\t\t    !tick_device_is_functional(dev)) {\n\n\t\tpr_info(\"Clockevents: could not switch to one-shot mode:\");\n\t\tif (!dev) {\n\t\t\tpr_cont(\" no tick device\\n\");\n\t\t} else {\n\t\t\tif (!tick_device_is_functional(dev))\n\t\t\t\tpr_cont(\" %s is not functional.\\n\", dev->name);\n\t\t\telse\n\t\t\t\tpr_cont(\" %s does not support one-shot mode.\\n\",\n\t\t\t\t\tdev->name);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\ttd->mode = TICKDEV_MODE_ONESHOT;\n\tdev->event_handler = handler;\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\ttick_broadcast_switch_to_oneshot();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_switch_to_nohz(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t next;\n\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\n\tif (tick_switch_to_oneshot(tick_nohz_handler))\n\t\treturn;\n\n\t/*\n\t * Recycle the hrtimer in ts, so we can share the\n\t * hrtimer_forward with the highres code.\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\t/* Get the next period */\n\tnext = tick_init_jiffy_update();\n\n\thrtimer_set_expires(&ts->sched_timer, next);\n\thrtimer_forward_now(&ts->sched_timer, TICK_NSEC);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\ttick_nohz_activate(ts, NOHZ_MODE_LOWRES);\n}"
  },
  {
    "function_name": "tick_nohz_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1330-1338",
    "snippet": "static inline void tick_nohz_activate(struct tick_sched *ts, int mode)\n{\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\tts->nohz_mode = mode;\n\t/* One update is enough */\n\tif (!test_and_set_bit(0, &tick_nohz_active))\n\t\ttimers_update_nohz();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timers_update_nohz",
          "args": [],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "timers_update_nohz",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "249-252",
          "snippet": "void timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&tick_nohz_active"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_nohz_activate(struct tick_sched *ts, int mode)\n{\n\tif (!tick_nohz_enabled)\n\t\treturn;\n\tts->nohz_mode = mode;\n\t/* One update is enough */\n\tif (!test_and_set_bit(0, &tick_nohz_active))\n\t\ttimers_update_nohz();\n}"
  },
  {
    "function_name": "tick_nohz_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1311-1328",
    "snippet": "static void tick_nohz_handler(struct clock_event_device *dev)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\tdev->next_event = KTIME_MAX;\n\n\ttick_sched_do_timer(ts, now);\n\ttick_sched_handle(ts, regs);\n\n\t/* No need to reprogram if we are running tickless  */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn;\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "TICK_NSEC"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tick_stopped"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_sched_handle",
          "args": [
            "ts",
            "regs"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "203-228",
          "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_sched_do_timer",
          "args": [
            "ts",
            "now"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "tick_sched_do_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "172-201",
          "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_handler(struct clock_event_device *dev)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tstruct pt_regs *regs = get_irq_regs();\n\tktime_t now = ktime_get();\n\n\tdev->next_event = KTIME_MAX;\n\n\ttick_sched_do_timer(ts, now);\n\ttick_sched_handle(ts, regs);\n\n\t/* No need to reprogram if we are running tickless  */\n\tif (unlikely(ts->tick_stopped))\n\t\treturn;\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n}"
  },
  {
    "function_name": "tick_nohz_idle_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1281-1306",
    "snippet": "void tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\ttick_nohz_idle_update_tick(ts, now);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_update_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_update_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1264-1272",
          "snippet": "static void tick_nohz_idle_update_tick(struct tick_sched *ts, ktime_t now)\n{\n\tif (tick_nohz_full_cpu(smp_processor_id()))\n\t\t__tick_nohz_full_update_tick(ts, now);\n\telse\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\n\ttick_nohz_account_idle_time(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_idle_update_tick(struct tick_sched *ts, ktime_t now)\n{\n\tif (tick_nohz_full_cpu(smp_processor_id()))\n\t\t__tick_nohz_full_update_tick(ts, now);\n\telse\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\n\ttick_nohz_account_idle_time(ts, now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_idle",
          "args": [
            "ts",
            "now"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "646-652",
          "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ts->timer_expires_base"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ts->inidle"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\ttick_nohz_idle_update_tick(ts, now);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "tick_nohz_idle_update_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1264-1272",
    "snippet": "static void tick_nohz_idle_update_tick(struct tick_sched *ts, ktime_t now)\n{\n\tif (tick_nohz_full_cpu(smp_processor_id()))\n\t\t__tick_nohz_full_update_tick(ts, now);\n\telse\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\n\ttick_nohz_account_idle_time(ts, now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_account_idle_time",
          "args": [
            "ts",
            "now"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1231-1251",
          "snippet": "static void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_restart_sched_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "943-961",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tick_nohz_full_update_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_full_update_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "963-974",
          "snippet": "static void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_idle_update_tick(struct tick_sched *ts, ktime_t now)\n{\n\tif (tick_nohz_full_cpu(smp_processor_id()))\n\t\t__tick_nohz_full_update_tick(ts, now);\n\telse\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\n\ttick_nohz_account_idle_time(ts, now);\n}"
  },
  {
    "function_name": "tick_nohz_idle_restart_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1253-1262",
    "snippet": "void tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tktime_t now = ktime_get();\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\t\ttick_nohz_account_idle_time(ts, now);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_account_idle_time",
          "args": [
            "ts",
            "now"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_account_idle_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1231-1251",
          "snippet": "static void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_restart_sched_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "943-961",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tktime_t now = ktime_get();\n\t\ttick_nohz_restart_sched_tick(ts, now);\n\t\ttick_nohz_account_idle_time(ts, now);\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_account_idle_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1231-1251",
    "snippet": "static void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_ticks",
          "args": [
            "ticks"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_ticks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "501-518",
          "snippet": "void account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled_this_cpu",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_account_idle_time(struct tick_sched *ts,\n\t\t\t\t\tktime_t now)\n{\n\tunsigned long ticks;\n\n\tts->idle_exittime = now;\n\n\tif (vtime_accounting_enabled_this_cpu())\n\t\treturn;\n\t/*\n\t * We stopped the tick in idle. Update process times would miss the\n\t * time we slept as update_process_times does only a 1 tick\n\t * accounting. Enforce that this is accounted to idle !\n\t */\n\tticks = jiffies - ts->idle_jiffies;\n\t/*\n\t * We might be one off. Do not randomly account a huge number of ticks!\n\t */\n\tif (ticks && ticks < LONG_MAX)\n\t\taccount_idle_ticks(ticks);\n}"
  },
  {
    "function_name": "tick_nohz_get_idle_calls",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1224-1229",
    "snippet": "unsigned long tick_nohz_get_idle_calls(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->idle_calls;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nunsigned long tick_nohz_get_idle_calls(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->idle_calls;\n}"
  },
  {
    "function_name": "tick_nohz_get_idle_calls_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1212-1217",
    "snippet": "unsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_get_tick_sched",
          "args": [
            "cpu"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "41-44",
          "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nunsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}"
  },
  {
    "function_name": "tick_nohz_get_sleep_length",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1173-1204",
    "snippet": "ktime_t tick_nohz_get_sleep_length(ktime_t *delta_next)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tint cpu = smp_processor_id();\n\t/*\n\t * The idle entry time is expected to be a sufficient approximation of\n\t * the current time at this point.\n\t */\n\tktime_t now = ts->idle_entrytime;\n\tktime_t next_event;\n\n\tWARN_ON_ONCE(!ts->inidle);\n\n\t*delta_next = ktime_sub(dev->next_event, now);\n\n\tif (!can_stop_idle_tick(cpu, ts))\n\t\treturn *delta_next;\n\n\tnext_event = tick_nohz_next_event(ts, cpu);\n\tif (!next_event)\n\t\treturn *delta_next;\n\n\t/*\n\t * If the next highres timer to expire is earlier than next_event, the\n\t * idle governor needs to know that.\n\t */\n\tnext_event = min_t(u64, next_event,\n\t\t\t   hrtimer_next_event_without(&ts->sched_timer));\n\n\treturn ktime_sub(next_event, now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "next_event",
            "now"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "next_event",
            "hrtimer_next_event_without(&ts->sched_timer)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_next_event_without",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_next_event_without",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1502-1526",
          "snippet": "u64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "769-852",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_idle_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_idle_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "987-1039",
          "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "dev->next_event",
            "now"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ts->inidle"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nktime_t tick_nohz_get_sleep_length(ktime_t *delta_next)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tint cpu = smp_processor_id();\n\t/*\n\t * The idle entry time is expected to be a sufficient approximation of\n\t * the current time at this point.\n\t */\n\tktime_t now = ts->idle_entrytime;\n\tktime_t next_event;\n\n\tWARN_ON_ONCE(!ts->inidle);\n\n\t*delta_next = ktime_sub(dev->next_event, now);\n\n\tif (!can_stop_idle_tick(cpu, ts))\n\t\treturn *delta_next;\n\n\tnext_event = tick_nohz_next_event(ts, cpu);\n\tif (!next_event)\n\t\treturn *delta_next;\n\n\t/*\n\t * If the next highres timer to expire is earlier than next_event, the\n\t * idle governor needs to know that.\n\t */\n\tnext_event = min_t(u64, next_event,\n\t\t\t   hrtimer_next_event_without(&ts->sched_timer));\n\n\treturn ktime_sub(next_event, now);\n}"
  },
  {
    "function_name": "tick_nohz_get_next_hrtimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1158-1161",
    "snippet": "ktime_t tick_nohz_get_next_hrtimer(void)\n{\n\treturn __this_cpu_read(tick_cpu_device.evtdev)->next_event;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_nohz_get_next_hrtimer(void)\n{\n\treturn __this_cpu_read(tick_cpu_device.evtdev)->next_event;\n}"
  },
  {
    "function_name": "tick_nohz_idle_got_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1140-1149",
    "snippet": "bool tick_nohz_idle_got_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->got_idle_tick) {\n\t\tts->got_idle_tick = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_idle_got_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->got_idle_tick) {\n\t\tts->got_idle_tick = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "tick_nohz_irq_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1127-1135",
    "snippet": "void tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_update_tick",
          "args": [
            "ts"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_update_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "976-985",
          "snippet": "static void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\t__tick_nohz_full_update_tick(ts, ktime_get());\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\t__tick_nohz_full_update_tick(ts, ktime_get());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_start_idle",
          "args": [
            "ts"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_start_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "654-659",
          "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_irq_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->inidle)\n\t\ttick_nohz_start_idle(ts);\n\telse\n\t\ttick_nohz_full_update_tick(ts);\n}"
  },
  {
    "function_name": "tick_nohz_idle_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1101-1117",
    "snippet": "void tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_start_idle",
          "args": [
            "ts"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_start_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "654-659",
          "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ts->timer_expires_base"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "tick_nohz_idle_retain_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1086-1094",
    "snippet": "void tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1692-1703",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "this_cpu_ptr(&tick_cpu_sched)"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "928-931",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}"
  },
  {
    "function_name": "tick_nohz_idle_stop_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1081-1084",
    "snippet": "void tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_nohz_idle_stop_tick",
          "args": [
            "this_cpu_ptr(&tick_cpu_sched)"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_idle_stop_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1041-1074",
          "snippet": "static void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}"
  },
  {
    "function_name": "__tick_nohz_idle_stop_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "1041-1074",
    "snippet": "static void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "ts"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "928-931",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nohz_balance_enter_idle",
          "args": [
            "cpu"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "nohz_balance_enter_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "10545-10600",
          "snippet": "void nohz_balance_enter_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tSCHED_WARN_ON(cpu != smp_processor_id());\n\n\t/* If this CPU is going down, then nothing needs to be done: */\n\tif (!cpu_active(cpu))\n\t\treturn;\n\n\t/* Spare idle load balancing on CPUs that don't want to be disturbed: */\n\tif (!housekeeping_cpu(cpu, HK_FLAG_SCHED))\n\t\treturn;\n\n\t/*\n\t * Can be set safely without rq->lock held\n\t * If a clear happens, it will have evaluated last additions because\n\t * rq->lock is held during the check and the clear\n\t */\n\trq->has_blocked_load = 1;\n\n\t/*\n\t * The tick is still stopped but load could have been added in the\n\t * meantime. We set the nohz.has_blocked flag to trig a check of the\n\t * *_avg. The CPU is already part of nohz.idle_cpus_mask so the clear\n\t * of nohz.has_blocked can only happen after checking the new load\n\t */\n\tif (rq->nohz_tick_stopped)\n\t\tgoto out;\n\n\t/* If we're a completely isolated CPU, we don't play: */\n\tif (on_null_domain(rq))\n\t\treturn;\n\n\trq->nohz_tick_stopped = 1;\n\n\tcpumask_set_cpu(cpu, nohz.idle_cpus_mask);\n\tatomic_inc(&nohz.nr_cpus);\n\n\t/*\n\t * Ensures that if nohz_idle_balance() fails to observe our\n\t * @idle_cpus_mask store, it must observe the @has_blocked\n\t * and @needs_update stores.\n\t */\n\tsmp_mb__after_atomic();\n\n\tset_cpu_sd_state_idle(cpu);\n\n\tWRITE_ONCE(nohz.needs_update, 1);\nout:\n\t/*\n\t * Each time a cpu enter idle, we assume that it has blocked load and\n\t * enable the periodic update of the load of idle cpus\n\t */\n\tWRITE_ONCE(nohz.has_blocked, 1);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid nohz_balance_enter_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tSCHED_WARN_ON(cpu != smp_processor_id());\n\n\t/* If this CPU is going down, then nothing needs to be done: */\n\tif (!cpu_active(cpu))\n\t\treturn;\n\n\t/* Spare idle load balancing on CPUs that don't want to be disturbed: */\n\tif (!housekeeping_cpu(cpu, HK_FLAG_SCHED))\n\t\treturn;\n\n\t/*\n\t * Can be set safely without rq->lock held\n\t * If a clear happens, it will have evaluated last additions because\n\t * rq->lock is held during the check and the clear\n\t */\n\trq->has_blocked_load = 1;\n\n\t/*\n\t * The tick is still stopped but load could have been added in the\n\t * meantime. We set the nohz.has_blocked flag to trig a check of the\n\t * *_avg. The CPU is already part of nohz.idle_cpus_mask so the clear\n\t * of nohz.has_blocked can only happen after checking the new load\n\t */\n\tif (rq->nohz_tick_stopped)\n\t\tgoto out;\n\n\t/* If we're a completely isolated CPU, we don't play: */\n\tif (on_null_domain(rq))\n\t\treturn;\n\n\trq->nohz_tick_stopped = 1;\n\n\tcpumask_set_cpu(cpu, nohz.idle_cpus_mask);\n\tatomic_inc(&nohz.nr_cpus);\n\n\t/*\n\t * Ensures that if nohz_idle_balance() fails to observe our\n\t * @idle_cpus_mask store, it must observe the @has_blocked\n\t * and @needs_update stores.\n\t */\n\tsmp_mb__after_atomic();\n\n\tset_cpu_sd_state_idle(cpu);\n\n\tWRITE_ONCE(nohz.needs_update, 1);\nout:\n\t/*\n\t * Each time a cpu enter idle, we assume that it has blocked load and\n\t * enable the periodic update of the load of idle cpus\n\t */\n\tWRITE_ONCE(nohz.has_blocked, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "854-926",
          "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "769-852",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_idle_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_idle_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "987-1039",
          "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_idle_stop_tick(struct tick_sched *ts)\n{\n\tktime_t expires;\n\tint cpu = smp_processor_id();\n\n\t/*\n\t * If tick_nohz_get_sleep_length() ran tick_nohz_next_event(), the\n\t * tick timer expiration time is known already.\n\t */\n\tif (ts->timer_expires_base)\n\t\texpires = ts->timer_expires;\n\telse if (can_stop_idle_tick(cpu, ts))\n\t\texpires = tick_nohz_next_event(ts, cpu);\n\telse\n\t\treturn;\n\n\tts->idle_calls++;\n\n\tif (expires > 0LL) {\n\t\tint was_stopped = ts->tick_stopped;\n\n\t\ttick_nohz_stop_tick(ts, cpu);\n\n\t\tts->idle_sleeps++;\n\t\tts->idle_expires = expires;\n\n\t\tif (!was_stopped && ts->tick_stopped) {\n\t\t\tts->idle_jiffies = ts->last_jiffies;\n\t\t\tnohz_balance_enter_idle(cpu);\n\t\t}\n\t} else {\n\t\ttick_nohz_retain_tick(ts);\n\t}\n}"
  },
  {
    "function_name": "can_stop_idle_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "987-1039",
    "snippet": "static bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tick_do_timer_cpu == TICK_DO_TIMER_NONE"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\"",
            "(unsigned int) local_softirq_pending()"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_blocked",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "local_bh_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "153-156",
          "snippet": "bool local_bh_blocked(void)\n{\n\treturn __this_cpu_read(softirq_ctrl.cnt) != 0;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nbool local_bh_blocked(void)\n{\n\treturn __this_cpu_read(softirq_ctrl.cnt) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "local_softirq_pending()"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->nohz_mode == NOHZ_MODE_INACTIVE"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpu_online(cpu)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_idle_tick(int cpu, struct tick_sched *ts)\n{\n\t/*\n\t * If this CPU is offline and it is the one which updates\n\t * jiffies, then give up the assignment and let it be taken by\n\t * the CPU which runs the tick timer next. If we don't drop\n\t * this here the jiffies might be stale and do_timer() never\n\t * invoked.\n\t */\n\tif (unlikely(!cpu_online(cpu))) {\n\t\tif (cpu == tick_do_timer_cpu)\n\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t/*\n\t\t * Make sure the CPU doesn't get fooled by obsolete tick\n\t\t * deadline if it comes back online later.\n\t\t */\n\t\tts->next_tick = 0;\n\t\treturn false;\n\t}\n\n\tif (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))\n\t\treturn false;\n\n\tif (need_resched())\n\t\treturn false;\n\n\tif (unlikely(local_softirq_pending())) {\n\t\tstatic int ratelimit;\n\n\t\tif (ratelimit < 10 && !local_bh_blocked() &&\n\t\t    (local_softirq_pending() & SOFTIRQ_STOP_IDLE_MASK)) {\n\t\t\tpr_warn(\"NOHZ tick-stop error: Non-RCU local softirq work is pending, handler #%02x!!!\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t/*\n\t\t * Keep the tick alive to guarantee timekeeping progression\n\t\t * if there are full dynticks CPUs around\n\t\t */\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\n\t\t/* Should not happen for nohz-full */\n\t\tif (WARN_ON_ONCE(tick_do_timer_cpu == TICK_DO_TIMER_NONE))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "tick_nohz_full_update_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "976-985",
    "snippet": "static void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\t__tick_nohz_full_update_tick(ts, ktime_get());\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_nohz_full_update_tick",
          "args": [
            "ts",
            "ktime_get()"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_full_update_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "963-974",
          "snippet": "static void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_update_tick(struct tick_sched *ts)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tif (!ts->tick_stopped && ts->nohz_mode == NOHZ_MODE_INACTIVE)\n\t\treturn;\n\n\t__tick_nohz_full_update_tick(ts, ktime_get());\n}"
  },
  {
    "function_name": "__tick_nohz_full_update_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "963-974",
    "snippet": "static void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_restart_sched_tick",
          "args": [
            "ts",
            "now"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "943-961",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_sched_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_sched_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "934-940",
          "snippet": "static void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_stop_full_tick",
          "args": [
            "cpu",
            "ts"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "can_stop_full_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "270-290",
          "snippet": "static bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void __tick_nohz_full_update_tick(struct tick_sched *ts,\n\t\t\t\t\t ktime_t now)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tint cpu = smp_processor_id();\n\n\tif (can_stop_full_tick(cpu, ts))\n\t\ttick_nohz_stop_sched_tick(ts, cpu);\n\telse if (ts->tick_stopped)\n\t\ttick_nohz_restart_sched_tick(ts, now);\n#endif\n}"
  },
  {
    "function_name": "tick_nohz_restart_sched_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "943-961",
    "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_restart",
          "args": [
            "ts",
            "now"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_restart_sched_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "943-961",
          "snippet": "static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_load_nohz_stop",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "264-282",
          "snippet": "void calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long calc_load_update;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long calc_load_update;\n\nvoid calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * If we're still before the pending sample window, we're done.\n\t */\n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t/*\n\t * We woke inside or after the sample window, this means we're already\n\t * accounted through the nohz accounting, so skip the entire deal and\n\t * sync up for the next window.\n\t */\n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1692-1703",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "57-152",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)\n{\n\t/* Update jiffies first */\n\ttick_do_update_jiffies64(now);\n\n\t/*\n\t * Clear the timer idle flag, so we avoid IPIs on remote queueing and\n\t * the clock forward checks in the enqueue path:\n\t */\n\ttimer_clear_idle();\n\n\tcalc_load_nohz_stop();\n\ttouch_softlockup_watchdog_sched();\n\t/*\n\t * Cancel the scheduled timer and restore the tick\n\t */\n\tts->tick_stopped  = 0;\n\ttick_nohz_restart(ts, now);\n}"
  },
  {
    "function_name": "tick_nohz_stop_sched_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "934-940",
    "snippet": "static void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_retain_tick",
          "args": [
            "ts"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_retain_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "928-931",
          "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_stop_tick",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_stop_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "854-926",
          "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_next_event",
          "args": [
            "ts",
            "cpu"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "769-852",
          "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)\n{\n\tif (tick_nohz_next_event(ts, cpu))\n\t\ttick_nohz_stop_tick(ts, cpu);\n\telse\n\t\ttick_nohz_retain_tick(ts);\n}"
  },
  {
    "function_name": "tick_nohz_retain_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "928-931",
    "snippet": "static void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_retain_tick(struct tick_sched *ts)\n{\n\tts->timer_expires_base = 0;\n}"
  },
  {
    "function_name": "tick_nohz_stop_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "854-926",
    "snippet": "static void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "tick",
            "1"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "tick"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&ts->sched_timer",
            "tick",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "expires == KTIME_MAX"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "1",
            "TICK_DEP_MASK_NONE"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quiet_vmstat",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_nohz_start",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_nohz_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "246-253",
          "snippet": "void calc_load_nohz_start(void)\n{\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tcalc_load_nohz_fold(this_rq());\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid calc_load_nohz_start(void)\n{\n\t/*\n\t * We're going into NO_HZ mode, if there's any pending delta, fold it\n\t * into the pending NO_HZ delta.\n\t */\n\tcalc_load_nohz_fold(this_rq());\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\"",
            "basemono",
            "ts->next_tick",
            "dev->next_event",
            "hrtimer_active(&ts->sched_timer)",
            "hrtimer_get_expires(&ts->sched_timer)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1604-1621",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_tick(struct tick_sched *ts, int cpu)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\tu64 basemono = ts->timer_expires_base;\n\tu64 expires = ts->timer_expires;\n\tktime_t tick = expires;\n\n\t/* Make sure we won't be trying to stop it twice in a row. */\n\tts->timer_expires_base = 0;\n\n\t/*\n\t * If this CPU is the one which updates jiffies, then give up\n\t * the assignment and let it be taken by the CPU which runs\n\t * the tick timer next, which might be this CPU as well. If we\n\t * don't drop this here the jiffies might be stale and\n\t * do_timer() never invoked. Keep track of the fact that it\n\t * was the one which had the do_timer() duty last.\n\t */\n\tif (cpu == tick_do_timer_cpu) {\n\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\tts->do_timer_last = 1;\n\t} else if (tick_do_timer_cpu != TICK_DO_TIMER_NONE) {\n\t\tts->do_timer_last = 0;\n\t}\n\n\t/* Skip reprogram of event if its not changed */\n\tif (ts->tick_stopped && (expires == ts->next_tick)) {\n\t\t/* Sanity check: make sure clockevent is actually programmed */\n\t\tif (tick == KTIME_MAX || ts->next_tick == hrtimer_get_expires(&ts->sched_timer))\n\t\t\treturn;\n\n\t\tWARN_ON_ONCE(1);\n\t\tprintk_once(\"basemono: %llu ts->next_tick: %llu dev->next_event: %llu timer->active: %d timer->expires: %llu\\n\",\n\t\t\t    basemono, ts->next_tick, dev->next_event,\n\t\t\t    hrtimer_active(&ts->sched_timer), hrtimer_get_expires(&ts->sched_timer));\n\t}\n\n\t/*\n\t * nohz_stop_sched_tick can be called several times before\n\t * the nohz_restart_sched_tick is called. This happens when\n\t * interrupts arrive which do not cause a reschedule. In the\n\t * first call we save the current tick time, so we can restart\n\t * the scheduler tick in nohz_restart_sched_tick.\n\t */\n\tif (!ts->tick_stopped) {\n\t\tcalc_load_nohz_start();\n\t\tquiet_vmstat();\n\n\t\tts->last_tick = hrtimer_get_expires(&ts->sched_timer);\n\t\tts->tick_stopped = 1;\n\t\ttrace_tick_stop(1, TICK_DEP_MASK_NONE);\n\t}\n\n\tts->next_tick = tick;\n\n\t/*\n\t * If the expiration time == KTIME_MAX, then we simply stop\n\t * the tick timer.\n\t */\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES)\n\t\t\thrtimer_cancel(&ts->sched_timer);\n\t\treturn;\n\t}\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start(&ts->sched_timer, tick,\n\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\thrtimer_set_expires(&ts->sched_timer, tick);\n\t\ttick_program_event(tick, 1);\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "769-852",
    "snippet": "static ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "expires",
            "next_tick"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_max_deferment",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_max_deferment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1537-1551",
          "snippet": "u64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_clear_idle",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "timer_clear_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1692-1703",
          "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_timer_interrupt",
          "args": [
            "basejiff",
            "basemono"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_timer_interrupt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1636-1685",
          "snippet": "u64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tif (base->next_expiry_recalc)\n\t\tbase->next_expiry = __next_timer_interrupt(base);\n\tnextevt = base->next_expiry;\n\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (base->timers_pending)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC)\n\t\t\tbase->is_idle = true;\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible u64",
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nu64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tif (base->next_expiry_recalc)\n\t\tbase->next_expiry = __next_timer_interrupt(base);\n\tnextevt = base->next_expiry;\n\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (base->timers_pending)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC)\n\t\t\tbase->is_idle = true;\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_timer_softirq_pending",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "local_timer_softirq_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "764-767",
          "snippet": "static inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_needs_cpu",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_needs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "174-189",
          "snippet": "bool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_needs_cpu(void)\n{\n\tstruct llist_head *raised, *lazy;\n\n\traised = this_cpu_ptr(&raised_list);\n\tlazy = this_cpu_ptr(&lazy_list);\n\n\tif (llist_empty(raised) || arch_irq_work_has_interrupt())\n\t\tif (llist_empty(lazy))\n\t\t\treturn false;\n\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_needs_cpu",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_needs_cpu",
          "args": [
            "basemono",
            "&next_rcu"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_needs_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1089-1094",
          "snippet": "int rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn !rcu_segcblist_empty(&this_cpu_ptr(&rcu_data)->cblist) &&\n\t\t!rcu_rdp_is_offloaded(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nint rcu_needs_cpu(u64 basemono, u64 *nextevt)\n{\n\t*nextevt = KTIME_MAX;\n\treturn !rcu_segcblist_empty(&this_cpu_ptr(&rcu_data)->cblist) &&\n\t\t!rcu_rdp_is_offloaded(this_cpu_ptr(&rcu_data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&jiffies_seq",
            "seq"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_nohz_next_event(struct tick_sched *ts, int cpu)\n{\n\tu64 basemono, next_tick, next_tmr, next_rcu, delta, expires;\n\tunsigned long basejiff;\n\tunsigned int seq;\n\n\t/* Read jiffies and the time when jiffies were updated last */\n\tdo {\n\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\tbasemono = last_jiffies_update;\n\t\tbasejiff = jiffies;\n\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\tts->last_jiffies = basejiff;\n\tts->timer_expires_base = basemono;\n\n\t/*\n\t * Keep the periodic tick, when RCU, architecture or irq_work\n\t * requests it.\n\t * Aside of that check whether the local timer softirq is\n\t * pending. If so its a bad idea to call get_next_timer_interrupt()\n\t * because there is an already expired timer, so it will request\n\t * immediate expiry, which rearms the hardware timer with a\n\t * minimal delta which brings us back to this place\n\t * immediately. Lather, rinse and repeat...\n\t */\n\tif (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||\n\t    irq_work_needs_cpu() || local_timer_softirq_pending()) {\n\t\tnext_tick = basemono + TICK_NSEC;\n\t} else {\n\t\t/*\n\t\t * Get the next pending timer. If high resolution\n\t\t * timers are enabled this only takes the timer wheel\n\t\t * timers into account. If high resolution timers are\n\t\t * disabled this also looks at the next expiring\n\t\t * hrtimer.\n\t\t */\n\t\tnext_tmr = get_next_timer_interrupt(basejiff, basemono);\n\t\tts->next_timer = next_tmr;\n\t\t/* Take the next rcu event into account */\n\t\tnext_tick = next_rcu < next_tmr ? next_rcu : next_tmr;\n\t}\n\n\t/*\n\t * If the tick is due in the next period, keep it ticking or\n\t * force prod the timer.\n\t */\n\tdelta = next_tick - basemono;\n\tif (delta <= (u64)TICK_NSEC) {\n\t\t/*\n\t\t * Tell the timer code that the base is not idle, i.e. undo\n\t\t * the effect of get_next_timer_interrupt():\n\t\t */\n\t\ttimer_clear_idle();\n\t\t/*\n\t\t * We've not stopped the tick yet, and there's a timer in the\n\t\t * next period, so no point in stopping it either, bail.\n\t\t */\n\t\tif (!ts->tick_stopped) {\n\t\t\tts->timer_expires = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this CPU is the one which had the do_timer() duty last, we limit\n\t * the sleep time to the timekeeping max_deferment value.\n\t * Otherwise we can sleep as long as we want.\n\t */\n\tdelta = timekeeping_max_deferment();\n\tif (cpu != tick_do_timer_cpu &&\n\t    (tick_do_timer_cpu != TICK_DO_TIMER_NONE || !ts->do_timer_last))\n\t\tdelta = KTIME_MAX;\n\n\t/* Calculate the next expiry time */\n\tif (delta < (KTIME_MAX - basemono))\n\t\texpires = basemono + delta;\n\telse\n\t\texpires = KTIME_MAX;\n\n\tts->timer_expires = min_t(u64, expires, next_tick);\n\nout:\n\treturn ts->timer_expires;\n}"
  },
  {
    "function_name": "local_timer_softirq_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "764-767",
    "snippet": "static inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "TIMER_SOFTIRQ"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline bool local_timer_softirq_pending(void)\n{\n\treturn local_softirq_pending() & BIT(TIMER_SOFTIRQ);\n}"
  },
  {
    "function_name": "tick_nohz_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "742-762",
    "snippet": "static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start_expires(&ts->sched_timer,\n\t\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\t}\n\n\t/*\n\t * Reset to make sure next tick stop doesn't get fooled by past\n\t * cached clock deadline.\n\t */\n\tts->next_tick = 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "hrtimer_get_expires(&ts->sched_timer)",
            "1"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&ts->sched_timer",
            "HRTIMER_MODE_ABS_PINNED_HARD"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "&ts->sched_timer",
            "now",
            "TICK_NSEC"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&ts->sched_timer",
            "ts->last_tick"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ts->sched_timer"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_restart(struct tick_sched *ts, ktime_t now)\n{\n\thrtimer_cancel(&ts->sched_timer);\n\thrtimer_set_expires(&ts->sched_timer, ts->last_tick);\n\n\t/* Forward the time to expire in the future */\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\n\tif (ts->nohz_mode == NOHZ_MODE_HIGHRES) {\n\t\thrtimer_start_expires(&ts->sched_timer,\n\t\t\t\t      HRTIMER_MODE_ABS_PINNED_HARD);\n\t} else {\n\t\ttick_program_event(hrtimer_get_expires(&ts->sched_timer), 1);\n\t}\n\n\t/*\n\t * Reset to make sure next tick stop doesn't get fooled by past\n\t * cached clock deadline.\n\t */\n\tts->next_tick = 0;\n}"
  },
  {
    "function_name": "get_cpu_iowait_time_us",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "716-739",
    "snippet": "u64 get_cpu_iowait_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, iowait;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tiowait = ts->iowait_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && nr_iowait_cpu(cpu) > 0) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tiowait = ktime_add(ts->iowait_sleeptime, delta);\n\t\t} else {\n\t\t\tiowait = ts->iowait_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(iowait);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "iowait"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->iowait_sleeptime",
            "delta"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "cpu",
            "ts",
            "now",
            "last_update_time"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "627-644",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nu64 get_cpu_iowait_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, iowait;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tiowait = ts->iowait_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && nr_iowait_cpu(cpu) > 0) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tiowait = ktime_add(ts->iowait_sleeptime, delta);\n\t\t} else {\n\t\t\tiowait = ts->iowait_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(iowait);\n}"
  },
  {
    "function_name": "get_cpu_idle_time_us",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "675-699",
    "snippet": "u64 get_cpu_idle_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, idle;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tidle = ts->idle_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && !nr_iowait_cpu(cpu)) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tidle = ktime_add(ts->idle_sleeptime, delta);\n\t\t} else {\n\t\t\tidle = ts->idle_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(idle);\n\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "idle"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->idle_sleeptime",
            "delta"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "cpu",
            "ts",
            "now",
            "last_update_time"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "627-644",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nu64 get_cpu_idle_time_us(int cpu, u64 *last_update_time)\n{\n\tstruct tick_sched *ts = &per_cpu(tick_cpu_sched, cpu);\n\tktime_t now, idle;\n\n\tif (!tick_nohz_active)\n\t\treturn -1;\n\n\tnow = ktime_get();\n\tif (last_update_time) {\n\t\tupdate_ts_time_stats(cpu, ts, now, last_update_time);\n\t\tidle = ts->idle_sleeptime;\n\t} else {\n\t\tif (ts->idle_active && !nr_iowait_cpu(cpu)) {\n\t\t\tktime_t delta = ktime_sub(now, ts->idle_entrytime);\n\n\t\t\tidle = ktime_add(ts->idle_sleeptime, delta);\n\t\t} else {\n\t\t\tidle = ts->idle_sleeptime;\n\t\t}\n\t}\n\n\treturn ktime_to_us(idle);\n\n}"
  },
  {
    "function_name": "tick_nohz_start_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "654-659",
    "snippet": "static void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_idle_sleep_event",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_idle_sleep_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "426-429",
          "snippet": "void sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_start_idle(struct tick_sched *ts)\n{\n\tts->idle_entrytime = ktime_get();\n\tts->idle_active = 1;\n\tsched_clock_idle_sleep_event();\n}"
  },
  {
    "function_name": "tick_nohz_stop_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "646-652",
    "snippet": "static void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_idle_wakeup_event",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_idle_wakeup_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "435-448",
          "snippet": "void sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ts_time_stats",
          "args": [
            "smp_processor_id()",
            "ts",
            "now",
            "NULL"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "update_ts_time_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "627-644",
          "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_stop_idle(struct tick_sched *ts, ktime_t now)\n{\n\tupdate_ts_time_stats(smp_processor_id(), ts, now, NULL);\n\tts->idle_active = 0;\n\n\tsched_clock_idle_wakeup_event();\n}"
  },
  {
    "function_name": "update_ts_time_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "627-644",
    "snippet": "static void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_us",
          "args": [
            "now"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "ts->idle_sleeptime",
            "delta"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_iowait_cpu",
          "args": [
            "cpu"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "ts->idle_entrytime"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->idle_active) {\n\t\tdelta = ktime_sub(now, ts->idle_entrytime);\n\t\tif (nr_iowait_cpu(cpu) > 0)\n\t\t\tts->iowait_sleeptime = ktime_add(ts->iowait_sleeptime, delta);\n\t\telse\n\t\t\tts->idle_sleeptime = ktime_add(ts->idle_sleeptime, delta);\n\t\tts->idle_entrytime = now;\n\t}\n\n\tif (last_update_time)\n\t\t*last_update_time = ktime_to_us(now);\n\n}"
  },
  {
    "function_name": "tick_nohz_update_jiffies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "611-622",
    "snippet": "static void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "57-152",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "tick_cpu_sched.idle_waketime",
            "now"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog_sched();\n}"
  },
  {
    "function_name": "tick_nohz_tick_stopped_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "594-599",
    "snippet": "bool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}"
  },
  {
    "function_name": "tick_nohz_tick_stopped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "587-592",
    "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
  },
  {
    "function_name": "setup_tick_nohz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "580-583",
    "snippet": "static int __init setup_tick_nohz(char *str)\n{\n\treturn (kstrtobool(str, &tick_nohz_enabled) == 0);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&tick_nohz_enabled"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int __init setup_tick_nohz(char *str)\n{\n\treturn (kstrtobool(str, &tick_nohz_enabled) == 0);\n}"
  },
  {
    "function_name": "tick_nohz_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "526-565",
    "snippet": "void __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP_SMP) &&\n\t\t\t!IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU)) {\n\t\tcpu = smp_processor_id();\n\n\t\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range \"\n\t\t\t\t\"for timekeeping\\n\", cpu);\n\t\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\"",
            "cpumask_pr_args(tick_nohz_full_mask)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"kernel/nohz:predown\"",
            "NULL",
            "tick_nohz_cpu_down"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_cpu_set",
          "args": [
            "cpu"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_cpu_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "191-213",
          "snippet": "void __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_key);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n#ifdef CONFIG_HAVE_TIF_NOHZ\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n#endif\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_key);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n#ifdef CONFIG_HAVE_TIF_NOHZ\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n#endif\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NO_HZ: Clearing %d from nohz_full range \"\n\t\t\t\t\"for timekeeping\\n\"",
            "cpu"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_nohz_full_mask"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PM_SLEEP_SMP_NONZERO_CPU"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PM_SLEEP_SMP"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tick_nohz_full_mask"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_work_has_interrupt",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP_SMP) &&\n\t\t\t!IS_ENABLED(CONFIG_PM_SLEEP_SMP_NONZERO_CPU)) {\n\t\tcpu = smp_processor_id();\n\n\t\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range \"\n\t\t\t\t\"for timekeeping\\n\", cpu);\n\t\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}"
  },
  {
    "function_name": "tick_nohz_cpu_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "514-524",
    "snippet": "static int tick_nohz_cpu_down(unsigned int cpu)\n{\n\t/*\n\t * The tick_do_timer_cpu CPU handles housekeeping duty (unbound\n\t * timers, workqueues, timekeeping, ...) on behalf of full dynticks\n\t * CPUs. It must remain online when nohz full is enabled.\n\t */\n\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int tick_nohz_cpu_down(unsigned int cpu)\n{\n\t/*\n\t * The tick_do_timer_cpu CPU handles housekeeping duty (unbound\n\t * timers, workqueues, timekeeping, ...) on behalf of full dynticks\n\t * CPUs. It must remain online when nohz full is enabled.\n\t */\n\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_nohz_full_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "506-511",
    "snippet": "void __init tick_nohz_full_setup(cpumask_var_t cpumask)\n{\n\talloc_bootmem_cpumask_var(&tick_nohz_full_mask);\n\tcpumask_copy(tick_nohz_full_mask, cpumask);\n\ttick_nohz_full_running = true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tick_nohz_full_mask",
            "cpumask"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_bootmem_cpumask_var",
          "args": [
            "&tick_nohz_full_mask"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_full_setup(cpumask_var_t cpumask)\n{\n\talloc_bootmem_cpumask_var(&tick_nohz_full_mask);\n\tcpumask_copy(tick_nohz_full_mask, cpumask);\n\ttick_nohz_full_running = true;\n}"
  },
  {
    "function_name": "__tick_nohz_task_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "489-503",
    "snippet": "void __tick_nohz_task_switch(void)\n{\n\tstruct tick_sched *ts;\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_kick",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "370-381",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->signal->tick_dep_mask"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->tick_dep_mask"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_sched"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid __tick_nohz_task_switch(void)\n{\n\tstruct tick_sched *ts;\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "479-482",
    "snippet": "void tick_nohz_dep_clear_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &sig->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&sig->tick_dep_mask"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear_signal(struct signal_struct *sig, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &sig->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "463-477",
    "snippet": "void tick_nohz_dep_set_signal(struct task_struct *tsk,\n\t\t\t      enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct signal_struct *sig = tsk->signal;\n\n\tprev = atomic_fetch_or(BIT(bit), &sig->tick_dep_mask);\n\tif (!prev) {\n\t\tstruct task_struct *t;\n\n\t\tlockdep_assert_held(&tsk->sighand->siglock);\n\t\t__for_each_thread(sig, t)\n\t\t\ttick_nohz_kick_task(t);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_kick_task",
          "args": [
            "t"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_kick_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "326-364",
          "snippet": "static void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__for_each_thread",
          "args": [
            "sig",
            "t"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "&sig->tick_dep_mask"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set_signal(struct task_struct *tsk,\n\t\t\t      enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct signal_struct *sig = tsk->signal;\n\n\tprev = atomic_fetch_or(BIT(bit), &sig->tick_dep_mask);\n\tif (!prev) {\n\t\tstruct task_struct *t;\n\n\t\tlockdep_assert_held(&tsk->sighand->siglock);\n\t\t__for_each_thread(sig, t)\n\t\t\ttick_nohz_kick_task(t);\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "453-456",
    "snippet": "void tick_nohz_dep_clear_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tsk->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&tsk->tick_dep_mask"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tsk->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "446-450",
    "snippet": "void tick_nohz_dep_set_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tif (!atomic_fetch_or(BIT(bit), &tsk->tick_dep_mask))\n\t\ttick_nohz_kick_task(tsk);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_kick_task",
          "args": [
            "tsk"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_kick_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "326-364",
          "snippet": "static void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "&tsk->tick_dep_mask"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set_task(struct task_struct *tsk, enum tick_dep_bits bit)\n{\n\tif (!atomic_fetch_or(BIT(bit), &tsk->tick_dep_mask))\n\t\ttick_nohz_kick_task(tsk);\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "434-439",
    "snippet": "void tick_nohz_dep_clear_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tatomic_andnot(BIT(bit), &ts->tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&ts->tick_dep_mask"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_dep_clear_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tatomic_andnot(BIT(bit), &ts->tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "411-431",
    "snippet": "void tick_nohz_dep_set_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct tick_sched *ts;\n\n\tts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tprev = atomic_fetch_or(BIT(bit), &ts->tick_dep_mask);\n\tif (!prev) {\n\t\tpreempt_disable();\n\t\t/* Perf needs local kick that is NMI safe */\n\t\tif (cpu == smp_processor_id()) {\n\t\t\ttick_nohz_full_kick();\n\t\t} else {\n\t\t\t/* Remote irq work not NMI-safe */\n\t\t\tif (!WARN_ON_ONCE(in_nmi()))\n\t\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "318-324",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_nmi()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "370-381",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "&ts->tick_dep_mask"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&tick_cpu_sched",
            "cpu"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_dep_set_cpu(int cpu, enum tick_dep_bits bit)\n{\n\tint prev;\n\tstruct tick_sched *ts;\n\n\tts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\tprev = atomic_fetch_or(BIT(bit), &ts->tick_dep_mask);\n\tif (!prev) {\n\t\tpreempt_disable();\n\t\t/* Perf needs local kick that is NMI safe */\n\t\tif (cpu == smp_processor_id()) {\n\t\t\ttick_nohz_full_kick();\n\t\t} else {\n\t\t\t/* Remote irq work not NMI-safe */\n\t\t\tif (!WARN_ON_ONCE(in_nmi()))\n\t\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "tick_nohz_dep_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "402-405",
    "snippet": "void tick_nohz_dep_clear(enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tick_dep_mask);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "BIT(bit)",
            "&tick_dep_mask"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_clear(enum tick_dep_bits bit)\n{\n\tatomic_andnot(BIT(bit), &tick_dep_mask);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "397-400",
    "snippet": "void tick_nohz_dep_set(enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&tick_dep_mask, bit);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_dep_set_all",
          "args": [
            "&tick_dep_mask",
            "bit"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_dep_set_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "383-391",
          "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_dep_set(enum tick_dep_bits bit)\n{\n\ttick_nohz_dep_set_all(&tick_dep_mask, bit);\n}"
  },
  {
    "function_name": "tick_nohz_dep_set_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "383-391",
    "snippet": "static void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_all",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "370-381",
          "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_or",
          "args": [
            "BIT(bit)",
            "dep"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_dep_set_all(atomic_t *dep,\n\t\t\t\t  enum tick_dep_bits bit)\n{\n\tint prev;\n\n\tprev = atomic_fetch_or(BIT(bit), dep);\n\tif (!prev)\n\t\ttick_nohz_full_kick_all();\n}"
  },
  {
    "function_name": "tick_nohz_full_kick_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "370-381",
    "snippet": "static void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "318-324",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "cpu",
            "tick_nohz_full_mask",
            "cpu_online_mask"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick_all(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\tpreempt_disable();\n\tfor_each_cpu_and(cpu, tick_nohz_full_mask, cpu_online_mask)\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "tick_nohz_kick_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "326-364",
    "snippet": "static void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "318-324",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "tsk"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_task_on_rq",
          "args": [
            "tsk"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "sched_task_on_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "1975-1978",
          "snippet": "bool sched_task_on_rq(struct task_struct *p)\n{\n\treturn task_on_rq_queued(p);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nbool sched_task_on_rq(struct task_struct *p)\n{\n\treturn task_on_rq_queued(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_kick_task(struct task_struct *tsk)\n{\n\tint cpu;\n\n\t/*\n\t * If the task is not running, run_posix_cpu_timers()\n\t * has nothing to elapse, IPI can then be spared.\n\t *\n\t * activate_task()                      STORE p->tick_dep_mask\n\t *   STORE p->on_rq\n\t * __schedule() (switch to task 'p')    smp_mb() (atomic_fetch_or())\n\t *   LOCK rq->lock                      LOAD p->on_rq\n\t *   smp_mb__after_spin_lock()\n\t *   tick_nohz_task_switch()\n\t *     LOAD p->tick_dep_mask\n\t */\n\tif (!sched_task_on_rq(tsk))\n\t\treturn;\n\n\t/*\n\t * If the task concurrently migrates to another CPU,\n\t * we guarantee it sees the new tick dependency upon\n\t * schedule.\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()          STORE p->tick_dep_mask\n\t *   tick_nohz_task_switch()            smp_mb() (atomic_fetch_or())\n\t *      LOAD p->tick_dep_mask           LOAD p->cpu\n\t */\n\tcpu = task_cpu(tsk);\n\n\tpreempt_disable();\n\tif (cpu_online(cpu))\n\t\ttick_nohz_full_kick_cpu(cpu);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "tick_nohz_full_kick_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "318-324",
    "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue_on",
          "args": [
            "&per_cpu(nohz_full_kick_work, cpu)",
            "cpu"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "127-172",
          "snippet": "bool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n#ifndef CONFIG_SMP\n\treturn irq_work_queue(work);\n\n#else /* CONFIG_SMP: */\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tkasan_record_aux_stack(work);\n\n\tpreempt_disable();\n\tif (cpu != smp_processor_id()) {\n\t\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\t\tWARN_ON_ONCE(in_nmi());\n\n\t\t/*\n\t\t * On PREEMPT_RT the items which are not marked as\n\t\t * IRQ_WORK_HARD_IRQ are added to the lazy list and a HARD work\n\t\t * item is used on the remote CPU to wake the thread.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT) &&\n\t\t    !(atomic_read(&work->node.a_flags) & IRQ_WORK_HARD_IRQ)) {\n\n\t\t\tif (!llist_add(&work->node.llist, &per_cpu(lazy_list, cpu)))\n\t\t\t\tgoto out;\n\n\t\t\twork = &per_cpu(irq_work_wakeup, cpu);\n\t\t\tif (!irq_work_claim(work))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t__smp_call_single_queue(cpu, &work->node.llist);\n\t} else {\n\t\t__irq_work_queue_local(work);\n\t}\nout:\n\tpreempt_enable();\n\n\treturn true;\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "nohz_full_kick_work",
            "cpu"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
  },
  {
    "function_name": "tick_nohz_full_kick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "306-312",
    "snippet": "static void tick_nohz_full_kick(void)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tirq_work_queue(this_cpu_ptr(&nohz_full_kick_work));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "this_cpu_ptr(&nohz_full_kick_work)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&nohz_full_kick_work"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_nohz_full_kick(void)\n{\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\treturn;\n\n\tirq_work_queue(this_cpu_ptr(&nohz_full_kick_work));\n}"
  },
  {
    "function_name": "nohz_full_kick_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "292-295",
    "snippet": "static void nohz_full_kick_func(struct irq_work *work)\n{\n\t/* Empty, the tick restart happens on tick_nohz_irq_exit() */\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void nohz_full_kick_func(struct irq_work *work)\n{\n\t/* Empty, the tick restart happens on tick_nohz_irq_exit() */\n}"
  },
  {
    "function_name": "can_stop_full_tick",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "270-290",
    "snippet": "static bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_tick_dependency",
          "args": [
            "&current->signal->tick_dep_mask"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "check_tick_dependency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "238-268",
          "snippet": "static bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_RCU) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_RCU);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_RCU) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_RCU);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cpu_online(cpu)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool can_stop_full_tick(int cpu, struct tick_sched *ts)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tif (unlikely(!cpu_online(cpu)))\n\t\treturn false;\n\n\tif (check_tick_dependency(&tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&ts->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->tick_dep_mask))\n\t\treturn false;\n\n\tif (check_tick_dependency(&current->signal->tick_dep_mask))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "check_tick_dependency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "238-268",
    "snippet": "static bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_RCU) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_RCU);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_RCU"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_CLOCK_UNSTABLE"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_SCHED"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_PERF_EVENTS"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_tick_stop",
          "args": [
            "0",
            "TICK_DEP_MASK_POSIX_TIMER"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "dep"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool check_tick_dependency(atomic_t *dep)\n{\n\tint val = atomic_read(dep);\n\n\tif (val & TICK_DEP_MASK_POSIX_TIMER) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_POSIX_TIMER);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_PERF_EVENTS) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_PERF_EVENTS);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_SCHED) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_SCHED);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_CLOCK_UNSTABLE) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_CLOCK_UNSTABLE);\n\t\treturn true;\n\t}\n\n\tif (val & TICK_DEP_MASK_RCU) {\n\t\ttrace_tick_stop(0, TICK_DEP_MASK_RCU);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "tick_sched_handle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "203-228",
    "snippet": "static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_tick",
          "args": [
            "CPU_PROFILING"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "profile_tick",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "330-337",
          "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_process_times",
          "args": [
            "user_mode(regs)"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "update_process_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1776-1793",
          "snippet": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\tPRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\tPRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "irqentry_exit_to_user_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/common.c",
          "lines": "303-309",
          "snippet": "noinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}",
          "includes": [
            "#include <trace/events/syscalls.h>",
            "#include \"common.h\"",
            "#include <linux/tick.h>",
            "#include <linux/audit.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/resume_user_mode.h>",
            "#include <linux/entry-common.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/syscalls.h>\n#include \"common.h\"\n#include <linux/tick.h>\n#include <linux/audit.h>\n#include <linux/livepatch.h>\n#include <linux/highmem.h>\n#include <linux/resume_user_mode.h>\n#include <linux/entry-common.h>\n#include <linux/context_tracking.h>\n\n__visible noinstr;\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * When we are idle and the tick is stopped, we have to touch\n\t * the watchdog as we might not schedule for a really long\n\t * time. This happens on complete idle SMP systems while\n\t * waiting on the login prompt. We also increment the \"start of\n\t * idle\" jiffy stamp so the idle accounting adjustment we do\n\t * when we go busy again does not account too much ticks.\n\t */\n\tif (ts->tick_stopped) {\n\t\ttouch_softlockup_watchdog_sched();\n\t\tif (is_idle_task(current))\n\t\t\tts->idle_jiffies++;\n\t\t/*\n\t\t * In case the current tick fired too early past its expected\n\t\t * expiration, make sure we don't bypass the next clock reprogramming\n\t\t * to the same deadline.\n\t\t */\n\t\tts->next_tick = 0;\n\t}\n#endif\n\tupdate_process_times(user_mode(regs));\n\tprofile_tick(CPU_PROFILING);\n}"
  },
  {
    "function_name": "tick_sched_do_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "172-201",
    "snippet": "static void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_do_update_jiffies64",
          "args": [
            "now"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_update_jiffies64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "57-152",
          "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tick_nohz_full_running"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tick_do_timer_cpu == TICK_DO_TIMER_NONE"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_sched_do_timer(struct tick_sched *ts, ktime_t now)\n{\n\tint cpu = smp_processor_id();\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t/*\n\t * Check if the do_timer duty was dropped. We don't care about\n\t * concurrency: This happens only when the CPU in charge went\n\t * into a long sleep. If two CPUs happen to assign themselves to\n\t * this duty, then the jiffies update is still serialized by\n\t * jiffies_lock.\n\t *\n\t * If nohz_full is enabled, this should not happen because the\n\t * tick_do_timer_cpu never relinquishes.\n\t */\n\tif (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE)) {\n#ifdef CONFIG_NO_HZ_FULL\n\t\tWARN_ON(tick_nohz_full_running);\n#endif\n\t\ttick_do_timer_cpu = cpu;\n\t}\n#endif\n\n\t/* Check, if the jiffies need an update */\n\tif (tick_do_timer_cpu == cpu)\n\t\ttick_do_update_jiffies64(now);\n\n\tif (ts->inidle)\n\t\tts->got_idle_tick = 1;\n}"
  },
  {
    "function_name": "tick_init_jiffy_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "157-170",
    "snippet": "static ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&jiffies_seq"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic ktime_t tick_init_jiffy_update(void)\n{\n\tktime_t period;\n\n\traw_spin_lock(&jiffies_lock);\n\twrite_seqcount_begin(&jiffies_seq);\n\t/* Did we start the jiffies update yet ? */\n\tif (last_jiffies_update == 0)\n\t\tlast_jiffies_update = tick_next_period;\n\tperiod = last_jiffies_update;\n\twrite_seqcount_end(&jiffies_seq);\n\traw_spin_unlock(&jiffies_lock);\n\treturn period;\n}"
  },
  {
    "function_name": "tick_do_update_jiffies64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "57-152",
    "snippet": "static void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_wall_time",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "update_wall_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2208-2212",
          "snippet": "void update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_global_load",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "calc_global_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "350-380",
          "snippet": "void calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t calc_load_tasks;",
            "unsigned long calc_load_update;",
            "unsigned long avenrun[3];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\nunsigned long avenrun[3];\n\nvoid calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&jiffies_seq"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&tick_next_period",
            "nextp"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "last_jiffies_update",
            "TICK_NSEC"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "last_jiffies_update",
            "TICK_NSEC"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "last_jiffies_update",
            "incr * ticks"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "303-320",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= TICK_NSEC"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "tick_next_period"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "tick_next_period"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "nextp"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&jiffies_seq",
            "seq"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&jiffies_seq"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "smp_load_acquire(&tick_next_period)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&tick_next_period"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_do_update_jiffies64(ktime_t now)\n{\n\tunsigned long ticks = 1;\n\tktime_t delta, nextp;\n\n\t/*\n\t * 64bit can do a quick check without holding jiffies lock and\n\t * without looking at the sequence count. The smp_load_acquire()\n\t * pairs with the update done later in this function.\n\t *\n\t * 32bit cannot do that because the store of tick_next_period\n\t * consists of two 32bit stores and the first store could move it\n\t * to a random point in the future.\n\t */\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\tif (ktime_before(now, smp_load_acquire(&tick_next_period)))\n\t\t\treturn;\n\t} else {\n\t\tunsigned int seq;\n\n\t\t/*\n\t\t * Avoid contention on jiffies_lock and protect the quick\n\t\t * check with the sequence count.\n\t\t */\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnextp = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tif (ktime_before(now, nextp))\n\t\t\treturn;\n\t}\n\n\t/* Quick check failed, i.e. update is required. */\n\traw_spin_lock(&jiffies_lock);\n\t/*\n\t * Reevaluate with the lock held. Another CPU might have done the\n\t * update already.\n\t */\n\tif (ktime_before(now, tick_next_period)) {\n\t\traw_spin_unlock(&jiffies_lock);\n\t\treturn;\n\t}\n\n\twrite_seqcount_begin(&jiffies_seq);\n\n\tdelta = ktime_sub(now, tick_next_period);\n\tif (unlikely(delta >= TICK_NSEC)) {\n\t\t/* Slow path for long idle sleep times */\n\t\ts64 incr = TICK_NSEC;\n\n\t\tticks += ktime_divns(delta, incr);\n\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   incr * ticks);\n\t} else {\n\t\tlast_jiffies_update = ktime_add_ns(last_jiffies_update,\n\t\t\t\t\t\t   TICK_NSEC);\n\t}\n\n\t/* Advance jiffies to complete the jiffies_seq protected job */\n\tjiffies_64 += ticks;\n\n\t/*\n\t * Keep the tick_next_period variable up to date.\n\t */\n\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC);\n\n\tif (IS_ENABLED(CONFIG_64BIT)) {\n\t\t/*\n\t\t * Pairs with smp_load_acquire() in the lockless quick\n\t\t * check above and ensures that the update to jiffies_64 is\n\t\t * not reordered vs. the store to tick_next_period, neither\n\t\t * by the compiler nor by the CPU.\n\t\t */\n\t\tsmp_store_release(&tick_next_period, nextp);\n\t} else {\n\t\t/*\n\t\t * A plain store is good enough on 32bit as the quick check\n\t\t * above is protected by the sequence count.\n\t\t */\n\t\ttick_next_period = nextp;\n\t}\n\n\t/*\n\t * Release the sequence count. calc_global_load() below is not\n\t * protected by it, but jiffies_lock needs to be held to prevent\n\t * concurrent invocations.\n\t */\n\twrite_seqcount_end(&jiffies_seq);\n\n\tcalc_global_load();\n\n\traw_spin_unlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
  },
  {
    "function_name": "tick_get_tick_sched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
    "lines": "41-44",
    "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <linux/mm.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/module.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/profile.h>",
      "#include <linux/nmi.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_sched",
            "cpu"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
  }
]