[
  {
    "function_name": "unregister_stat_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "351-364",
    "snippet": "void unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_stat_sessions);",
      "static DEFINE_MUTEX(all_stat_sessions_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&all_stat_sessions_mutex"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_session",
          "args": [
            "node"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "67-73",
          "snippet": "static void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->session_list"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "node",
            "tmp",
            "&all_stat_sessions",
            "session_list"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&all_stat_sessions_mutex"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}"
  },
  {
    "function_name": "register_stat_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "308-349",
    "snippet": "int register_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *session, *node;\n\tint ret = -EINVAL;\n\n\tif (!trace)\n\t\treturn -EINVAL;\n\n\tif (!trace->stat_start || !trace->stat_next || !trace->stat_show)\n\t\treturn -EINVAL;\n\n\t/* Already registered? */\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry(node, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace)\n\t\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\t/* Init the session */\n\tsession = kzalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\tgoto out;\n\n\tsession->ts = trace;\n\tINIT_LIST_HEAD(&session->session_list);\n\tmutex_init(&session->stat_mutex);\n\n\tret = init_stat_file(session);\n\tif (ret) {\n\t\tdestroy_session(session);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t/* Register */\n\tlist_add_tail(&session->session_list, &all_stat_sessions);\n out:\n\tmutex_unlock(&all_stat_sessions_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(all_stat_sessions);",
      "static DEFINE_MUTEX(all_stat_sessions_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&all_stat_sessions_mutex"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&session->session_list",
            "&all_stat_sessions"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_session",
          "args": [
            "session"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "67-73",
          "snippet": "static void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_stat_file",
          "args": [
            "session"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "init_stat_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "293-306",
          "snippet": "static int init_stat_file(struct stat_session *session)\n{\n\tint ret;\n\n\tif (!stat_dir && (ret = tracing_stat_init()))\n\t\treturn ret;\n\n\tsession->file = tracefs_create_file(session->ts->name, TRACE_MODE_WRITE,\n\t\t\t\t\t    stat_dir, session,\n\t\t\t\t\t    &tracing_stat_fops);\n\tif (!session->file)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry\t\t*stat_dir;",
            "static const struct file_operations tracing_stat_fops = {\n\t.open\t\t= tracing_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_stat_release\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic struct dentry\t\t*stat_dir;\nstatic const struct file_operations tracing_stat_fops = {\n\t.open\t\t= tracing_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_stat_release\n};\n\nstatic int init_stat_file(struct stat_session *session)\n{\n\tint ret;\n\n\tif (!stat_dir && (ret = tracing_stat_init()))\n\t\treturn ret;\n\n\tsession->file = tracefs_create_file(session->ts->name, TRACE_MODE_WRITE,\n\t\t\t\t\t    stat_dir, session,\n\t\t\t\t\t    &tracing_stat_fops);\n\tif (!session->file)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&session->session_list"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*session)",
            "GFP_KERNEL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&all_stat_sessions",
            "session_list"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&all_stat_sessions_mutex"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\nint register_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *session, *node;\n\tint ret = -EINVAL;\n\n\tif (!trace)\n\t\treturn -EINVAL;\n\n\tif (!trace->stat_start || !trace->stat_next || !trace->stat_show)\n\t\treturn -EINVAL;\n\n\t/* Already registered? */\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry(node, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace)\n\t\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\t/* Init the session */\n\tsession = kzalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\tgoto out;\n\n\tsession->ts = trace;\n\tINIT_LIST_HEAD(&session->session_list);\n\tmutex_init(&session->stat_mutex);\n\n\tret = init_stat_file(session);\n\tif (ret) {\n\t\tdestroy_session(session);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t/* Register */\n\tlist_add_tail(&session->session_list, &all_stat_sessions);\n out:\n\tmutex_unlock(&all_stat_sessions_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_stat_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "293-306",
    "snippet": "static int init_stat_file(struct stat_session *session)\n{\n\tint ret;\n\n\tif (!stat_dir && (ret = tracing_stat_init()))\n\t\treturn ret;\n\n\tsession->file = tracefs_create_file(session->ts->name, TRACE_MODE_WRITE,\n\t\t\t\t\t    stat_dir, session,\n\t\t\t\t\t    &tracing_stat_fops);\n\tif (!session->file)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry\t\t*stat_dir;",
      "static const struct file_operations tracing_stat_fops = {\n\t.open\t\t= tracing_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_stat_release\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "session->ts->name",
            "TRACE_MODE_WRITE",
            "stat_dir",
            "session",
            "&tracing_stat_fops"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_stat_init",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stat_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "277-291",
          "snippet": "static int tracing_stat_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tstat_dir = tracefs_create_dir(\"trace_stat\", NULL);\n\tif (!stat_dir) {\n\t\tpr_warn(\"Could not create tracefs 'trace_stat' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry\t\t*stat_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic struct dentry\t\t*stat_dir;\n\nstatic int tracing_stat_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tstat_dir = tracefs_create_dir(\"trace_stat\", NULL);\n\tif (!stat_dir) {\n\t\tpr_warn(\"Could not create tracefs 'trace_stat' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic struct dentry\t\t*stat_dir;\nstatic const struct file_operations tracing_stat_fops = {\n\t.open\t\t= tracing_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_stat_release\n};\n\nstatic int init_stat_file(struct stat_session *session)\n{\n\tint ret;\n\n\tif (!stat_dir && (ret = tracing_stat_init()))\n\t\treturn ret;\n\n\tsession->file = tracefs_create_file(session->ts->name, TRACE_MODE_WRITE,\n\t\t\t\t\t    stat_dir, session,\n\t\t\t\t\t    &tracing_stat_fops);\n\tif (!session->file)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_stat_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "277-291",
    "snippet": "static int tracing_stat_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tstat_dir = tracefs_create_dir(\"trace_stat\", NULL);\n\tif (!stat_dir) {\n\t\tpr_warn(\"Could not create tracefs 'trace_stat' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry\t\t*stat_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'trace_stat' entry\\n\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "\"trace_stat\"",
            "NULL"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic struct dentry\t\t*stat_dir;\n\nstatic int tracing_stat_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tstat_dir = tracefs_create_dir(\"trace_stat\", NULL);\n\tif (!stat_dir) {\n\t\tpr_warn(\"Could not create tracefs 'trace_stat' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tracing_stat_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "261-268",
    "snippet": "static int tracing_stat_release(struct inode *i, struct file *f)\n{\n\tstruct stat_session *session = i->i_private;\n\n\treset_stat_session(session);\n\n\treturn seq_release(i, f);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "i",
            "f"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_stat_session",
          "args": [
            "session"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "reset_stat_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "60-65",
          "snippet": "static void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int tracing_stat_release(struct inode *i, struct file *f)\n{\n\tstruct stat_session *session = i->i_private;\n\n\treset_stat_session(session);\n\n\treturn seq_release(i, f);\n}"
  },
  {
    "function_name": "tracing_stat_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "233-256",
    "snippet": "static int tracing_stat_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_file *m;\n\tstruct stat_session *session = inode->i_private;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stat_seq_init(session);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, &trace_stat_seq_ops);\n\tif (ret) {\n\t\treset_stat_session(session);\n\t\treturn ret;\n\t}\n\n\tm = file->private_data;\n\tm->private = session;\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations trace_stat_seq_ops = {\n\t.start\t\t= stat_seq_start,\n\t.next\t\t= stat_seq_next,\n\t.stop\t\t= stat_seq_stop,\n\t.show\t\t= stat_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_stat_session",
          "args": [
            "session"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "reset_stat_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "60-65",
          "snippet": "static void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&trace_stat_seq_ops"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_seq_init",
          "args": [
            "session"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "stat_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "123-168",
          "snippet": "static int stat_seq_init(struct stat_session *session)\n{\n\tstruct tracer_stat *ts = session->ts;\n\tstruct rb_root *root = &session->stat_root;\n\tvoid *stat;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\n\tif (!ts->stat_cmp)\n\t\tts->stat_cmp = dummy_cmp;\n\n\tstat = ts->stat_start(ts);\n\tif (!stat)\n\t\tgoto exit;\n\n\tret = insert_stat(root, stat, ts->stat_cmp);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Iterate over the tracer stat entries and store them in an rbtree.\n\t */\n\tfor (i = 1; ; i++) {\n\t\tstat = ts->stat_next(stat, i);\n\n\t\t/* End of insertion */\n\t\tif (!stat)\n\t\t\tbreak;\n\n\t\tret = insert_stat(root, stat, ts->stat_cmp);\n\t\tif (ret)\n\t\t\tgoto exit_free_rbtree;\n\t}\n\nexit:\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n\nexit_free_rbtree:\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int stat_seq_init(struct stat_session *session)\n{\n\tstruct tracer_stat *ts = session->ts;\n\tstruct rb_root *root = &session->stat_root;\n\tvoid *stat;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\n\tif (!ts->stat_cmp)\n\t\tts->stat_cmp = dummy_cmp;\n\n\tstat = ts->stat_start(ts);\n\tif (!stat)\n\t\tgoto exit;\n\n\tret = insert_stat(root, stat, ts->stat_cmp);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Iterate over the tracer stat entries and store them in an rbtree.\n\t */\n\tfor (i = 1; ; i++) {\n\t\tstat = ts->stat_next(stat, i);\n\n\t\t/* End of insertion */\n\t\tif (!stat)\n\t\t\tbreak;\n\n\t\tret = insert_stat(root, stat, ts->stat_cmp);\n\t\tif (ret)\n\t\t\tgoto exit_free_rbtree;\n\t}\n\nexit:\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n\nexit_free_rbtree:\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic const struct seq_operations trace_stat_seq_ops = {\n\t.start\t\t= stat_seq_start,\n\t.next\t\t= stat_seq_next,\n\t.stop\t\t= stat_seq_stop,\n\t.show\t\t= stat_seq_show\n};\n\nstatic int tracing_stat_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_file *m;\n\tstruct stat_session *session = inode->i_private;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stat_seq_init(session);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, &trace_stat_seq_ops);\n\tif (ret) {\n\t\treset_stat_session(session);\n\t\treturn ret;\n\t}\n\n\tm = file->private_data;\n\tm->private = session;\n\treturn ret;\n}"
  },
  {
    "function_name": "stat_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "214-223",
    "snippet": "static int stat_seq_show(struct seq_file *s, void *v)\n{\n\tstruct stat_session *session = s->private;\n\tstruct stat_node *l = container_of(v, struct stat_node, node);\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn session->ts->stat_headers(s);\n\n\treturn session->ts->stat_show(s, l->stat);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "session->ts->stat_show",
          "args": [
            "s",
            "l->stat"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "session->ts->stat_headers",
          "args": [
            "s"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "v",
            "structstat_node",
            "node"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int stat_seq_show(struct seq_file *s, void *v)\n{\n\tstruct stat_session *session = s->private;\n\tstruct stat_node *l = container_of(v, struct stat_node, node);\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn session->ts->stat_headers(s);\n\n\treturn session->ts->stat_show(s, l->stat);\n}"
  },
  {
    "function_name": "stat_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "208-212",
    "snippet": "static void stat_seq_stop(struct seq_file *s, void *p)\n{\n\tstruct stat_session *session = s->private;\n\tmutex_unlock(&session->stat_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void stat_seq_stop(struct seq_file *s, void *p)\n{\n\tstruct stat_session *session = s->private;\n\tmutex_unlock(&session->stat_mutex);\n}"
  },
  {
    "function_name": "stat_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "195-206",
    "snippet": "static void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node = p;\n\n\t(*pos)++;\n\n\tif (p == SEQ_START_TOKEN)\n\t\treturn rb_first(&session->stat_root);\n\n\treturn rb_next(node);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&session->stat_root"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "prb_first_valid_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "1981-1989",
          "snippet": "u64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node = p;\n\n\t(*pos)++;\n\n\tif (p == SEQ_START_TOKEN)\n\t\treturn rb_first(&session->stat_root);\n\n\treturn rb_next(node);\n}"
  },
  {
    "function_name": "stat_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "171-193",
    "snippet": "static void *stat_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node;\n\tint n = *pos;\n\tint i;\n\n\t/* Prevent from tracer switch or rbtree modification */\n\tmutex_lock(&session->stat_mutex);\n\n\t/* If we are in the beginning of the file, print the headers */\n\tif (session->ts->stat_headers) {\n\t\tif (n == 0)\n\t\t\treturn SEQ_START_TOKEN;\n\t\tn--;\n\t}\n\n\tnode = rb_first(&session->stat_root);\n\tfor (i = 0; node && i < n; i++)\n\t\tnode = rb_next(node);\n\n\treturn node;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&session->stat_root"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "prb_first_valid_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "1981-1989",
          "snippet": "u64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void *stat_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node;\n\tint n = *pos;\n\tint i;\n\n\t/* Prevent from tracer switch or rbtree modification */\n\tmutex_lock(&session->stat_mutex);\n\n\t/* If we are in the beginning of the file, print the headers */\n\tif (session->ts->stat_headers) {\n\t\tif (n == 0)\n\t\t\treturn SEQ_START_TOKEN;\n\t\tn--;\n\t}\n\n\tnode = rb_first(&session->stat_root);\n\tfor (i = 0; node && i < n; i++)\n\t\tnode = rb_next(node);\n\n\treturn node;\n}"
  },
  {
    "function_name": "stat_seq_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "123-168",
    "snippet": "static int stat_seq_init(struct stat_session *session)\n{\n\tstruct tracer_stat *ts = session->ts;\n\tstruct rb_root *root = &session->stat_root;\n\tvoid *stat;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\n\tif (!ts->stat_cmp)\n\t\tts->stat_cmp = dummy_cmp;\n\n\tstat = ts->stat_start(ts);\n\tif (!stat)\n\t\tgoto exit;\n\n\tret = insert_stat(root, stat, ts->stat_cmp);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Iterate over the tracer stat entries and store them in an rbtree.\n\t */\n\tfor (i = 1; ; i++) {\n\t\tstat = ts->stat_next(stat, i);\n\n\t\t/* End of insertion */\n\t\tif (!stat)\n\t\t\tbreak;\n\n\t\tret = insert_stat(root, stat, ts->stat_cmp);\n\t\tif (ret)\n\t\t\tgoto exit_free_rbtree;\n\t}\n\nexit:\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n\nexit_free_rbtree:\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reset_stat_session",
          "args": [
            "session"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_stat_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "47-58",
          "snippet": "static void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_stat",
          "args": [
            "root",
            "stat",
            "ts->stat_cmp"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "insert_stat",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "75-106",
          "snippet": "static int insert_stat(struct rb_root *root, void *stat, cmp_func_t cmp)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct stat_node *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->stat = stat;\n\n\t/*\n\t * Figure out where to put new node\n\t * This is a descendent sorting\n\t */\n\twhile (*new) {\n\t\tstruct stat_node *this;\n\t\tint result;\n\n\t\tthis = container_of(*new, struct stat_node, node);\n\t\tresult = cmp(data->stat, this->stat);\n\n\t\tparent = *new;\n\t\tif (result >= 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int insert_stat(struct rb_root *root, void *stat, cmp_func_t cmp)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct stat_node *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->stat = stat;\n\n\t/*\n\t * Figure out where to put new node\n\t * This is a descendent sorting\n\t */\n\twhile (*new) {\n\t\tstruct stat_node *this;\n\t\tint result;\n\n\t\tthis = container_of(*new, struct stat_node, node);\n\t\tresult = cmp(data->stat, this->stat);\n\n\t\tparent = *new;\n\t\tif (result >= 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ts->stat_next",
          "args": [
            "stat",
            "i"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts->stat_start",
          "args": [
            "ts"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int stat_seq_init(struct stat_session *session)\n{\n\tstruct tracer_stat *ts = session->ts;\n\tstruct rb_root *root = &session->stat_root;\n\tvoid *stat;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\n\tif (!ts->stat_cmp)\n\t\tts->stat_cmp = dummy_cmp;\n\n\tstat = ts->stat_start(ts);\n\tif (!stat)\n\t\tgoto exit;\n\n\tret = insert_stat(root, stat, ts->stat_cmp);\n\tif (ret)\n\t\tgoto exit;\n\n\t/*\n\t * Iterate over the tracer stat entries and store them in an rbtree.\n\t */\n\tfor (i = 1; ; i++) {\n\t\tstat = ts->stat_next(stat, i);\n\n\t\t/* End of insertion */\n\t\tif (!stat)\n\t\t\tbreak;\n\n\t\tret = insert_stat(root, stat, ts->stat_cmp);\n\t\tif (ret)\n\t\t\tgoto exit_free_rbtree;\n\t}\n\nexit:\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n\nexit_free_rbtree:\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "dummy_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "113-116",
    "snippet": "static int dummy_cmp(const void *p1, const void *p2)\n{\n\treturn -1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int dummy_cmp(const void *p1, const void *p2)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "insert_stat",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "75-106",
    "snippet": "static int insert_stat(struct rb_root *root, void *stat, cmp_func_t cmp)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct stat_node *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->stat = stat;\n\n\t/*\n\t * Figure out where to put new node\n\t * This is a descendent sorting\n\t */\n\twhile (*new) {\n\t\tstruct stat_node *this;\n\t\tint result;\n\n\t\tthis = container_of(*new, struct stat_node, node);\n\t\tresult = cmp(data->stat, this->stat);\n\n\t\tparent = *new;\n\t\tif (result >= 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&data->node",
            "root"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&data->node",
            "parent",
            "new"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmp",
          "args": [
            "data->stat",
            "this->stat"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_cmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "113-116",
          "snippet": "static int dummy_cmp(const void *p1, const void *p2)\n{\n\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int dummy_cmp(const void *p1, const void *p2)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "*new",
            "structstat_node",
            "node"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic int insert_stat(struct rb_root *root, void *stat, cmp_func_t cmp)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct stat_node *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->stat = stat;\n\n\t/*\n\t * Figure out where to put new node\n\t * This is a descendent sorting\n\t */\n\twhile (*new) {\n\t\tstruct stat_node *this;\n\t\tint result;\n\n\t\tthis = container_of(*new, struct stat_node, node);\n\t\tresult = cmp(data->stat, this->stat);\n\n\t\tparent = *new;\n\t\tif (result >= 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_session",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "67-73",
    "snippet": "static void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "session"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex-debug.c",
          "lines": "100-104",
          "snippet": "void mutex_destroy(struct mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\n\tlock->magic = NULL;\n}",
          "includes": [
            "#include \"mutex.h\"",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mutex.h\"\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\nvoid mutex_destroy(struct mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\n\tlock->magic = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reset_stat_session",
          "args": [
            "session"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_stat_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "47-58",
          "snippet": "static void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "session->file"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}"
  },
  {
    "function_name": "reset_stat_session",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "60-65",
    "snippet": "static void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reset_stat_session",
          "args": [
            "session"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_stat_session",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
          "lines": "47-58",
          "snippet": "static void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_stat.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->stat_mutex"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}"
  },
  {
    "function_name": "__reset_stat_session",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stat.c",
    "lines": "47-58",
    "snippet": "static void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"trace_stat.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "snode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "session->ts->stat_release",
          "args": [
            "snode->stat"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbtree_postorder_for_each_entry_safe",
          "args": [
            "snode",
            "n",
            "&session->stat_root",
            "node"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"trace_stat.h\"\n#include <linux/tracefs.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/security.h>\n\nstatic void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}"
  }
]