[
  {
    "function_name": "audit_killed_trees",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2991-2997",
    "snippet": "struct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || ctx->context == AUDIT_CTX_UNUSED))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ctx || ctx->context == AUDIT_CTX_UNUSED"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || ctx->context == AUDIT_CTX_UNUSED))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}"
  },
  {
    "function_name": "audit_seccomp_actions_logged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2972-2989",
    "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"op=seccomp-logging actions=%s old-actions=%s res=%d\"",
            "names",
            "old_names",
            "res"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2958-2970",
    "snippet": "void audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(current), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\"",
            "signr",
            "syscall_get_arch(current)",
            "syscall",
            "in_compat_syscall()",
            "KSTK_EIP(current)",
            "code"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "current"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [
            "current"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task",
          "args": [
            "ab"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2899-2919",
          "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_SECCOMP"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(current), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_core_dumps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2928-2944",
    "snippet": "void audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" sig=%ld res=1\"",
            "signr"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task",
          "args": [
            "ab"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2899-2919",
          "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_ANOM_ABEND"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2899-2919",
    "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_d_path_exe",
          "args": [
            "ab",
            "current->mm"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path_exe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2171-2188",
          "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, current)"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" pid=%d comm=\"",
            "task_tgid_nr(current)"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid_gid",
          "args": [
            "&uid",
            "&gid"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
  },
  {
    "function_name": "__audit_log_nfcfg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2879-2896",
    "snippet": "void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t       enum audit_nfcfgop op, gfp_t gfp)\n{\n\tstruct audit_buffer *ab;\n\tchar comm[sizeof(current->comm)];\n\n\tab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"table=%s family=%u entries=%u op=%s\",\n\t\t\t name, af, nentries, audit_nfcfgs[op].s);\n\n\taudit_log_format(ab, \" pid=%u\", task_pid_nr(current));\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct audit_nfcfgop_tab audit_nfcfgs[] = {\n\t{ AUDIT_XT_OP_REGISTER,\t\t\t\"xt_register\"\t\t   },\n\t{ AUDIT_XT_OP_REPLACE,\t\t\t\"xt_replace\"\t\t   },\n\t{ AUDIT_XT_OP_UNREGISTER,\t\t\"xt_unregister\"\t\t   },\n\t{ AUDIT_NFT_OP_TABLE_REGISTER,\t\t\"nft_register_table\"\t   },\n\t{ AUDIT_NFT_OP_TABLE_UNREGISTER,\t\"nft_unregister_table\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_REGISTER,\t\t\"nft_register_chain\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_UNREGISTER,\t\"nft_unregister_chain\"\t   },\n\t{ AUDIT_NFT_OP_RULE_REGISTER,\t\t\"nft_register_rule\"\t   },\n\t{ AUDIT_NFT_OP_RULE_UNREGISTER,\t\t\"nft_unregister_rule\"\t   },\n\t{ AUDIT_NFT_OP_SET_REGISTER,\t\t\"nft_register_set\"\t   },\n\t{ AUDIT_NFT_OP_SET_UNREGISTER,\t\t\"nft_unregister_set\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_REGISTER,\t\"nft_register_setelem\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_UNREGISTER,\t\"nft_unregister_setelem\"   },\n\t{ AUDIT_NFT_OP_GEN_REGISTER,\t\t\"nft_register_gen\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_REGISTER,\t\t\"nft_register_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_UNREGISTER,\t\t\"nft_unregister_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_RESET,\t\t\"nft_reset_obj\"\t\t   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_REGISTER,\t\"nft_register_flowtable\"   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\t\"nft_unregister_flowtable\" },\n\t{ AUDIT_NFT_OP_INVALID,\t\t\t\"nft_invalid\"\t\t   },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, current)"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" comm=\""
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "gfp",
            "AUDIT_NETFILTER_CFG"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic const struct audit_nfcfgop_tab audit_nfcfgs[] = {\n\t{ AUDIT_XT_OP_REGISTER,\t\t\t\"xt_register\"\t\t   },\n\t{ AUDIT_XT_OP_REPLACE,\t\t\t\"xt_replace\"\t\t   },\n\t{ AUDIT_XT_OP_UNREGISTER,\t\t\"xt_unregister\"\t\t   },\n\t{ AUDIT_NFT_OP_TABLE_REGISTER,\t\t\"nft_register_table\"\t   },\n\t{ AUDIT_NFT_OP_TABLE_UNREGISTER,\t\"nft_unregister_table\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_REGISTER,\t\t\"nft_register_chain\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_UNREGISTER,\t\"nft_unregister_chain\"\t   },\n\t{ AUDIT_NFT_OP_RULE_REGISTER,\t\t\"nft_register_rule\"\t   },\n\t{ AUDIT_NFT_OP_RULE_UNREGISTER,\t\t\"nft_unregister_rule\"\t   },\n\t{ AUDIT_NFT_OP_SET_REGISTER,\t\t\"nft_register_set\"\t   },\n\t{ AUDIT_NFT_OP_SET_UNREGISTER,\t\t\"nft_unregister_set\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_REGISTER,\t\"nft_register_setelem\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_UNREGISTER,\t\"nft_unregister_setelem\"   },\n\t{ AUDIT_NFT_OP_GEN_REGISTER,\t\t\"nft_register_gen\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_REGISTER,\t\t\"nft_register_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_UNREGISTER,\t\t\"nft_unregister_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_RESET,\t\t\"nft_reset_obj\"\t\t   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_REGISTER,\t\"nft_register_flowtable\"   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\t\"nft_unregister_flowtable\" },\n\t{ AUDIT_NFT_OP_INVALID,\t\t\t\"nft_invalid\"\t\t   },\n};\n\nvoid __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t       enum audit_nfcfgop op, gfp_t gfp)\n{\n\tstruct audit_buffer *ab;\n\tchar comm[sizeof(current->comm)];\n\n\tab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"table=%s family=%u entries=%u op=%s\",\n\t\t\t name, af, nentries, audit_nfcfgs[op].s);\n\n\taudit_log_format(ab, \" pid=%u\", task_pid_nr(current));\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "__audit_ntp_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2869-2877",
    "snippet": "void __audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\taudit_log_ntp_val(ad, \"offset\",\tAUDIT_NTP_OFFSET);\n\taudit_log_ntp_val(ad, \"freq\",\tAUDIT_NTP_FREQ);\n\taudit_log_ntp_val(ad, \"status\",\tAUDIT_NTP_STATUS);\n\taudit_log_ntp_val(ad, \"tai\",\tAUDIT_NTP_TAI);\n\taudit_log_ntp_val(ad, \"tick\",\tAUDIT_NTP_TICK);\n\taudit_log_ntp_val(ad, \"adjust\",\tAUDIT_NTP_ADJUST);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_ntp_val",
          "args": [
            "ad",
            "\"adjust\"",
            "AUDIT_NTP_ADJUST"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_ntp_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2857-2867",
          "snippet": "static void audit_log_ntp_val(const struct audit_ntp_data *ad,\n\t\t\t      const char *op, enum audit_ntp_type type)\n{\n\tconst struct audit_ntp_val *val = &ad->vals[type];\n\n\tif (val->newval == val->oldval)\n\t\treturn;\n\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_ADJNTPVAL,\n\t\t  \"op=%s old=%lli new=%lli\", op, val->oldval, val->newval);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_ntp_val(const struct audit_ntp_data *ad,\n\t\t\t      const char *op, enum audit_ntp_type type)\n{\n\tconst struct audit_ntp_val *val = &ad->vals[type];\n\n\tif (val->newval == val->oldval)\n\t\treturn;\n\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_ADJNTPVAL,\n\t\t  \"op=%s old=%lli new=%lli\", op, val->oldval, val->newval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\taudit_log_ntp_val(ad, \"offset\",\tAUDIT_NTP_OFFSET);\n\taudit_log_ntp_val(ad, \"freq\",\tAUDIT_NTP_FREQ);\n\taudit_log_ntp_val(ad, \"status\",\tAUDIT_NTP_STATUS);\n\taudit_log_ntp_val(ad, \"tai\",\tAUDIT_NTP_TAI);\n\taudit_log_ntp_val(ad, \"tick\",\tAUDIT_NTP_TICK);\n\taudit_log_ntp_val(ad, \"adjust\",\tAUDIT_NTP_ADJUST);\n}"
  },
  {
    "function_name": "audit_log_ntp_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2857-2867",
    "snippet": "static void audit_log_ntp_val(const struct audit_ntp_data *ad,\n\t\t\t      const char *op, enum audit_ntp_type type)\n{\n\tconst struct audit_ntp_val *val = &ad->vals[type];\n\n\tif (val->newval == val->oldval)\n\t\treturn;\n\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_ADJNTPVAL,\n\t\t  \"op=%s old=%lli new=%lli\", op, val->oldval, val->newval);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_TIME_ADJNTPVAL",
            "\"op=%s old=%lli new=%lli\"",
            "op",
            "val->oldval",
            "val->newval"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_pid_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1110-1140",
          "snippet": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_ntp_val(const struct audit_ntp_data *ad,\n\t\t\t      const char *op, enum audit_ntp_type type)\n{\n\tconst struct audit_ntp_val *val = &ad->vals[type];\n\n\tif (val->newval == val->oldval)\n\t\treturn;\n\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_ADJNTPVAL,\n\t\t  \"op=%s old=%lli new=%lli\", op, val->oldval, val->newval);\n}"
  },
  {
    "function_name": "__audit_tk_injoffset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2850-2855",
    "snippet": "void __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_TIME_INJOFFSET",
            "\"sec=%lli nsec=%li\"",
            "(long long)offset.tv_sec",
            "offset.tv_nsec"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}"
  },
  {
    "function_name": "__audit_fanotify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2844-2848",
    "snippet": "void __audit_fanotify(unsigned int response)\n{\n\taudit_log(audit_context(), GFP_KERNEL,\n\t\tAUDIT_FANOTIFY,\t\"resp=%u\", response);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_FANOTIFY",
            "\"resp=%u\"",
            "response"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_log_nfcfg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2879-2896",
          "snippet": "void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t       enum audit_nfcfgop op, gfp_t gfp)\n{\n\tstruct audit_buffer *ab;\n\tchar comm[sizeof(current->comm)];\n\n\tab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"table=%s family=%u entries=%u op=%s\",\n\t\t\t name, af, nentries, audit_nfcfgs[op].s);\n\n\taudit_log_format(ab, \" pid=%u\", task_pid_nr(current));\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct audit_nfcfgop_tab audit_nfcfgs[] = {\n\t{ AUDIT_XT_OP_REGISTER,\t\t\t\"xt_register\"\t\t   },\n\t{ AUDIT_XT_OP_REPLACE,\t\t\t\"xt_replace\"\t\t   },\n\t{ AUDIT_XT_OP_UNREGISTER,\t\t\"xt_unregister\"\t\t   },\n\t{ AUDIT_NFT_OP_TABLE_REGISTER,\t\t\"nft_register_table\"\t   },\n\t{ AUDIT_NFT_OP_TABLE_UNREGISTER,\t\"nft_unregister_table\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_REGISTER,\t\t\"nft_register_chain\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_UNREGISTER,\t\"nft_unregister_chain\"\t   },\n\t{ AUDIT_NFT_OP_RULE_REGISTER,\t\t\"nft_register_rule\"\t   },\n\t{ AUDIT_NFT_OP_RULE_UNREGISTER,\t\t\"nft_unregister_rule\"\t   },\n\t{ AUDIT_NFT_OP_SET_REGISTER,\t\t\"nft_register_set\"\t   },\n\t{ AUDIT_NFT_OP_SET_UNREGISTER,\t\t\"nft_unregister_set\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_REGISTER,\t\"nft_register_setelem\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_UNREGISTER,\t\"nft_unregister_setelem\"   },\n\t{ AUDIT_NFT_OP_GEN_REGISTER,\t\t\"nft_register_gen\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_REGISTER,\t\t\"nft_register_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_UNREGISTER,\t\t\"nft_unregister_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_RESET,\t\t\"nft_reset_obj\"\t\t   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_REGISTER,\t\"nft_register_flowtable\"   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\t\"nft_unregister_flowtable\" },\n\t{ AUDIT_NFT_OP_INVALID,\t\t\t\"nft_invalid\"\t\t   },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic const struct audit_nfcfgop_tab audit_nfcfgs[] = {\n\t{ AUDIT_XT_OP_REGISTER,\t\t\t\"xt_register\"\t\t   },\n\t{ AUDIT_XT_OP_REPLACE,\t\t\t\"xt_replace\"\t\t   },\n\t{ AUDIT_XT_OP_UNREGISTER,\t\t\"xt_unregister\"\t\t   },\n\t{ AUDIT_NFT_OP_TABLE_REGISTER,\t\t\"nft_register_table\"\t   },\n\t{ AUDIT_NFT_OP_TABLE_UNREGISTER,\t\"nft_unregister_table\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_REGISTER,\t\t\"nft_register_chain\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_UNREGISTER,\t\"nft_unregister_chain\"\t   },\n\t{ AUDIT_NFT_OP_RULE_REGISTER,\t\t\"nft_register_rule\"\t   },\n\t{ AUDIT_NFT_OP_RULE_UNREGISTER,\t\t\"nft_unregister_rule\"\t   },\n\t{ AUDIT_NFT_OP_SET_REGISTER,\t\t\"nft_register_set\"\t   },\n\t{ AUDIT_NFT_OP_SET_UNREGISTER,\t\t\"nft_unregister_set\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_REGISTER,\t\"nft_register_setelem\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_UNREGISTER,\t\"nft_unregister_setelem\"   },\n\t{ AUDIT_NFT_OP_GEN_REGISTER,\t\t\"nft_register_gen\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_REGISTER,\t\t\"nft_register_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_UNREGISTER,\t\t\"nft_unregister_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_RESET,\t\t\"nft_reset_obj\"\t\t   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_REGISTER,\t\"nft_register_flowtable\"   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\t\"nft_unregister_flowtable\" },\n\t{ AUDIT_NFT_OP_INVALID,\t\t\t\"nft_invalid\"\t\t   },\n};\n\nvoid __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t       enum audit_nfcfgop op, gfp_t gfp)\n{\n\tstruct audit_buffer *ab;\n\tchar comm[sizeof(current->comm)];\n\n\tab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"table=%s family=%u entries=%u op=%s\",\n\t\t\t name, af, nentries, audit_nfcfgs[op].s);\n\n\taudit_log_format(ab, \" pid=%u\", task_pid_nr(current));\n\taudit_log_task_context(ab); /* subj= */\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_fanotify(unsigned int response)\n{\n\taudit_log(audit_context(), GFP_KERNEL,\n\t\tAUDIT_FANOTIFY,\t\"resp=%u\", response);\n}"
  },
  {
    "function_name": "__audit_log_kern_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2834-2842",
    "snippet": "void __audit_log_kern_module(char *name)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->module.name = kstrdup(name, GFP_KERNEL);\n\tif (!context->module.name)\n\t\taudit_log_lost(\"out of memory in __audit_log_kern_module\");\n\tcontext->type = AUDIT_KERN_MODULE;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in __audit_log_kern_module\""
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_log_kern_module(char *name)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->module.name = kstrdup(name, GFP_KERNEL);\n\tif (!context->module.name)\n\t\taudit_log_lost(\"out of memory in __audit_log_kern_module\");\n\tcontext->type = AUDIT_KERN_MODULE;\n}"
  },
  {
    "function_name": "__audit_openat2_how",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2824-2832",
    "snippet": "void __audit_openat2_how(struct open_how *how)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->openat2.flags = how->flags;\n\tcontext->openat2.mode = how->mode;\n\tcontext->openat2.resolve = how->resolve;\n\tcontext->type = AUDIT_OPENAT2;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_openat2_how(struct open_how *how)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->openat2.flags = how->flags;\n\tcontext->openat2.mode = how->mode;\n\tcontext->openat2.resolve = how->resolve;\n\tcontext->type = AUDIT_OPENAT2;\n}"
  },
  {
    "function_name": "__audit_mmap_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2815-2822",
    "snippet": "void __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}"
  },
  {
    "function_name": "__audit_log_capset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2803-2813",
    "snippet": "void __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->capset.pid = task_tgid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->capset.cap.ambient     = new->cap_ambient;\n\tcontext->type = AUDIT_CAPSET;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->capset.pid = task_tgid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->capset.cap.ambient     = new->cap_ambient;\n\tcontext->type = AUDIT_CAPSET;\n}"
  },
  {
    "function_name": "__audit_log_bprm_fcaps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2759-2793",
    "snippet": "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = audit_context();\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(&init_user_ns,\n\t\t\t       bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap.rootid = vcaps.rootid;\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\tax->old_pcap.ambient     = old->cap_ambient;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\tax->new_pcap.ambient     = new->cap_ambient;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vfs_caps_from_disk",
          "args": [
            "&init_user_ns",
            "bprm->file->f_path.dentry",
            "&vcaps"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ax)",
            "GFP_KERNEL"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = audit_context();\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(&init_user_ns,\n\t\t\t       bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap.rootid = vcaps.rootid;\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\tax->old_pcap.ambient     = old->cap_ambient;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\tax->new_pcap.ambient     = new->cap_ambient;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_signal_info_syscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2704-2746",
    "snippet": "int audit_signal_info_syscall(struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t t_uid = task_uid(t);\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDIT_AUX_PIDS\t16"
    ],
    "globals_used": [
      "int audit_signals;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "axp->target_comm[axp->pid_count]",
            "t->comm",
            "TASK_COMM_LEN"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getsecid_obj",
          "args": [
            "t",
            "&axp->target_sid[axp->pid_count]"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "axp->pid_count >= AUDIT_AUX_PIDS"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*axp)",
            "GFP_ATOMIC"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid_obj",
          "args": [
            "t",
            "&ctx->target_sid"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "t"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDIT_AUX_PIDS\t16\n\nint audit_signals;\n\nint audit_signal_info_syscall(struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t t_uid = task_uid(t);\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_ptrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2685-2695",
    "snippet": "void __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->target_comm",
            "t->comm",
            "TASK_COMM_LEN"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getsecid_obj",
          "args": [
            "t",
            "&context->target_sid"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "t"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}"
  },
  {
    "function_name": "__audit_sockaddr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2668-2683",
    "snippet": "int __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->sockaddr",
            "a",
            "len"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct sockaddr_storage)",
            "GFP_KERNEL"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_fd_pair",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2653-2659",
    "snippet": "void __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}"
  },
  {
    "function_name": "__audit_socketcall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2635-2645",
    "snippet": "int __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->socketcall.args",
            "args",
            "nargs * sizeof(unsigned long)"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_bprm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2620-2626",
    "snippet": "void __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}"
  },
  {
    "function_name": "__audit_ipc_set_perm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2609-2618",
    "snippet": "void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}"
  },
  {
    "function_name": "__audit_ipc_obj",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2588-2598",
    "snippet": "void __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_ipc_getsecid",
          "args": [
            "ipcp",
            "&context->ipc.osid"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}"
  },
  {
    "function_name": "__audit_mq_getsetattr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2574-2581",
    "snippet": "void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}"
  },
  {
    "function_name": "__audit_mq_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2555-2566",
    "snippet": "void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}"
  },
  {
    "function_name": "__audit_mq_sendrecv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2530-2546",
    "snippet": "void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec64 *abs_timeout)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct timespec64 *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(*p));\n\telse\n\t\tmemset(p, 0, sizeof(*p));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "abs_timeout",
            "sizeof(*p)"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec64 *abs_timeout)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct timespec64 *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(*p));\n\telse\n\t\tmemset(p, 0, sizeof(*p));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}"
  },
  {
    "function_name": "__audit_mq_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2507-2520",
    "snippet": "void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->mq_open.attr",
            "0",
            "sizeof(struct mq_attr)"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->mq_open.attr",
            "attr",
            "sizeof(struct mq_attr)"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}"
  },
  {
    "function_name": "auditsc_get_stamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2483-2498",
    "snippet": "int auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (ctx->context == AUDIT_CTX_UNUSED)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_serial",
          "args": [],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "audit_serial",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1791-1796",
          "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (ctx->context == AUDIT_CTX_UNUSED)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__audit_inode_child",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2375-2472",
    "snippet": "void __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst struct qstr *dname = &dentry->d_name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname->name, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent, 0);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode, 0);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_inode",
          "args": [
            "found_child",
            "dentry",
            "inode",
            "0"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2234-2250",
          "snippet": "static void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "type"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2135-2158",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_compare_dname_path",
          "args": [
            "dname",
            "n->name->name",
            "found_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_dname_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1310-1327",
          "snippet": "int audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dname->name",
            "n->name->name"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_one",
          "args": [
            "inode"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "handle_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2048-2075",
          "snippet": "static inline void handle_one(const struct inode *inode)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void handle_one(const struct inode *inode)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "parent->i_sb->s_magic",
            "f->op",
            "f->val"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1204-1226",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst struct qstr *dname = &dentry->d_name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname->name, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent, 0);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode, 0);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}"
  },
  {
    "function_name": "__audit_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2356-2359",
    "snippet": "void __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__audit_inode",
          "args": [
            "NULL",
            "file->f_path.dentry",
            "0"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_inode_child",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2375-2472",
          "snippet": "void __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst struct qstr *dname = &dentry->d_name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname->name, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent, 0);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode, 0);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst struct qstr *dname = &dentry->d_name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname->name, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent, 0);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode, 0);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}"
  },
  {
    "function_name": "__audit_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2258-2354",
    "snippet": "void __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(inode->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode, flags & AUDIT_INODE_NOEVAL);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_inode",
          "args": [
            "n",
            "dentry",
            "inode",
            "flags & AUDIT_INODE_NOEVAL"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2234-2250",
          "snippet": "static void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_path",
          "args": [
            "dentry"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "handle_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2077-2133",
          "snippet": "static void handle_path(const struct dentry *dentry)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void handle_path(const struct dentry *dentry)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_len",
          "args": [
            "n->name->name"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "parent_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1276-1300",
          "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "AUDIT_TYPE_UNKNOWN"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2135-2158",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "n->name->name",
            "name->name"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "inode->i_sb->s_magic",
            "f->op",
            "f->val"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1204-1226",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(inode->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode, flags & AUDIT_INODE_NOEVAL);\n}"
  },
  {
    "function_name": "audit_copy_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2234-2250",
    "snippet": "static void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_fcaps",
          "args": [
            "name",
            "dentry"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_fcaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2210-2231",
          "snippet": "static inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(&init_user_ns, dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap.rootid = caps.rootid;\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(&init_user_ns, dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap.rootid = caps.rootid;\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_getsecid",
          "args": [
            "inode",
            "&name->osid"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}"
  },
  {
    "function_name": "audit_copy_fcaps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2210-2231",
    "snippet": "static inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(&init_user_ns, dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap.rootid = caps.rootid;\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vfs_caps_from_disk",
          "args": [
            "&init_user_ns",
            "dentry",
            "&caps"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(&init_user_ns, dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap.rootid = caps.rootid;\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_getname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2192-2208",
    "snippet": "void __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "AUDIT_TYPE_UNKNOWN"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2135-2158",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n}"
  },
  {
    "function_name": "__audit_reusename",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2168-2183",
    "snippet": "struct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_alloc_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2135-2158",
    "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fs_pwd",
          "args": [
            "current->fs",
            "&context->pwd"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&aname->list",
            "&context->names_list"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aname)",
            "GFP_NOFS"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "aname",
            "0",
            "sizeof(*aname)"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}"
  },
  {
    "function_name": "handle_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2077-2133",
    "snippet": "static void handle_path(const struct dentry *dentry)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_auditable",
          "args": [
            "context"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_auditable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "221-227",
          "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "p",
            "count"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "268-295",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory, audit has lost a tree reference\\n\""
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_tree_refs",
          "args": [
            "context"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "grow_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "251-266",
          "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "drop"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "139-143",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_seqretry(&rename_lock, seq) || drop"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!put_tree_ref(context, chunk)"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_tree_ref",
          "args": [
            "context",
            "chunk"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "put_tree_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "229-249",
          "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_lookup",
          "args": [
            "inode"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "242-259",
          "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_fsnotify_marks"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "d"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void handle_path(const struct dentry *dentry)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "handle_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2048-2075",
    "snippet": "static inline void handle_one(const struct inode *inode)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree_ref",
          "args": [
            "context",
            "chunk"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "put_tree_ref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "229-249",
          "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "p",
            "count"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "268-295",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "139-143",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_auditable",
          "args": [
            "context"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_auditable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "221-227",
          "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory, audit has lost a tree reference\\n\""
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!grow_tree_refs(context)"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_tree_refs",
          "args": [
            "context"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "grow_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "251-266",
          "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "put_tree_ref(context, chunk)"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_lookup",
          "args": [
            "inode"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "242-259",
          "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\t/*\n\t\t * We use a data dependency barrier in READ_ONCE() to make sure\n\t\t * the chunk we see is fully initialized.\n\t\t */\n\t\tif (READ_ONCE(p->key) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!inode->i_fsnotify_marks"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void handle_one(const struct inode *inode)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n}"
  },
  {
    "function_name": "__audit_syscall_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "2023-2046",
    "snippet": "void __audit_syscall_exit(int success, long return_code)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context || context->dummy ||\n\t    context->context != AUDIT_CTX_SYSCALL)\n\t\tgoto out;\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\t/* run through both filters to ensure we set the filterkey properly */\n\taudit_filter_syscall(current, context);\n\taudit_filter_inodes(current, context);\n\tif (context->current_state < AUDIT_STATE_RECORD)\n\t\tgoto out;\n\n\taudit_return_fixup(context, success, return_code);\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_reset_context",
          "args": [
            "context"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "audit_reset_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "963-1021",
          "snippet": "static void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_exit",
          "args": [],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1647-1788",
          "snippet": "static void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_return_fixup",
          "args": [
            "context",
            "success",
            "return_code"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "audit_return_fixup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1842-1859",
          "snippet": "static void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "current",
            "context"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "891-905",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_syscall",
          "args": [
            "current",
            "context"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_syscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "841-862",
          "snippet": "static void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_kill_trees",
          "args": [
            "context"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "audit_kill_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "972-995",
          "snippet": "void audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&context->killed_trees"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_syscall_exit(int success, long return_code)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context || context->dummy ||\n\t    context->context != AUDIT_CTX_SYSCALL)\n\t\tgoto out;\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\t/* run through both filters to ensure we set the filterkey properly */\n\taudit_filter_syscall(current, context);\n\taudit_filter_inodes(current, context);\n\tif (context->current_state < AUDIT_STATE_RECORD)\n\t\tgoto out;\n\n\taudit_return_fixup(context, success, return_code);\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(context);\n}"
  },
  {
    "function_name": "__audit_syscall_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1974-2010",
    "snippet": "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tWARN_ON(context->context != AUDIT_CTX_UNUSED);\n\tWARN_ON(context->name_count);\n\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {\n\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");\n\t\treturn;\n\t}\n\n\tstate = context->state;\n\tif (state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_STATE_BUILD) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch(current);\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->context = AUDIT_CTX_SYSCALL;\n\tcontext->current_state  = state;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int audit_n_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "&context->ctime"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2234-2244",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [
            "current"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "current"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"unrecoverable error in audit_syscall_entry()\""
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "context->name_count"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "context->context != AUDIT_CTX_UNUSED"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_n_rules;\n\nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tWARN_ON(context->context != AUDIT_CTX_UNUSED);\n\tWARN_ON(context->name_count);\n\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {\n\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");\n\t\treturn;\n\t}\n\n\tstate = context->state;\n\tif (state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_STATE_BUILD) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch(current);\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->context = AUDIT_CTX_SYSCALL;\n\tcontext->current_state  = state;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}"
  },
  {
    "function_name": "__audit_uring_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1906-1956",
    "snippet": "void __audit_uring_exit(int success, long code)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->context == AUDIT_CTX_SYSCALL) {\n\t\t/*\n\t\t * NOTE: See the note in __audit_uring_entry() about the case\n\t\t *       where we may be called from process context before we\n\t\t *       return to userspace via audit_syscall_exit().  In this\n\t\t *       case we simply emit a URINGOP record and bail, the\n\t\t *       normal syscall exit handling will take care of\n\t\t *       everything else.\n\t\t *       It is also worth mentioning that when we are called,\n\t\t *       the current process creds may differ from the creds\n\t\t *       used during the normal syscall processing; keep that\n\t\t *       in mind if/when we move the record generation code.\n\t\t */\n\n\t\t/*\n\t\t * We need to filter on the syscall info here to decide if we\n\t\t * should emit a URINGOP record.  I know it seems odd but this\n\t\t * solves the problem where users have a filter to block *all*\n\t\t * syscall records in the \"exit\" filter; we want to preserve\n\t\t * the behavior here.\n\t\t */\n\t\taudit_filter_syscall(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\taudit_filter_uring(current, ctx);\n\t\taudit_filter_inodes(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\treturn;\n\n\t\taudit_log_uring(ctx);\n\t\treturn;\n\t}\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&ctx->killed_trees))\n\t\taudit_kill_trees(ctx);\n\n\t/* run through both filters to ensure we set the filterkey properly */\n\taudit_filter_uring(current, ctx);\n\taudit_filter_inodes(current, ctx);\n\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\tgoto out;\n\taudit_return_fixup(ctx, success, code);\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(ctx);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_reset_context",
          "args": [
            "ctx"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "audit_reset_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "963-1021",
          "snippet": "static void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_exit",
          "args": [],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1647-1788",
          "snippet": "static void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_return_fixup",
          "args": [
            "ctx",
            "success",
            "code"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "audit_return_fixup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1842-1859",
          "snippet": "static void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "current",
            "ctx"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "891-905",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_uring",
          "args": [
            "current",
            "ctx"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_uring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "813-834",
          "snippet": "static void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_kill_trees",
          "args": [
            "ctx"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "audit_kill_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "972-995",
          "snippet": "void audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->killed_trees"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_uring",
          "args": [
            "ctx"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_uring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1613-1645",
          "snippet": "static void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_syscall",
          "args": [
            "current",
            "ctx"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_syscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "841-862",
          "snippet": "static void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_uring_exit(int success, long code)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->context == AUDIT_CTX_SYSCALL) {\n\t\t/*\n\t\t * NOTE: See the note in __audit_uring_entry() about the case\n\t\t *       where we may be called from process context before we\n\t\t *       return to userspace via audit_syscall_exit().  In this\n\t\t *       case we simply emit a URINGOP record and bail, the\n\t\t *       normal syscall exit handling will take care of\n\t\t *       everything else.\n\t\t *       It is also worth mentioning that when we are called,\n\t\t *       the current process creds may differ from the creds\n\t\t *       used during the normal syscall processing; keep that\n\t\t *       in mind if/when we move the record generation code.\n\t\t */\n\n\t\t/*\n\t\t * We need to filter on the syscall info here to decide if we\n\t\t * should emit a URINGOP record.  I know it seems odd but this\n\t\t * solves the problem where users have a filter to block *all*\n\t\t * syscall records in the \"exit\" filter; we want to preserve\n\t\t * the behavior here.\n\t\t */\n\t\taudit_filter_syscall(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\taudit_filter_uring(current, ctx);\n\t\taudit_filter_inodes(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\treturn;\n\n\t\taudit_log_uring(ctx);\n\t\treturn;\n\t}\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&ctx->killed_trees))\n\t\taudit_kill_trees(ctx);\n\n\t/* run through both filters to ensure we set the filterkey properly */\n\taudit_filter_uring(current, ctx);\n\taudit_filter_inodes(current, ctx);\n\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\tgoto out;\n\taudit_return_fixup(ctx, success, code);\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(ctx);\n}"
  },
  {
    "function_name": "__audit_uring_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1870-1894",
    "snippet": "void __audit_uring_entry(u8 op)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\t/*\n\t * NOTE: It's possible that we can be called from the process' context\n\t *       before it returns to userspace, and before audit_syscall_exit()\n\t *       is called.  In this case there is not much to do, just record\n\t *       the io_uring details and return.\n\t */\n\tctx->uring_op = op;\n\tif (ctx->context == AUDIT_CTX_SYSCALL)\n\t\treturn;\n\n\tctx->dummy = !audit_n_rules;\n\tif (!ctx->dummy && ctx->state == AUDIT_STATE_BUILD)\n\t\tctx->prio = 0;\n\n\tctx->context = AUDIT_CTX_URING;\n\tctx->current_state = ctx->state;\n\tktime_get_coarse_real_ts64(&ctx->ctime);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int audit_n_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "&ctx->ctime"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2234-2244",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_n_rules;\n\nvoid __audit_uring_entry(u8 op)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\t/*\n\t * NOTE: It's possible that we can be called from the process' context\n\t *       before it returns to userspace, and before audit_syscall_exit()\n\t *       is called.  In this case there is not much to do, just record\n\t *       the io_uring details and return.\n\t */\n\tctx->uring_op = op;\n\tif (ctx->context == AUDIT_CTX_SYSCALL)\n\t\treturn;\n\n\tctx->dummy = !audit_n_rules;\n\tif (!ctx->dummy && ctx->state == AUDIT_STATE_BUILD)\n\t\tctx->prio = 0;\n\n\tctx->context = AUDIT_CTX_URING;\n\tctx->current_state = ctx->state;\n\tktime_get_coarse_real_ts64(&ctx->ctime);\n}"
  },
  {
    "function_name": "audit_return_fixup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1842-1859",
    "snippet": "static void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_FAILURE 2",
      "#define AUDITSC_SUCCESS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "code <= -ERESTARTSYS"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t/*\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}"
  },
  {
    "function_name": "__audit_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1796-1831",
    "snippet": "void __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn;\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\t/* We are called either by do_exit() or the fork() error handling code;\n\t * in the former case tsk == current and in the latter tsk is a\n\t * random task_struct that doesn't doesn't have any meaningful data we\n\t * need to log via audit_log_exit().\n\t */\n\tif (tsk == current && !context->dummy) {\n\t\tcontext->return_valid = AUDITSC_INVALID;\n\t\tcontext->return_code = 0;\n\t\tif (context->context == AUDIT_CTX_SYSCALL) {\n\t\t\taudit_filter_syscall(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_exit();\n\t\t} else if (context->context == AUDIT_CTX_URING) {\n\t\t\t/* TODO: verify this case is real and valid */\n\t\t\taudit_filter_uring(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_uring(context);\n\t\t}\n\t}\n\n\taudit_set_context(tsk, NULL);\n\taudit_free_context(context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_context",
          "args": [
            "context"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1101-1108",
          "snippet": "static inline void audit_free_context(struct audit_context *context)\n{\n\t/* resetting is extra work, but it is likely just noise */\n\taudit_reset_context(context);\n\tfree_tree_refs(context);\n\tkfree(context->filterkey);\n\tkfree(context);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\t/* resetting is extra work, but it is likely just noise */\n\taudit_reset_context(context);\n\tfree_tree_refs(context);\n\tkfree(context->filterkey);\n\tkfree(context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_context",
          "args": [
            "tsk",
            "NULL"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_uring",
          "args": [
            "context"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_uring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1613-1645",
          "snippet": "static void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "tsk",
            "context"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "891-905",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_uring",
          "args": [
            "tsk",
            "context"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_uring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "813-834",
          "snippet": "static void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_exit",
          "args": [],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1647-1788",
          "snippet": "static void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_syscall",
          "args": [
            "tsk",
            "context"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_syscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "841-862",
          "snippet": "static void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_kill_trees",
          "args": [
            "context"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "audit_kill_trees",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "972-995",
          "snippet": "void audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct audit_context *context)\n{\n\tstruct list_head *list = &context->killed_trees;\n\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(context, victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nvoid __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn;\n\n\t/* this may generate CONFIG_CHANGE records */\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\t/* We are called either by do_exit() or the fork() error handling code;\n\t * in the former case tsk == current and in the latter tsk is a\n\t * random task_struct that doesn't doesn't have any meaningful data we\n\t * need to log via audit_log_exit().\n\t */\n\tif (tsk == current && !context->dummy) {\n\t\tcontext->return_valid = AUDITSC_INVALID;\n\t\tcontext->return_code = 0;\n\t\tif (context->context == AUDIT_CTX_SYSCALL) {\n\t\t\taudit_filter_syscall(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_exit();\n\t\t} else if (context->context == AUDIT_CTX_URING) {\n\t\t\t/* TODO: verify this case is real and valid */\n\t\t\taudit_filter_uring(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_uring(context);\n\t\t}\n\t}\n\n\taudit_set_context(tsk, NULL);\n\taudit_free_context(context);\n}"
  },
  {
    "function_name": "audit_log_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1647-1788",
    "snippet": "static void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_SUCCESS 1",
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error in audit_log_exit()\""
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_EOE"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_proctitle",
          "args": [],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_proctitle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1568-1607",
          "snippet": "static void audit_log_proctitle(void)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_PROCTITLE_AUDIT_LEN 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\nstatic void audit_log_proctitle(void)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_name",
          "args": [
            "context",
            "n",
            "NULL",
            "i++",
            "&call_panic"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1482-1566",
          "snippet": "static void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd\n\t\t\t */\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\telse\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\tswitch (n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \" nametype=PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \" nametype=DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \" nametype=CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd\n\t\t\t */\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\telse\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\tswitch (n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \" nametype=PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \" nametype=DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \" nametype=CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\"cwd=\"",
            "&context->pwd"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2103-2124",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_pid_context",
          "args": [
            "context",
            "context->target_pid",
            "context->target_auid",
            "context->target_uid",
            "context->target_sessionid",
            "context->target_sid",
            "context->target_comm"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_pid_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1110-1140",
          "snippet": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "ab",
            "(void *)context->sockaddr",
            "context->sockaddr_len"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1990-2017",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"saddr=\""
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_special",
          "args": [
            "context",
            "&call_panic"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "show_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1343-1459",
          "snippet": "static void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_OPENAT2:\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\n\t\t\t\t context->openat2.flags,\n\t\t\t\t context->openat2.mode,\n\t\t\t\t context->openat2.resolve);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_OPENAT2:\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\n\t\t\t\t context->openat2.flags,\n\t\t\t\t context->openat2.mode,\n\t\t\t\t context->openat2.resolve);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "axs->fcap.rootid"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"pa\"",
            "&axs->new_pcap.ambient"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1316-1328",
          "snippet": "static void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_uring",
          "args": [
            "context"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_uring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1613-1645",
          "snippet": "static void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "context->filterkey"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2134-2141",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2207-2240",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}"
  },
  {
    "function_name": "audit_log_uring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1613-1645",
    "snippet": "static void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_SUCCESS 1",
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "ctx->filterkey"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2134-2141",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2143-2168",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\"",
            "ctx->name_count",
            "task_ppid_nr(current)",
            "task_tgid_nr(current)",
            "from_kuid(&init_user_ns, cred->uid)",
            "from_kgid(&init_user_ns, cred->gid)",
            "from_kuid(&init_user_ns, cred->euid)",
            "from_kuid(&init_user_ns, cred->suid)",
            "from_kuid(&init_user_ns, cred->fsuid)",
            "from_kgid(&init_user_ns, cred->egid)",
            "from_kgid(&init_user_ns, cred->sgid)",
            "from_kgid(&init_user_ns, cred->fsgid)"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "cred->fsgid"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "cred->fsuid"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_ppid_nr",
          "args": [
            "current"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "ctx",
            "GFP_ATOMIC",
            "AUDIT_URINGOP"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_proctitle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1568-1607",
    "snippet": "static void audit_log_proctitle(void)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_PROCTITLE_AUDIT_LEN 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "msg",
            "len"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2080-2087",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_proctitle_rtrim",
          "args": [
            "buf",
            "res"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "audit_proctitle_rtrim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1461-1472",
          "snippet": "static inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cmdline",
          "args": [
            "current",
            "buf",
            "MAX_PROCTITLE_AUDIT_LEN"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_PROCTITLE_AUDIT_LEN",
            "GFP_KERNEL"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"proctitle=\""
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_PROCTITLE"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\nstatic void audit_log_proctitle(void)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1482-1566",
    "snippet": "static void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd\n\t\t\t */\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\telse\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\tswitch (n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \" nametype=PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \" nametype=DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \" nametype=CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_fcaps",
          "args": [
            "ab",
            "n"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_fcaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1330-1341",
          "snippet": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\tif (name->fcap_ver == -1) {\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\n\t\treturn;\n\t}\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\n\t\t\t name->fcap.fE, name->fcap_ver,\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\tif (name->fcap_ver == -1) {\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\n\t\treturn;\n\t}\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\n\t\t\t name->fcap.fE, name->fcap_ver,\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" nametype=UNKNOWN\""
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "n->osid",
            "&ctx",
            "&len"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->rdev"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->rdev"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "n->gid"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "n->uid"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->dev"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->dev"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "n->name->name",
            "n->name_len"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2080-2087",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\" name=\"",
            "&context->pwd"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2103-2124",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "n->name->name"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_PATH"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd\n\t\t\t */\n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\telse\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\tswitch (n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \" nametype=PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \" nametype=DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \" nametype=CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_proctitle_rtrim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1461-1472",
    "snippet": "static inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "proctitle[len-1]"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "*end"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}"
  },
  {
    "function_name": "show_special",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1343-1459",
    "snippet": "static void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_OPENAT2:\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\n\t\t\t\t context->openat2.flags,\n\t\t\t\t context->openat2.mode,\n\t\t\t\t context->openat2.resolve);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"(null)\""
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "context->module.name"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_execve_info",
          "args": [
            "context",
            "&ab"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_execve_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1142-1314",
          "snippet": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf >= 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_EXECVE_AUDIT_LEN 7500"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_EXECVE_AUDIT_LEN 7500\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf >= 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"cap_pa\"",
            "&context->capset.cap.ambient"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1316-1328",
          "snippet": "static void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_IPC_SET_PERM"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "osid",
            "&ctx",
            "&len"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "context->ipc.gid"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "context->ipc.uid"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_OPENAT2:\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\n\t\t\t\t context->openat2.flags,\n\t\t\t\t context->openat2.mode,\n\t\t\t\t context->openat2.resolve);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_fcaps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1330-1341",
    "snippet": "static void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\tif (name->fcap_ver == -1) {\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\n\t\treturn;\n\t}\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\n\t\t\t name->fcap.fE, name->fcap_ver,\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" cap_fe=%d cap_fver=%x cap_frootid=%d\"",
            "name->fcap.fE",
            "name->fcap_ver",
            "from_kuid(&init_user_ns, name->fcap.rootid)"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "name->fcap.rootid"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"cap_fi\"",
            "&name->fcap.inheritable"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1316-1328",
          "snippet": "static void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\tif (name->fcap_ver == -1) {\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\n\t\treturn;\n\t}\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\n\t\t\t name->fcap.fE, name->fcap_ver,\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\n}"
  },
  {
    "function_name": "audit_log_cap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1316-1328",
    "snippet": "static void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" %s=\"",
            "prefix"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_isclear",
          "args": [
            "*cap"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tint i;\n\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i)\n\t\taudit_log_format(ab, \"%08x\", cap->cap[CAP_LAST_U32 - i]);\n}"
  },
  {
    "function_name": "audit_log_execve_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1142-1314",
    "snippet": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf >= 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_EXECVE_AUDIT_LEN 7500"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_head"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_string",
          "args": [
            "*ab",
            "buf",
            "len_tmp"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2023-2049",
          "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "*ab",
            "buf",
            "len_tmp"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1990-2017",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "*ab",
            "\"%s\"",
            "abuf"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "len_tmp >= sizeof(abuf)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d=\"",
            "arg"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d[%d]=\"",
            "arg",
            "iter++"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d_len=%lu\"",
            "arg",
            "len_full"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_EXECVE"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "*ab"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_string_contains_control",
          "args": [
            "buf",
            "len_tmp"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "audit_string_contains_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2056-2064",
          "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGKILL",
            "current",
            "0"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1950-1996",
          "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "&buf_head[len_buf]",
            "p",
            "len_max - len_buf"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf_head",
            "buf",
            "len_buf"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"out of memory for argv string\""
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_EXECVE_AUDIT_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "MAX_EXECVE_AUDIT_LEN > 7500"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_EXECVE_AUDIT_LEN 7500\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf >= 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}"
  },
  {
    "function_name": "audit_log_pid_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1110-1140",
    "snippet": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "comm"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" ocomm=\""
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "sid",
            "&ctx",
            "&len"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_OBJ_PID"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_free_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1101-1108",
    "snippet": "static inline void audit_free_context(struct audit_context *context)\n{\n\t/* resetting is extra work, but it is likely just noise */\n\taudit_reset_context(context);\n\tfree_tree_refs(context);\n\tkfree(context->filterkey);\n\tkfree(context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_tree_refs",
          "args": [
            "context"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "free_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "297-305",
          "snippet": "static void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_reset_context",
          "args": [
            "context"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "audit_reset_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "963-1021",
          "snippet": "static void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\t/* resetting is extra work, but it is likely just noise */\n\taudit_reset_context(context);\n\tfree_tree_refs(context);\n\tkfree(context->filterkey);\n\tkfree(context);\n}"
  },
  {
    "function_name": "audit_alloc_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1083-1099",
    "snippet": "int audit_alloc_kernel(struct task_struct *tsk)\n{\n\t/*\n\t * At the moment we are just going to call into audit_alloc() to\n\t * simplify the code, but there two things to keep in mind with this\n\t * approach:\n\t *\n\t * 1. Filtering internal kernel tasks is a bit laughable in almost all\n\t * cases, but there is at least one case where there is a benefit:\n\t * the '-a task,never' case allows the admin to effectively disable\n\t * task auditing at runtime.\n\t *\n\t * 2. The {set,clear}_task_syscall_work() ops likely have zero effect\n\t * on these internal kernel tasks, but they probably don't hurt either.\n\t */\n\treturn audit_alloc(tsk);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_alloc",
          "args": [
            "tsk"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1083-1099",
          "snippet": "int audit_alloc_kernel(struct task_struct *tsk)\n{\n\t/*\n\t * At the moment we are just going to call into audit_alloc() to\n\t * simplify the code, but there two things to keep in mind with this\n\t * approach:\n\t *\n\t * 1. Filtering internal kernel tasks is a bit laughable in almost all\n\t * cases, but there is at least one case where there is a benefit:\n\t * the '-a task,never' case allows the admin to effectively disable\n\t * task auditing at runtime.\n\t *\n\t * 2. The {set,clear}_task_syscall_work() ops likely have zero effect\n\t * on these internal kernel tasks, but they probably don't hurt either.\n\t */\n\treturn audit_alloc(tsk);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_alloc_kernel(struct task_struct *tsk)\n{\n\t/*\n\t * At the moment we are just going to call into audit_alloc() to\n\t * simplify the code, but there two things to keep in mind with this\n\t * approach:\n\t *\n\t * 1. Filtering internal kernel tasks is a bit laughable in almost all\n\t * cases, but there is at least one case where there is a benefit:\n\t * the '-a task,never' case allows the admin to effectively disable\n\t * task auditing at runtime.\n\t *\n\t * 2. The {set,clear}_task_syscall_work() ops likely have zero effect\n\t * on these internal kernel tasks, but they probably don't hurt either.\n\t */\n\treturn audit_alloc(tsk);\n}"
  },
  {
    "function_name": "audit_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1049-1074",
    "snippet": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0;\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_STATE_DISABLED) {\n\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\taudit_set_context(tsk, context);\n\tset_task_syscall_work(tsk, SYSCALL_AUDIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_task_syscall_work",
          "args": [
            "tsk",
            "SYSCALL_AUDIT"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_context",
          "args": [
            "tsk",
            "context"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_alloc\""
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "354-384",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_context",
          "args": [
            "state"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_context",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "1023-1038",
          "snippet": "static inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->context = AUDIT_CTX_UNUSED;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_STATE_RECORD ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\tcontext->fds[0] = -1;\n\tcontext->return_valid = AUDITSC_INVALID;\n\treturn context;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->context = AUDIT_CTX_UNUSED;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_STATE_RECORD ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\tcontext->fds[0] = -1;\n\tcontext->return_valid = AUDITSC_INVALID;\n\treturn context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_task_syscall_work",
          "args": [
            "tsk",
            "SYSCALL_AUDIT"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter_task",
          "args": [
            "tsk",
            "&key"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "773-790",
          "snippet": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_STATE_RECORD)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_STATE_BUILD;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_STATE_RECORD)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_STATE_BUILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!audit_ever_enabled"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0;\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_STATE_DISABLED) {\n\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\taudit_set_context(tsk, context);\n\tset_task_syscall_work(tsk, SYSCALL_AUDIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_alloc_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "1023-1038",
    "snippet": "static inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->context = AUDIT_CTX_UNUSED;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_STATE_RECORD ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\tcontext->fds[0] = -1;\n\tcontext->return_valid = AUDITSC_INVALID;\n\treturn context;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&context->names_list"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*context)",
            "GFP_KERNEL"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->context = AUDIT_CTX_UNUSED;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_STATE_RECORD ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\tcontext->fds[0] = -1;\n\tcontext->return_valid = AUDITSC_INVALID;\n\treturn context;\n}"
  },
  {
    "function_name": "audit_reset_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "963-1021",
    "snippet": "static void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_proctitle_free",
          "args": [
            "ctx"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "audit_proctitle_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "907-912",
          "snippet": "static inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_module",
          "args": [
            "ctx"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "914-920",
          "snippet": "static inline void audit_free_module(struct audit_context *context)\n{\n\tif (context->type == AUDIT_KERN_MODULE) {\n\t\tkfree(context->module.name);\n\t\tcontext->module.name = NULL;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_module(struct audit_context *context)\n{\n\tif (context->type == AUDIT_KERN_MODULE) {\n\t\tkfree(context->module.name);\n\t\tcontext->module.name = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&ctx->killed_trees)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->killed_trees"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "ctx",
            "NULL",
            "0"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "268-295",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "0"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KGIDT_INIT",
          "args": [
            "0"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->sockaddr"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_aux",
          "args": [
            "ctx"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "938-952",
          "snippet": "static inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux = NULL;\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux_pids = NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux = NULL;\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux_pids = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_names",
          "args": [
            "ctx"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_names",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "921-936",
          "snippet": "static inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ctx->argv",
            "0",
            "sizeof(ctx->argv)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_INVALID 0\n\nstatic void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t/* if ctx is non-null, reset the \"ctx->state\" regardless */\n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t/*\n\t * NOTE: It shouldn't matter in what order we release the fields, so\n\t *       release them in the order in which they appear in the struct;\n\t *       this gives us some hope of quickly making sure we are\n\t *       resetting the audit_context properly.\n\t *\n\t *       Other things worth mentioning:\n\t *       - we don't reset \"dummy\"\n\t *       - we don't reset \"state\", we do reset \"current_state\"\n\t *       - we preserve \"filterkey\" if \"state\" is AUDIT_STATE_RECORD\n\t *       - much of this is likely overkill, but play it safe for now\n\t *       - we really need to work on improving the audit_context struct\n\t */\n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->pid = ctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\tctx->type = 0;\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\taudit_proctitle_free(ctx);\n}"
  },
  {
    "function_name": "audit_free_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "938-952",
    "snippet": "static inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux = NULL;\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux_pids = NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux = NULL;\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux_pids = NULL;\n}"
  },
  {
    "function_name": "audit_free_names",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "921-936",
    "snippet": "static inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&context->pwd"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "n->name"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&n->list"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "n",
            "next",
            "&context->names_list",
            "list"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}"
  },
  {
    "function_name": "audit_free_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "914-920",
    "snippet": "static inline void audit_free_module(struct audit_context *context)\n{\n\tif (context->type == AUDIT_KERN_MODULE) {\n\t\tkfree(context->module.name);\n\t\tcontext->module.name = NULL;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context->module.name"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_module(struct audit_context *context)\n{\n\tif (context->type == AUDIT_KERN_MODULE) {\n\t\tkfree(context->module.name);\n\t\tcontext->module.name = NULL;\n\t}\n}"
  },
  {
    "function_name": "audit_proctitle_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "907-912",
    "snippet": "static inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context->proctitle.value"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}"
  },
  {
    "function_name": "audit_filter_inodes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "891-905",
    "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inode_name",
          "args": [
            "tsk",
            "n",
            "ctx"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inode_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "868-884",
          "snippet": "static int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "tsk"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "audit_filter_inode_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "868-884",
    "snippet": "static int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "ctx",
            "n",
            "&state",
            "false"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "461-767",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_in_mask",
          "args": [
            "&e->rule",
            "ctx->major"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "audit_in_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "792-806",
          "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)n->ino"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.h",
          "lines": "218-221",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/openat2.h> // struct open_how\n#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_filter_syscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "841-862",
    "snippet": "static void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "ctx",
            "NULL",
            "&state",
            "false"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "461-767",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_in_mask",
          "args": [
            "&e->rule",
            "ctx->major"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "audit_in_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "792-806",
          "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[AUDIT_FILTER_EXIT]",
            "list"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "tsk"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_EXIT], list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t       &state, false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn;\n}"
  },
  {
    "function_name": "audit_filter_uring",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "813-834",
    "snippet": "static void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "ctx",
            "NULL",
            "&state",
            "false"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "461-767",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_in_mask",
          "args": [
            "&e->rule",
            "ctx->uring_op"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "audit_in_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "792-806",
          "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[AUDIT_FILTER_URING_EXIT]",
            "list"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "tsk"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "218-229",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection __rcu *auditd_conn;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection __rcu *auditd_conn;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\t\tlist) {\n\t\tif (audit_in_mask(&e->rule, ctx->uring_op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL, &state,\n\t\t\t\t       false)) {\n\t\t\trcu_read_unlock();\n\t\t\tctx->current_state = state;\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "audit_in_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "792-806",
    "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "val"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "val"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
  },
  {
    "function_name": "audit_filter_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "773-790",
    "snippet": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_STATE_RECORD)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_STATE_BUILD;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "e->rule.filterkey",
            "GFP_ATOMIC"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "NULL",
            "NULL",
            "&state",
            "true"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "461-767",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1",
            "#define AUDITSC_INVALID 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[AUDIT_FILTER_TASK]",
            "list"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_STATE_RECORD)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_STATE_BUILD;\n}"
  },
  {
    "function_name": "audit_filter_rules",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "461-767",
    "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_FAILURE 2",
      "#define AUDITSC_SUCCESS 1",
      "#define AUDITSC_INVALID 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "rule->filterkey",
            "GFP_ATOMIC"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->filterkey"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_field_compare",
          "args": [
            "tsk",
            "cred",
            "f",
            "ctx",
            "name"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "audit_field_compare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "377-451",
          "snippet": "static int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_filetype",
          "args": [
            "ctx",
            "f->val"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_filetype",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "194-209",
          "snippet": "static int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_perm",
          "args": [
            "ctx",
            "f->val"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_perm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "148-192",
          "snippet": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase AUDITSC_NATIVE:\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_COMPAT: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_OPEN:\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase AUDITSC_OPENAT:\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase AUDITSC_SOCKETCALL:\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase AUDITSC_EXECVE:\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tcase AUDITSC_OPENAT2:\n\t\treturn mask & ACC_MODE((u32)((struct open_how *)ctx->argv[2])->flags);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase AUDITSC_NATIVE:\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_COMPAT: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_OPEN:\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase AUDITSC_OPENAT:\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase AUDITSC_SOCKETCALL:\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase AUDITSC_EXECVE:\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tcase AUDITSC_OPENAT2:\n\t\treturn mask & ACC_MODE((u32)((struct open_how *)ctx->argv[2])->flags);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "ctx->argv[f->type-AUDIT_ARG0]",
            "f->op",
            "f->val"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1204-1226",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "ctx->ipc.osid",
            "f->type",
            "f->op",
            "f->lsm_rule"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "n->osid",
            "f->type",
            "f->op",
            "f->lsm_rule"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "name->osid",
            "f->type",
            "f->op",
            "f->lsm_rule"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "sid",
            "f->type",
            "f->op",
            "f->lsm_rule"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_current_getsecid_subj",
          "args": [
            "&sid"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "tsk"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "audit_get_loginuid(tsk)",
            "f->op",
            "f->uid"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1228-1248",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_tree_refs",
          "args": [
            "ctx",
            "rule->tree"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "match_tree_refs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "307-327",
          "snippet": "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n\tstruct audit_tree_refs *p;\n\tint n;\n\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n\tstruct audit_tree_refs *p;\n\tint n;\n\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_compare",
          "args": [
            "rule->watch",
            "name->ino",
            "name->dev"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_compare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "128-133",
          "snippet": "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "n->gid",
            "f->op",
            "f->gid"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1250-1270",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->rdev"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->dev"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "name->rdev"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "name->dev"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->rdev"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->dev"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "name->rdev"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "name->dev"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "tsk"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "f->gid"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/groups.c",
          "lines": "92-111",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_exe_compare",
          "args": [
            "tsk",
            "rule->exe"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "audit_exe_compare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "524-537",
          "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ppid_nr",
          "args": [
            "tsk"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "tsk"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "tsk->cred",
            "tsk == current || task_creation"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_INVALID 0\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t/* @tsk should always be equal to\n\t\t\t\t\t * @current with the exception of\n\t\t\t\t\t * fork()/copy_process() in which case\n\t\t\t\t\t * the new @tsk creds are still a dup\n\t\t\t\t\t * of @current's creds so we can still\n\t\t\t\t\t * use security_current_getsecid_subj()\n\t\t\t\t\t * here even though it always refs\n\t\t\t\t\t * @current's creds\n\t\t\t\t\t */\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_field_compare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "377-451",
    "snippet": "static int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Missing AUDIT_COMPARE define.  Report as a bug\\n\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "cred->sgid",
            "f->op",
            "cred->fsgid"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1250-1270",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "cred->suid",
            "f->op",
            "cred->fsuid"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1228-1248",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_compare_gid",
          "args": [
            "cred->fsgid",
            "name",
            "f",
            "ctx"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_gid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "353-375",
          "snippet": "static int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_compare_uid",
          "args": [
            "cred->fsuid",
            "name",
            "f",
            "ctx"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_uid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "329-351",
          "snippet": "static int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_compare_gid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "353-375",
    "snippet": "static int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "gid",
            "f->op",
            "n->gid"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1250-1270",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_compare_uid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "329-351",
    "snippet": "static int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "uid",
            "f->op",
            "n->uid"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1228-1248",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "match_tree_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "307-327",
    "snippet": "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n\tstruct audit_tree_refs *p;\n\tint n;\n\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_tree_match",
          "args": [
            "p->c[n]",
            "tree"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "261-268",
          "snippet": "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nbool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n\tstruct audit_tree_refs *p;\n\tint n;\n\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_tree_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "297-305",
    "snippet": "static void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}"
  },
  {
    "function_name": "unroll_tree_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "268-295",
    "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "q->c[n]"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "139-143",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}"
  },
  {
    "function_name": "grow_tree_refs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "251-266",
    "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct audit_tree_refs)",
            "GFP_KERNEL"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
  },
  {
    "function_name": "put_tree_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "229-249",
    "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "left"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_set_auditable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "221-227",
    "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}"
  },
  {
    "function_name": "audit_match_filetype",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "194-209",
    "snippet": "static int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_match_perm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
    "lines": "148-192",
    "snippet": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase AUDITSC_NATIVE:\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_COMPAT: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_OPEN:\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase AUDITSC_OPENAT:\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase AUDITSC_SOCKETCALL:\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase AUDITSC_EXECVE:\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tcase AUDITSC_OPENAT2:\n\t\treturn mask & ACC_MODE((u32)((struct open_how *)ctx->argv[2])->flags);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/openat2.h> // struct open_how",
      "#include <uapi/linux/netfilter/nf_tables.h>",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "(u32)((struct open_how *)ctx->argv[2])->flags"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(struct open_how *)ctx->argv[2]"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "ctx->argv[2]"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "ctx->argv[1]"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_match_class",
          "args": [
            "AUDIT_CLASS_CHATTR_32",
            "n"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_class_bits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "199-209",
          "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_classify_syscall",
          "args": [
            "ctx->arch",
            "n"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase AUDITSC_NATIVE:\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_COMPAT: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_OPEN:\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase AUDITSC_OPENAT:\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase AUDITSC_SOCKETCALL:\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase AUDITSC_EXECVE:\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tcase AUDITSC_OPENAT2:\n\t\treturn mask & ACC_MODE((u32)((struct open_how *)ctx->argv[2])->flags);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  }
]