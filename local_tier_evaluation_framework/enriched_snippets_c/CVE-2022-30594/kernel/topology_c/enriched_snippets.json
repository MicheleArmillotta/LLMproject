[
  {
    "function_name": "partition_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2527-2533",
    "snippet": "void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\tmutex_unlock(&sched_domains_mutex);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "partition_sched_domains_locked",
          "args": [
            "ndoms_new",
            "doms_new",
            "dattr_new"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "partition_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2421-2522",
          "snippet": "void partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t\t\t\t*doms_cur;",
            "static int\t\t\t\tndoms_cur;",
            "static struct sched_domain_attr\t\t*dattr_cur;",
            "static cpumask_var_t\t\t\tfallback_doms;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\tmutex_unlock(&sched_domains_mutex);\n}"
  },
  {
    "function_name": "partition_sched_domains_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2421-2522",
    "snippet": "void partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t\t\t\t*doms_cur;",
      "static int\t\t\t\tndoms_cur;",
      "static struct sched_domain_attr\t\t*dattr_cur;",
      "static cpumask_var_t\t\t\tfallback_doms;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_sched_domain_debugfs",
          "args": [],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_domain_debugfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1840-1842",
          "snippet": "static inline void update_sched_domain_debugfs(void)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void update_sched_domain_debugfs(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dattr_cur"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_sched_domains",
          "args": [
            "doms_cur",
            "ndoms_cur"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2328-2334",
          "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_energy_set",
          "args": [
            "has_eas"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "sched_energy_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "311-322",
          "snippet": "static void sched_energy_set(bool has_eas)\n{\n\tif (!has_eas && static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: stopping EAS\\n\", __func__);\n\t\tstatic_branch_disable_cpuslocked(&sched_energy_present);\n\t} else if (has_eas && !static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: starting EAS\\n\", __func__);\n\t\tstatic_branch_enable_cpuslocked(&sched_energy_present);\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void sched_energy_set(bool has_eas)\n{\n\tif (!has_eas && static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: stopping EAS\\n\", __func__);\n\t\tstatic_branch_disable_cpuslocked(&sched_energy_present);\n\t} else if (has_eas && !static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: starting EAS\\n\", __func__);\n\t\tstatic_branch_enable_cpuslocked(&sched_energy_present);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_perf_domains",
          "args": [
            "doms_new[i]"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "build_perf_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "352-446",
          "snippet": "static bool build_perf_domains(const struct cpumask *cpu_map)\n{\n\tint i, nr_pd = 0, nr_ps = 0, nr_cpus = cpumask_weight(cpu_map);\n\tstruct perf_domain *pd = NULL, *tmp;\n\tint cpu = cpumask_first(cpu_map);\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\tstruct cpufreq_policy *policy;\n\tstruct cpufreq_governor *gov;\n\n\tif (!sysctl_sched_energy_aware)\n\t\tgoto free;\n\n\t/* EAS is enabled for asymmetric CPU capacity topologies. */\n\tif (!per_cpu(sd_asym_cpucapacity, cpu)) {\n\t\tif (sched_debug()) {\n\t\t\tpr_info(\"rd %*pbl: CPUs do not have asymmetric capacities\\n\",\n\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\t/* EAS definitely does *not* handle SMT */\n\tif (sched_smt_active()) {\n\t\tpr_warn(\"rd %*pbl: Disabling EAS, SMT is not supported\\n\",\n\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tif (!arch_scale_freq_invariant()) {\n\t\tif (sched_debug()) {\n\t\t\tpr_warn(\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\",\n\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\tfor_each_cpu(i, cpu_map) {\n\t\t/* Skip already covered CPUs. */\n\t\tif (find_pd(pd, i))\n\t\t\tcontinue;\n\n\t\t/* Do not attempt EAS if schedutil is not being used. */\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tgoto free;\n\t\tgov = policy->governor;\n\t\tcpufreq_cpu_put(policy);\n\t\tif (gov != &schedutil_gov) {\n\t\t\tif (rd->pd)\n\t\t\t\tpr_warn(\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t\tgoto free;\n\t\t}\n\n\t\t/* Create the new pd and add it to the local list. */\n\t\ttmp = pd_init(i);\n\t\tif (!tmp)\n\t\t\tgoto free;\n\t\ttmp->next = pd;\n\t\tpd = tmp;\n\n\t\t/*\n\t\t * Count performance domains and performance states for the\n\t\t * complexity check.\n\t\t */\n\t\tnr_pd++;\n\t\tnr_ps += em_pd_nr_perf_states(pd->em_pd);\n\t}\n\n\t/* Bail out if the Energy Model complexity is too high. */\n\tif (nr_pd * (nr_ps + nr_cpus) > EM_MAX_COMPLEXITY) {\n\t\tWARN(1, \"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tperf_domain_debug(cpu_map, pd);\n\n\t/* Attach the new list of performance domains to the root domain. */\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, pd);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn !!pd;\n\nfree:\n\tfree_pd(pd);\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, NULL);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define EM_MAX_COMPLEXITY 2048"
          ],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\n#define EM_MAX_COMPLEXITY 2048\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic bool build_perf_domains(const struct cpumask *cpu_map)\n{\n\tint i, nr_pd = 0, nr_ps = 0, nr_cpus = cpumask_weight(cpu_map);\n\tstruct perf_domain *pd = NULL, *tmp;\n\tint cpu = cpumask_first(cpu_map);\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\tstruct cpufreq_policy *policy;\n\tstruct cpufreq_governor *gov;\n\n\tif (!sysctl_sched_energy_aware)\n\t\tgoto free;\n\n\t/* EAS is enabled for asymmetric CPU capacity topologies. */\n\tif (!per_cpu(sd_asym_cpucapacity, cpu)) {\n\t\tif (sched_debug()) {\n\t\t\tpr_info(\"rd %*pbl: CPUs do not have asymmetric capacities\\n\",\n\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\t/* EAS definitely does *not* handle SMT */\n\tif (sched_smt_active()) {\n\t\tpr_warn(\"rd %*pbl: Disabling EAS, SMT is not supported\\n\",\n\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tif (!arch_scale_freq_invariant()) {\n\t\tif (sched_debug()) {\n\t\t\tpr_warn(\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\",\n\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\tfor_each_cpu(i, cpu_map) {\n\t\t/* Skip already covered CPUs. */\n\t\tif (find_pd(pd, i))\n\t\t\tcontinue;\n\n\t\t/* Do not attempt EAS if schedutil is not being used. */\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tgoto free;\n\t\tgov = policy->governor;\n\t\tcpufreq_cpu_put(policy);\n\t\tif (gov != &schedutil_gov) {\n\t\t\tif (rd->pd)\n\t\t\t\tpr_warn(\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t\tgoto free;\n\t\t}\n\n\t\t/* Create the new pd and add it to the local list. */\n\t\ttmp = pd_init(i);\n\t\tif (!tmp)\n\t\t\tgoto free;\n\t\ttmp->next = pd;\n\t\tpd = tmp;\n\n\t\t/*\n\t\t * Count performance domains and performance states for the\n\t\t * complexity check.\n\t\t */\n\t\tnr_pd++;\n\t\tnr_ps += em_pd_nr_perf_states(pd->em_pd);\n\t}\n\n\t/* Bail out if the Energy Model complexity is too high. */\n\tif (nr_pd * (nr_ps + nr_cpus) > EM_MAX_COMPLEXITY) {\n\t\tWARN(1, \"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tperf_domain_debug(cpu_map, pd);\n\n\t/* Attach the new list of performance domains to the root domain. */\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, pd);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn !!pd;\n\nfree:\n\tfree_pd(pd);\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, NULL);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpumask_first(doms_cur[j])"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "doms_cur[j]"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "doms_new[i]",
            "doms_cur[j]"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sched_domains",
          "args": [
            "doms_new[i]",
            "dattr_new ? dattr_new + i : NULL"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2191-2283",
          "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);",
            "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dattrs_equal",
          "args": [
            "dattr_new",
            "i",
            "dattr_cur",
            "j"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "dattrs_equal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2379-2393",
          "snippet": "static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "doms_new[i]",
            "doms_cur[j]"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_new[0]",
            "cpu_active_mask",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_destroy_domains",
          "args": [
            "doms_cur[i]"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "detach_destroy_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2364-2376",
          "snippet": "static void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tunsigned int cpu = cpumask_any(cpu_map);\n\tint i;\n\n\tif (rcu_access_pointer(per_cpu(sd_asym_cpucapacity, cpu)))\n\t\tstatic_branch_dec_cpuslocked(&sched_asym_cpucapacity);\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct root_domain def_root_domain;",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstruct root_domain def_root_domain;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tunsigned int cpu = cpumask_any(cpu_map);\n\tint i;\n\n\tif (rcu_access_pointer(per_cpu(sd_asym_cpucapacity, cpu)))\n\t\tstatic_branch_dec_cpuslocked(&sched_asym_cpucapacity);\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_clear_root_domain",
          "args": [
            "rd"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_root_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2516-2523",
          "snippet": "void dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "doms_cur[i]"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "doms_cur[i]",
            "doms_new[j]"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_new[0]",
            "cpu_active_mask",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sched_domains",
          "args": [
            "1"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2311-2326",
          "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dattr_new"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asym_cpu_capacity_scan",
          "args": [],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "asym_cpu_capacity_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1361-1388",
          "snippet": "static void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(asym_cap_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\n\nstatic void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_update_cpu_topology",
          "args": [],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "arch_update_cpu_topology",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2306-2309",
          "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}"
  },
  {
    "function_name": "dattrs_equal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2379-2393",
    "snippet": "static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cur ? (cur + idx_cur) : &tmp",
            "new ? (new + idx_new) : &tmp",
            "sizeof(struct sched_domain_attr)"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}"
  },
  {
    "function_name": "detach_destroy_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2364-2376",
    "snippet": "static void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tunsigned int cpu = cpumask_any(cpu_map);\n\tint i;\n\n\tif (rcu_access_pointer(per_cpu(sd_asym_cpucapacity, cpu)))\n\t\tstatic_branch_dec_cpuslocked(&sched_asym_cpucapacity);\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct root_domain def_root_domain;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_attach_domain",
          "args": [
            "NULL",
            "&def_root_domain",
            "i"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_attach_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "686-743",
          "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_dec_cpuslocked",
          "args": [
            "&sched_asym_cpucapacity"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "per_cpu(sd_asym_cpucapacity, cpu)"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sd_asym_cpucapacity",
            "cpu"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "cpu_map"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstruct root_domain def_root_domain;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tunsigned int cpu = cpumask_any(cpu_map);\n\tint i;\n\n\tif (rcu_access_pointer(per_cpu(sd_asym_cpucapacity, cpu)))\n\t\tstatic_branch_dec_cpuslocked(&sched_asym_cpucapacity);\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "sched_init_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2340-2358",
    "snippet": "int sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tasym_cpu_capacity_scan();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;",
      "static cpumask_var_t sched_domains_tmpmask2;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);",
      "static cpumask_var_t\t\t\t*doms_cur;",
      "static int\t\t\t\tndoms_cur;",
      "static cpumask_var_t\t\t\tfallback_doms;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_sched_domains",
          "args": [
            "doms_cur[0]",
            "NULL"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2191-2283",
          "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);",
            "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_cur[0]",
            "cpu_map",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_sched_domains",
          "args": [
            "ndoms_cur"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2311-2326",
          "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "asym_cpu_capacity_scan",
          "args": [],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "asym_cpu_capacity_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1361-1388",
          "snippet": "static void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(asym_cap_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\n\nstatic void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_update_cpu_topology",
          "args": [],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "arch_update_cpu_topology",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2306-2309",
          "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&fallback_doms",
            "GFP_KERNEL"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&sched_domains_tmpmask2",
            "GFP_KERNEL"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&sched_domains_tmpmask",
            "GFP_KERNEL"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\nstatic cpumask_var_t sched_domains_tmpmask2;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nint sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tasym_cpu_capacity_scan();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\n\treturn err;\n}"
  },
  {
    "function_name": "free_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2328-2334",
    "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "doms"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "doms[i]"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
  },
  {
    "function_name": "alloc_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2311-2326",
    "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sched_domains",
          "args": [
            "doms",
            "i"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2328-2334",
          "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&doms[i]",
            "GFP_KERNEL"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "ndoms",
            "sizeof(*doms)",
            "GFP_KERNEL"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
  },
  {
    "function_name": "arch_update_cpu_topology",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2306-2309",
    "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "build_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2191-2283",
    "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);",
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_domain_allocs",
          "args": [
            "&d",
            "alloc_state",
            "cpu_map"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "__free_domain_allocs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1428-1445",
          "snippet": "static void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\tfallthrough;\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\tfallthrough;\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\tfallthrough;\n\tcase sa_none:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\tfallthrough;\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\tfallthrough;\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\tfallthrough;\n\tcase sa_none:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\"",
            "cpumask_pr_args(cpu_map)",
            "rq->rd->max_cpu_capacity"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc_cpuslocked",
          "args": [
            "&sched_asym_cpucapacity"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_attach_domain",
          "args": [
            "sd",
            "d.rd",
            "i"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_attach_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "686-743",
          "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "d.rd->max_cpu_capacity",
            "rq->cpu_capacity_orig"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "d.rd->max_cpu_capacity"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sched_groups_capacity",
          "args": [
            "i",
            "sd"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "init_sched_groups_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1248-1278",
          "snippet": "static void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "claim_allocations",
          "args": [
            "i",
            "sd"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "claim_allocations",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1469-1484",
          "snippet": "static void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sched_groups",
          "args": [
            "sd",
            "i"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1202-1236",
          "snippet": "static int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_overlap_sched_groups",
          "args": [
            "sd",
            "i"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "build_overlap_sched_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "991-1083",
          "snippet": "static int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Usually we build sched_group by sibling's child sched_domain\n\t\t * But for machines whose NUMA diameter are 3 or above, we move\n\t\t * to build sched_group by sibling's proper descendant's child\n\t\t * domain because sibling's child sched_domain will span out of\n\t\t * the sched_domain being built as below.\n\t\t *\n\t\t * Smallest diameter=3 topology is:\n\t\t *\n\t\t *   node   0   1   2   3\n\t\t *     0:  10  20  30  40\n\t\t *     1:  20  10  20  30\n\t\t *     2:  30  20  10  20\n\t\t *     3:  40  30  20  10\n\t\t *\n\t\t *   0 --- 1 --- 2 --- 3\n\t\t *\n\t\t * NUMA-3       0-3             N/A             N/A             0-3\n\t\t *  groups:     {0-2},{1-3}                                     {1-3},{0-2}\n\t\t *\n\t\t * NUMA-2       0-2             0-3             0-3             1-3\n\t\t *  groups:     {0-1},{1-3}     {0-2},{2-3}     {1-3},{0-1}     {2-3},{0-2}\n\t\t *\n\t\t * NUMA-1       0-1             0-2             1-3             2-3\n\t\t *  groups:     {0},{1}         {1},{2},{0}     {2},{3},{1}     {3},{2}\n\t\t *\n\t\t * NUMA-0       0               1               2               3\n\t\t *\n\t\t * The NUMA-2 groups for nodes 0 and 3 are obviously buggered, as the\n\t\t * group span isn't a subset of the domain span.\n\t\t */\n\t\tif (sibling->child &&\n\t\t    !cpumask_subset(sched_domain_span(sibling->child), span))\n\t\t\tsibling = find_descended_sibling(sd, sibling);\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sibling, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Usually we build sched_group by sibling's child sched_domain\n\t\t * But for machines whose NUMA diameter are 3 or above, we move\n\t\t * to build sched_group by sibling's proper descendant's child\n\t\t * domain because sibling's child sched_domain will span out of\n\t\t * the sched_domain being built as below.\n\t\t *\n\t\t * Smallest diameter=3 topology is:\n\t\t *\n\t\t *   node   0   1   2   3\n\t\t *     0:  10  20  30  40\n\t\t *     1:  20  10  20  30\n\t\t *     2:  30  20  10  20\n\t\t *     3:  40  30  20  10\n\t\t *\n\t\t *   0 --- 1 --- 2 --- 3\n\t\t *\n\t\t * NUMA-3       0-3             N/A             N/A             0-3\n\t\t *  groups:     {0-2},{1-3}                                     {1-3},{0-2}\n\t\t *\n\t\t * NUMA-2       0-2             0-3             0-3             1-3\n\t\t *  groups:     {0-1},{1-3}     {0-2},{2-3}     {1-3},{0-1}     {2-3},{0-2}\n\t\t *\n\t\t * NUMA-1       0-1             0-2             1-3             2-3\n\t\t *  groups:     {0},{1}         {1},{2},{0}     {2},{3},{1}     {3},{2}\n\t\t *\n\t\t * NUMA-0       0               1               2               3\n\t\t *\n\t\t * The NUMA-2 groups for nodes 0 and 3 are obviously buggered, as the\n\t\t * group span isn't a subset of the domain span.\n\t\t */\n\t\tif (sibling->child &&\n\t\t    !cpumask_subset(sched_domain_span(sibling->child), span))\n\t\t\tsibling = find_descended_sibling(sd, sibling);\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sibling, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpu_map",
            "sched_domain_span(sd)"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sched_domain",
          "args": [
            "tl",
            "cpu_map",
            "attr",
            "sd",
            "i"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2121-2149",
          "snippet": "static struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sched_domain_level_max;",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint sched_domain_level_max;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!topology_span_sane(tl, cpu_map, i)"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topology_span_sane",
          "args": [
            "tl",
            "cpu_map",
            "i"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "topology_span_sane",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2155-2185",
          "snippet": "static bool topology_span_sane(struct sched_domain_topology_level *tl,\n\t\t\t      const struct cpumask *cpu_map, int cpu)\n{\n\tint i;\n\n\t/* NUMA levels are allowed to overlap */\n\tif (tl->flags & SDTL_OVERLAP)\n\t\treturn true;\n\n\t/*\n\t * Non-NUMA levels cannot partially overlap - they must be either\n\t * completely equal or completely disjoint. Otherwise we can end up\n\t * breaking the sched_group lists - i.e. a later get_group() pass\n\t * breaks the linking done for an earlier span.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We should 'and' all those masks with 'cpu_map' to exactly\n\t\t * match the topology we're about to build, but that can only\n\t\t * remove CPUs, which only lessens our ability to detect\n\t\t * overlaps\n\t\t */\n\t\tif (!cpumask_equal(tl->mask(cpu), tl->mask(i)) &&\n\t\t    cpumask_intersects(tl->mask(cpu), tl->mask(i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic bool topology_span_sane(struct sched_domain_topology_level *tl,\n\t\t\t      const struct cpumask *cpu_map, int cpu)\n{\n\tint i;\n\n\t/* NUMA levels are allowed to overlap */\n\tif (tl->flags & SDTL_OVERLAP)\n\t\treturn true;\n\n\t/*\n\t * Non-NUMA levels cannot partially overlap - they must be either\n\t * completely equal or completely disjoint. Otherwise we can end up\n\t * breaking the sched_group lists - i.e. a later get_group() pass\n\t * breaks the linking done for an earlier span.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We should 'and' all those masks with 'cpu_map' to exactly\n\t\t * match the topology we're about to build, but that can only\n\t\t * remove CPUs, which only lessens our ability to detect\n\t\t * overlaps\n\t\t */\n\t\tif (!cpumask_equal(tl->mask(cpu), tl->mask(i)) &&\n\t\t    cpumask_intersects(tl->mask(cpu), tl->mask(i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__visit_domain_allocation_hell",
          "args": [
            "&d",
            "cpu_map"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "__visit_domain_allocation_hell",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1447-1462",
          "snippet": "static enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpumask_empty(cpu_map)"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpu_map"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state = sa_none;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tbool has_asym = false;\n\n\tif (WARN_ON(cpumask_empty(cpu_map)))\n\t\tgoto error;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\n\t\t\tif (WARN_ON(!topology_span_sane(tl, cpu_map, i)))\n\t\t\t\tgoto error;\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, i);\n\n\t\t\thas_asym |= sd->flags & SD_ASYM_CPUCAPACITY;\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_inc_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_verbose) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "topology_span_sane",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2155-2185",
    "snippet": "static bool topology_span_sane(struct sched_domain_topology_level *tl,\n\t\t\t      const struct cpumask *cpu_map, int cpu)\n{\n\tint i;\n\n\t/* NUMA levels are allowed to overlap */\n\tif (tl->flags & SDTL_OVERLAP)\n\t\treturn true;\n\n\t/*\n\t * Non-NUMA levels cannot partially overlap - they must be either\n\t * completely equal or completely disjoint. Otherwise we can end up\n\t * breaking the sched_group lists - i.e. a later get_group() pass\n\t * breaks the linking done for an earlier span.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We should 'and' all those masks with 'cpu_map' to exactly\n\t\t * match the topology we're about to build, but that can only\n\t\t * remove CPUs, which only lessens our ability to detect\n\t\t * overlaps\n\t\t */\n\t\tif (!cpumask_equal(tl->mask(cpu), tl->mask(i)) &&\n\t\t    cpumask_intersects(tl->mask(cpu), tl->mask(i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "tl->mask(cpu)",
            "tl->mask(i)"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "i"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "tl->mask(cpu)",
            "tl->mask(i)"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "i"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic bool topology_span_sane(struct sched_domain_topology_level *tl,\n\t\t\t      const struct cpumask *cpu_map, int cpu)\n{\n\tint i;\n\n\t/* NUMA levels are allowed to overlap */\n\tif (tl->flags & SDTL_OVERLAP)\n\t\treturn true;\n\n\t/*\n\t * Non-NUMA levels cannot partially overlap - they must be either\n\t * completely equal or completely disjoint. Otherwise we can end up\n\t * breaking the sched_group lists - i.e. a later get_group() pass\n\t * breaks the linking done for an earlier span.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We should 'and' all those masks with 'cpu_map' to exactly\n\t\t * match the topology we're about to build, but that can only\n\t\t * remove CPUs, which only lessens our ability to detect\n\t\t * overlaps\n\t\t */\n\t\tif (!cpumask_equal(tl->mask(cpu), tl->mask(i)) &&\n\t\t    cpumask_intersects(tl->mask(cpu), tl->mask(i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "build_sched_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2121-2149",
    "snippet": "static struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sched_domain_level_max;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_domain_attribute",
          "args": [
            "sd",
            "attr"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "set_domain_attribute",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1407-1423",
          "snippet": "static void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\n\tif (sd->level > request) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int default_relax_domain_level = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\n\tif (sd->level > request) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "sched_domain_span(sd)",
            "sched_domain_span(sd)",
            "sched_domain_span(child)"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"     the %s domain not a subset of the %s domain\\n\"",
            "child->name",
            "sd->name"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: arch topology borken\\n\""
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "sched_domain_span(child)",
            "sched_domain_span(sd)"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sched_domain_level_max",
            "sd->level"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "254-257",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_init",
          "args": [
            "tl",
            "cpu_map",
            "child",
            "cpu"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "sd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1521-1631",
          "snippet": "static struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\tstruct cpumask *sd_span;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= TOPOLOGY_SD_FLAGS;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 16,\n\t\t.imbalance_pct\t\t= 117,\n\n\t\t.cache_nice_tries\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.last_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tsd_span = sched_domain_span(sd);\n\tcpumask_and(sd_span, cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sd_span);\n\n\tsd->flags |= asym_cpu_capacity_classify(sd_span, cpu_map);\n\n\tWARN_ONCE((sd->flags & (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)) ==\n\t\t  (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY),\n\t\t  \"CPU capacity asymmetry not supported on SMT\\n\");\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\t/* Don't attempt to spread across CPUs of different capacities. */\n\tif ((sd->flags & SD_ASYM_CPUCAPACITY) && sd->child)\n\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > node_reclaim_distance) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING)"
          ],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\n#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING)\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\tstruct cpumask *sd_span;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= TOPOLOGY_SD_FLAGS;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 16,\n\t\t.imbalance_pct\t\t= 117,\n\n\t\t.cache_nice_tries\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.last_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tsd_span = sched_domain_span(sd);\n\tcpumask_and(sd_span, cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sd_span);\n\n\tsd->flags |= asym_cpu_capacity_classify(sd_span, cpu_map);\n\n\tWARN_ONCE((sd->flags & (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)) ==\n\t\t  (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY),\n\t\t  \"CPU capacity asymmetry not supported on SMT\\n\");\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\t/* Don't attempt to spread across CPUs of different capacities. */\n\tif ((sd->flags & SD_ASYM_CPUCAPACITY) && sd->child)\n\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > node_reclaim_distance) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint sched_domain_level_max;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}"
  },
  {
    "function_name": "__sdt_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2085-2119",
    "snippet": "static void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sdd->sgc"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*per_cpu_ptr(sdd->sgc, j)"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "j"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "j"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "j"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "sd->groups",
            "0"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "584-602",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "j",
            "cpu_map"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}"
  },
  {
    "function_name": "__sdt_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2016-2083",
    "snippet": "static int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "j"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group_capacity) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "j"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "j"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_domain_shared)",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_domain) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "j",
            "cpu_map"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "struct sched_group_capacity *"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_numa_find_closest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "2002-2012",
    "snippet": "int sched_numa_find_closest(const struct cpumask *cpus, int cpu)\n{\n\tint i, j = cpu_to_node(cpu);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tcpu = cpumask_any_and(cpus, sched_domains_numa_masks[i][j]);\n\t\tif (cpu < nr_cpu_ids)\n\t\t\treturn cpu;\n\t}\n\treturn nr_cpu_ids;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpus",
            "sched_domains_numa_masks[i][j]"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint sched_numa_find_closest(const struct cpumask *cpus, int cpu)\n{\n\tint i, j = cpu_to_node(cpu);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tcpu = cpumask_any_and(cpus, sched_domains_numa_masks[i][j]);\n\t\tif (cpu < nr_cpu_ids)\n\t\t\treturn cpu;\n\t}\n\treturn nr_cpu_ids;\n}"
  },
  {
    "function_name": "sched_domains_numa_masks_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1984-1992",
    "snippet": "void sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "sched_domains_numa_masks[i][j]"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}"
  },
  {
    "function_name": "sched_domains_numa_masks_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1965-1982",
    "snippet": "void sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\t__sched_domains_numa_masks_set(node);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (!node_online(j))\n\t\t\t\tcontinue;\n\n\t\t\t/* Set ourselves in the remote node's masks */\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "sched_domains_numa_masks[i][j]"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "node"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "j"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_domains_numa_masks_set",
          "args": [
            "node"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\t__sched_domains_numa_masks_set(node);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (!node_online(j))\n\t\t\t\tcontinue;\n\n\t\t\t/* Set ourselves in the remote node's masks */\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "sched_init_numa",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1764-1963",
    "snippet": "void sched_init_numa(void)\n{\n\tstruct sched_domain_topology_level *tl;\n\tunsigned long *distance_map;\n\tint nr_levels = 0;\n\tint i, j;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t */\n\tdistance_map = bitmap_alloc(NR_DISTANCE_VALUES, GFP_KERNEL);\n\tif (!distance_map)\n\t\treturn;\n\n\tbitmap_zero(distance_map, NR_DISTANCE_VALUES);\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tint distance = node_distance(i, j);\n\n\t\t\tif (distance < LOCAL_DISTANCE || distance >= NR_DISTANCE_VALUES) {\n\t\t\t\tsched_numa_warn(\"Invalid distance value range\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbitmap_set(distance_map, distance, 1);\n\t\t}\n\t}\n\t/*\n\t * We can now figure out how many unique distance values there are and\n\t * allocate memory accordingly.\n\t */\n\tnr_levels = bitmap_weight(distance_map, NR_DISTANCE_VALUES);\n\n\tsched_domains_numa_distance = kcalloc(nr_levels, sizeof(int), GFP_KERNEL);\n\tif (!sched_domains_numa_distance) {\n\t\tbitmap_free(distance_map);\n\t\treturn;\n\t}\n\n\tfor (i = 0, j = 0; i < nr_levels; i++, j++) {\n\t\tj = find_next_bit(distance_map, NR_DISTANCE_VALUES, j);\n\t\tsched_domains_numa_distance[i] = j;\n\t}\n\n\tbitmap_free(distance_map);\n\n\t/*\n\t * 'nr_levels' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'nr_levels' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'nr_levels' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * nr_levels, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < nr_levels; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tint k;\n\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\t/*\n\t\t\t\t * Distance information can be unreliable for\n\t\t\t\t * offline nodes, defer building the node\n\t\t\t\t * masks to its bringup.\n\t\t\t\t * This relies on all unique distance values\n\t\t\t\t * still being visible at init time.\n\t\t\t\t */\n\t\t\t\tif (!node_online(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (sched_debug() && (node_distance(j, k) != node_distance(k, j)))\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + nr_levels + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < nr_levels; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = nr_levels;\n\tsched_max_numa_distance = sched_domains_numa_distance[nr_levels - 1];\n\n\tinit_numa_topology_type();\n\n\tsched_numa_onlined_nodes = bitmap_alloc(nr_node_ids, GFP_KERNEL);\n\tif (!sched_numa_onlined_nodes)\n\t\treturn;\n\n\tbitmap_zero(sched_numa_onlined_nodes, nr_node_ids);\n\tfor_each_online_node(i)\n\t\tbitmap_set(sched_numa_onlined_nodes, i, 1);\n}\n\nstatic void __sched_domains_numa_masks_set(unsigned int node)\n{\n\tint i, j;\n\n\t/*\n\t * NUMA masks are not built for offline nodes in sched_init_numa().\n\t * Thus, when a CPU of a never-onlined-before node gets plugged in,\n\t * adding that new CPU to the right NUMA masks is not sufficient: the\n\t * masks of that CPU's node must also be updated.\n\t */\n\tif (test_bit(node, sched_numa_onlined_nodes))\n\t\treturn;\n\n\tbitmap_set(sched_numa_onlined_nodes, node, 1);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (!node_online(j) || node == j)\n\t\t\t\tcontinue;\n\n\t\t\tif (node_distance(j, node) > sched_domains_numa_distance[i])\n\t\t\t\tcontinue;\n\n\t\t\t/* Add remote nodes in our masks */\n\t\t\tcpumask_or(sched_domains_numa_masks[i][node],\n\t\t\t\t   sched_domains_numa_masks[i][node],\n\t\t\t\t   sched_domains_numa_masks[0][j]);\n\t\t}\n\t}\n\n\t/*\n\t * A new node has been brought up, potentially changing the topology\n\t * classification.\n\t *\n\t * Note that this is racy vs any use of sched_numa_topology_type :/\n\t */\n\tinit_numa_topology_type();\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define NR_DISTANCE_VALUES (1 << DISTANCE_BITS)"
    ],
    "globals_used": [
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_numa_topology_type",
          "args": [],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "init_numa_topology_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1728-1759",
          "snippet": "static void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "sched_domains_numa_masks[i][node]",
            "sched_domains_numa_masks[i][node]",
            "sched_domains_numa_masks[0][j]"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "node"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "j"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "sched_numa_onlined_nodes",
            "nr_node_ids"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_alloc",
          "args": [
            "nr_node_ids",
            "GFP_KERNEL"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SD_INIT_NAME",
          "args": [
            "NUMA"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SD_INIT_NAME",
          "args": [
            "NODE"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "(i + nr_levels + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level)",
            "GFP_KERNEL"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "mask",
            "mask",
            "cpumask_of_node(k)"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "k"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "k"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_numa_warn",
          "args": [
            "\"Node-distance not symmetric\""
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "sched_numa_warn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1673-1692",
          "snippet": "static void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "k",
            "j"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "k"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "157-160",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "j"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "cpumask_size()",
            "GFP_KERNEL"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nr_node_ids * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(void *) * nr_levels",
            "GFP_KERNEL"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "distance_map"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "distance_map",
            "NR_DISTANCE_VALUES",
            "j"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "distance_map"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_levels",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "distance_map",
            "NR_DISTANCE_VALUES"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "distance_map",
            "distance",
            "1"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "i",
            "j"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "distance_map",
            "NR_DISTANCE_VALUES"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_alloc",
          "args": [
            "NR_DISTANCE_VALUES",
            "GFP_KERNEL"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\n#define NR_DISTANCE_VALUES (1 << DISTANCE_BITS)\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nvoid sched_init_numa(void)\n{\n\tstruct sched_domain_topology_level *tl;\n\tunsigned long *distance_map;\n\tint nr_levels = 0;\n\tint i, j;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t */\n\tdistance_map = bitmap_alloc(NR_DISTANCE_VALUES, GFP_KERNEL);\n\tif (!distance_map)\n\t\treturn;\n\n\tbitmap_zero(distance_map, NR_DISTANCE_VALUES);\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tint distance = node_distance(i, j);\n\n\t\t\tif (distance < LOCAL_DISTANCE || distance >= NR_DISTANCE_VALUES) {\n\t\t\t\tsched_numa_warn(\"Invalid distance value range\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbitmap_set(distance_map, distance, 1);\n\t\t}\n\t}\n\t/*\n\t * We can now figure out how many unique distance values there are and\n\t * allocate memory accordingly.\n\t */\n\tnr_levels = bitmap_weight(distance_map, NR_DISTANCE_VALUES);\n\n\tsched_domains_numa_distance = kcalloc(nr_levels, sizeof(int), GFP_KERNEL);\n\tif (!sched_domains_numa_distance) {\n\t\tbitmap_free(distance_map);\n\t\treturn;\n\t}\n\n\tfor (i = 0, j = 0; i < nr_levels; i++, j++) {\n\t\tj = find_next_bit(distance_map, NR_DISTANCE_VALUES, j);\n\t\tsched_domains_numa_distance[i] = j;\n\t}\n\n\tbitmap_free(distance_map);\n\n\t/*\n\t * 'nr_levels' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'nr_levels' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'nr_levels' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * nr_levels, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < nr_levels; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tint k;\n\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\t/*\n\t\t\t\t * Distance information can be unreliable for\n\t\t\t\t * offline nodes, defer building the node\n\t\t\t\t * masks to its bringup.\n\t\t\t\t * This relies on all unique distance values\n\t\t\t\t * still being visible at init time.\n\t\t\t\t */\n\t\t\t\tif (!node_online(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (sched_debug() && (node_distance(j, k) != node_distance(k, j)))\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + nr_levels + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < nr_levels; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = nr_levels;\n\tsched_max_numa_distance = sched_domains_numa_distance[nr_levels - 1];\n\n\tinit_numa_topology_type();\n\n\tsched_numa_onlined_nodes = bitmap_alloc(nr_node_ids, GFP_KERNEL);\n\tif (!sched_numa_onlined_nodes)\n\t\treturn;\n\n\tbitmap_zero(sched_numa_onlined_nodes, nr_node_ids);\n\tfor_each_online_node(i)\n\t\tbitmap_set(sched_numa_onlined_nodes, i, 1);\n}\n\nstatic void __sched_domains_numa_masks_set(unsigned int node)\n{\n\tint i, j;\n\n\t/*\n\t * NUMA masks are not built for offline nodes in sched_init_numa().\n\t * Thus, when a CPU of a never-onlined-before node gets plugged in,\n\t * adding that new CPU to the right NUMA masks is not sufficient: the\n\t * masks of that CPU's node must also be updated.\n\t */\n\tif (test_bit(node, sched_numa_onlined_nodes))\n\t\treturn;\n\n\tbitmap_set(sched_numa_onlined_nodes, node, 1);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (!node_online(j) || node == j)\n\t\t\t\tcontinue;\n\n\t\t\tif (node_distance(j, node) > sched_domains_numa_distance[i])\n\t\t\t\tcontinue;\n\n\t\t\t/* Add remote nodes in our masks */\n\t\t\tcpumask_or(sched_domains_numa_masks[i][node],\n\t\t\t\t   sched_domains_numa_masks[i][node],\n\t\t\t\t   sched_domains_numa_masks[0][j]);\n\t\t}\n\t}\n\n\t/*\n\t * A new node has been brought up, potentially changing the topology\n\t * classification.\n\t *\n\t * Note that this is racy vs any use of sched_numa_topology_type :/\n\t */\n\tinit_numa_topology_type();\n}"
  },
  {
    "function_name": "init_numa_topology_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1728-1759",
    "snippet": "static void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "b",
            "c"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "a",
            "c"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "a",
            "b"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "find_numa_distance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1694-1707",
    "snippet": "bool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "0",
            "0"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "sched_numa_warn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1673-1692",
    "snippet": "static void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"\\n\""
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%02d \"",
            "node_distance(i,j)"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "i",
            "j"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}"
  },
  {
    "function_name": "sd_numa_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1668-1671",
    "snippet": "static const struct cpumask *sd_numa_mask(int cpu)\n{\n\treturn sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const struct cpumask *sd_numa_mask(int cpu)\n{\n\treturn sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];\n}"
  },
  {
    "function_name": "set_sched_topology",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1658-1664",
    "snippet": "void set_sched_topology(struct sched_domain_topology_level *tl)\n{\n\tif (WARN_ON_ONCE(sched_smp_initialized))\n\t\treturn;\n\n\tsched_domain_topology = tl;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sched_smp_initialized"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nvoid set_sched_topology(struct sched_domain_topology_level *tl)\n{\n\tif (WARN_ON_ONCE(sched_smp_initialized))\n\t\treturn;\n\n\tsched_domain_topology = tl;\n}"
  },
  {
    "function_name": "sd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1521-1631",
    "snippet": "static struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\tstruct cpumask *sd_span;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= TOPOLOGY_SD_FLAGS;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 16,\n\t\t.imbalance_pct\t\t= 117,\n\n\t\t.cache_nice_tries\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.last_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tsd_span = sched_domain_span(sd);\n\tcpumask_and(sd_span, cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sd_span);\n\n\tsd->flags |= asym_cpu_capacity_classify(sd_span, cpu_map);\n\n\tWARN_ONCE((sd->flags & (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)) ==\n\t\t  (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY),\n\t\t  \"CPU capacity asymmetry not supported on SMT\\n\");\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\t/* Don't attempt to spread across CPUs of different capacities. */\n\tif ((sd->flags & SD_ASYM_CPUCAPACITY) && sd->child)\n\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > node_reclaim_distance) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING)"
    ],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sd->shared->nr_busy_cpus",
            "sd_weight"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sd->shared->ref"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "sd_id"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "(sd->flags & (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)) ==\n\t\t  (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)",
            "\"CPU capacity asymmetry not supported on SMT\\n\""
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asym_cpu_capacity_classify",
          "args": [
            "sd_span",
            "cpu_map"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "asym_cpu_capacity_classify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1303-1335",
          "snippet": "static inline int\nasym_cpu_capacity_classify(const struct cpumask *sd_span,\n\t\t\t   const struct cpumask *cpu_map)\n{\n\tstruct asym_cap_data *entry;\n\tint count = 0, miss = 0;\n\n\t/*\n\t * Count how many unique CPU capacities this domain spans across\n\t * (compare sched_domain CPUs mask with ones representing  available\n\t * CPUs capacities). Take into account CPUs that might be offline:\n\t * skip those.\n\t */\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (cpumask_intersects(sd_span, cpu_capacity_span(entry)))\n\t\t\t++count;\n\t\telse if (cpumask_intersects(cpu_map, cpu_capacity_span(entry)))\n\t\t\t++miss;\n\t}\n\n\tWARN_ON_ONCE(!count && !list_empty(&asym_cap_list));\n\n\t/* No asymmetry detected */\n\tif (count < 2)\n\t\treturn 0;\n\t/* Some of the available CPU capacity values have not been detected */\n\tif (miss)\n\t\treturn SD_ASYM_CPUCAPACITY;\n\n\t/* Full asymmetry */\n\treturn SD_ASYM_CPUCAPACITY | SD_ASYM_CPUCAPACITY_FULL;\n\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(asym_cap_list);",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic inline int\nasym_cpu_capacity_classify(const struct cpumask *sd_span,\n\t\t\t   const struct cpumask *cpu_map)\n{\n\tstruct asym_cap_data *entry;\n\tint count = 0, miss = 0;\n\n\t/*\n\t * Count how many unique CPU capacities this domain spans across\n\t * (compare sched_domain CPUs mask with ones representing  available\n\t * CPUs capacities). Take into account CPUs that might be offline:\n\t * skip those.\n\t */\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (cpumask_intersects(sd_span, cpu_capacity_span(entry)))\n\t\t\t++count;\n\t\telse if (cpumask_intersects(cpu_map, cpu_capacity_span(entry)))\n\t\t\t++miss;\n\t}\n\n\tWARN_ON_ONCE(!count && !list_empty(&asym_cap_list));\n\n\t/* No asymmetry detected */\n\tif (count < 2)\n\t\treturn 0;\n\t/* Some of the available CPU capacity values have not been detected */\n\tif (miss)\n\t\treturn SD_ASYM_CPUCAPACITY;\n\n\t/* Full asymmetry */\n\treturn SD_ASYM_CPUCAPACITY | SD_ASYM_CPUCAPACITY_FULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sd_span"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "sd_span",
            "cpu_map",
            "tl->mask(cpu)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "sd_flags & ~TOPOLOGY_SD_FLAGS",
            "\"wrong sd_flags in topology description\\n\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "tl->mask(cpu)"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\n#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING)\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\tstruct cpumask *sd_span;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= TOPOLOGY_SD_FLAGS;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 16,\n\t\t.imbalance_pct\t\t= 117,\n\n\t\t.cache_nice_tries\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.last_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tsd_span = sched_domain_span(sd);\n\tcpumask_and(sd_span, cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sd_span);\n\n\tsd->flags |= asym_cpu_capacity_classify(sd_span, cpu_map);\n\n\tWARN_ONCE((sd->flags & (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY)) ==\n\t\t  (SD_SHARE_CPUCAPACITY | SD_ASYM_CPUCAPACITY),\n\t\t  \"CPU capacity asymmetry not supported on SMT\\n\");\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\t/* Don't attempt to spread across CPUs of different capacities. */\n\tif ((sd->flags & SD_ASYM_CPUCAPACITY) && sd->child)\n\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > node_reclaim_distance) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}"
  },
  {
    "function_name": "claim_allocations",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1469-1484",
    "snippet": "static void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sgc, cpu))->ref"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sg, cpu))->ref"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "cpu"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sds, cpu))->ref"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "cpu"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*per_cpu_ptr(sdd->sd, cpu) != sd"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}"
  },
  {
    "function_name": "__visit_domain_allocation_hell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1447-1462",
    "snippet": "static enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_rootdomain",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rootdomain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "568-582",
          "snippet": "static struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "struct sched_domain *"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sdt_alloc",
          "args": [
            "cpu_map"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "__sdt_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2016-2083",
          "snippet": "static int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(*d)"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}"
  },
  {
    "function_name": "__free_domain_allocs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1428-1445",
    "snippet": "static void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\tfallthrough;\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\tfallthrough;\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\tfallthrough;\n\tcase sa_none:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sdt_free",
          "args": [
            "cpu_map"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "__sdt_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2085-2119",
          "snippet": "static void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "d->sd"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rootdomain",
          "args": [
            "&d->rd->rcu"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "free_rootdomain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "451-463",
          "snippet": "static void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tfree_pd(rd->pd);\n\tkfree(rd);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tfree_pd(rd->pd);\n\tkfree(rd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->rd->refcount"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\tfallthrough;\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\tfallthrough;\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\tfallthrough;\n\tcase sa_none:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "set_domain_attribute",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1407-1423",
    "snippet": "static void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\n\tif (sd->level > request) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int default_relax_domain_level = -1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\n\tif (sd->level > request) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}"
  },
  {
    "function_name": "setup_relax_domain_level",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1398-1404",
    "snippet": "static int __init setup_relax_domain_level(char *str)\n{\n\tif (kstrtoint(str, 0, &default_relax_domain_level))\n\t\tpr_warn(\"Unable to set relax_domain_level\\n\");\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int default_relax_domain_level = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to set relax_domain_level\\n\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "str",
            "0",
            "&default_relax_domain_level"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic int __init setup_relax_domain_level(char *str)\n{\n\tif (kstrtoint(str, 0, &default_relax_domain_level))\n\t\tpr_warn(\"Unable to set relax_domain_level\\n\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "asym_cpu_capacity_scan",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1361-1388",
    "snippet": "static void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(asym_cap_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->link"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&asym_cap_list",
            "typeof(*entry)",
            "link"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&asym_cap_list"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpu_capacity_span(entry)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_capacity_span",
          "args": [
            "entry"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "next",
            "&asym_cap_list",
            "link"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asym_cpu_capacity_update_data",
          "args": [
            "cpu"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "asym_cpu_capacity_update_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1337-1354",
          "snippet": "static inline void asym_cpu_capacity_update_data(int cpu)\n{\n\tunsigned long capacity = arch_scale_cpu_capacity(cpu);\n\tstruct asym_cap_data *entry = NULL;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (capacity == entry->capacity)\n\t\t\tgoto done;\n\t}\n\n\tentry = kzalloc(sizeof(*entry) + cpumask_size(), GFP_KERNEL);\n\tif (WARN_ONCE(!entry, \"Failed to allocate memory for asymmetry data\\n\"))\n\t\treturn;\n\tentry->capacity = capacity;\n\tlist_add(&entry->link, &asym_cap_list);\ndone:\n\t__cpumask_set_cpu(cpu, cpu_capacity_span(entry));\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(asym_cap_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\n\nstatic inline void asym_cpu_capacity_update_data(int cpu)\n{\n\tunsigned long capacity = arch_scale_cpu_capacity(cpu);\n\tstruct asym_cap_data *entry = NULL;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (capacity == entry->capacity)\n\t\t\tgoto done;\n\t}\n\n\tentry = kzalloc(sizeof(*entry) + cpumask_size(), GFP_KERNEL);\n\tif (WARN_ONCE(!entry, \"Failed to allocate memory for asymmetry data\\n\"))\n\t\treturn;\n\tentry->capacity = capacity;\n\tlist_add(&entry->link, &asym_cap_list);\ndone:\n\t__cpumask_set_cpu(cpu, cpu_capacity_span(entry));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "cpu",
            "cpu_possible_mask",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cpu_capacity_span(entry)"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_capacity_span",
          "args": [
            "entry"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&asym_cap_list",
            "link"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\n\nstatic void asym_cpu_capacity_scan(void)\n{\n\tstruct asym_cap_data *entry, *next;\n\tint cpu;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link)\n\t\tcpumask_clear(cpu_capacity_span(entry));\n\n\tfor_each_cpu_and(cpu, cpu_possible_mask, housekeeping_cpumask(HK_FLAG_DOMAIN))\n\t\tasym_cpu_capacity_update_data(cpu);\n\n\tlist_for_each_entry_safe(entry, next, &asym_cap_list, link) {\n\t\tif (cpumask_empty(cpu_capacity_span(entry))) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\n\t/*\n\t * Only one capacity value has been detected i.e. this system is symmetric.\n\t * No need to keep this data around.\n\t */\n\tif (list_is_singular(&asym_cap_list)) {\n\t\tentry = list_first_entry(&asym_cap_list, typeof(*entry), link);\n\t\tlist_del(&entry->link);\n\t\tkfree(entry);\n\t}\n}"
  },
  {
    "function_name": "asym_cpu_capacity_update_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1337-1354",
    "snippet": "static inline void asym_cpu_capacity_update_data(int cpu)\n{\n\tunsigned long capacity = arch_scale_cpu_capacity(cpu);\n\tstruct asym_cap_data *entry = NULL;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (capacity == entry->capacity)\n\t\t\tgoto done;\n\t}\n\n\tentry = kzalloc(sizeof(*entry) + cpumask_size(), GFP_KERNEL);\n\tif (WARN_ONCE(!entry, \"Failed to allocate memory for asymmetry data\\n\"))\n\t\treturn;\n\tentry->capacity = capacity;\n\tlist_add(&entry->link, &asym_cap_list);\ndone:\n\t__cpumask_set_cpu(cpu, cpu_capacity_span(entry));\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(asym_cap_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cpumask_set_cpu",
          "args": [
            "cpu",
            "cpu_capacity_span(entry)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_capacity_span",
          "args": [
            "entry"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->link",
            "&asym_cap_list"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!entry",
            "\"Failed to allocate memory for asymmetry data\\n\""
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry) + cpumask_size()",
            "GFP_KERNEL"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&asym_cap_list",
            "link"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "cpu"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\n\nstatic inline void asym_cpu_capacity_update_data(int cpu)\n{\n\tunsigned long capacity = arch_scale_cpu_capacity(cpu);\n\tstruct asym_cap_data *entry = NULL;\n\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (capacity == entry->capacity)\n\t\t\tgoto done;\n\t}\n\n\tentry = kzalloc(sizeof(*entry) + cpumask_size(), GFP_KERNEL);\n\tif (WARN_ONCE(!entry, \"Failed to allocate memory for asymmetry data\\n\"))\n\t\treturn;\n\tentry->capacity = capacity;\n\tlist_add(&entry->link, &asym_cap_list);\ndone:\n\t__cpumask_set_cpu(cpu, cpu_capacity_span(entry));\n}"
  },
  {
    "function_name": "asym_cpu_capacity_classify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1303-1335",
    "snippet": "static inline int\nasym_cpu_capacity_classify(const struct cpumask *sd_span,\n\t\t\t   const struct cpumask *cpu_map)\n{\n\tstruct asym_cap_data *entry;\n\tint count = 0, miss = 0;\n\n\t/*\n\t * Count how many unique CPU capacities this domain spans across\n\t * (compare sched_domain CPUs mask with ones representing  available\n\t * CPUs capacities). Take into account CPUs that might be offline:\n\t * skip those.\n\t */\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (cpumask_intersects(sd_span, cpu_capacity_span(entry)))\n\t\t\t++count;\n\t\telse if (cpumask_intersects(cpu_map, cpu_capacity_span(entry)))\n\t\t\t++miss;\n\t}\n\n\tWARN_ON_ONCE(!count && !list_empty(&asym_cap_list));\n\n\t/* No asymmetry detected */\n\tif (count < 2)\n\t\treturn 0;\n\t/* Some of the available CPU capacity values have not been detected */\n\tif (miss)\n\t\treturn SD_ASYM_CPUCAPACITY;\n\n\t/* Full asymmetry */\n\treturn SD_ASYM_CPUCAPACITY | SD_ASYM_CPUCAPACITY_FULL;\n\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(asym_cap_list);",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!count && !list_empty(&asym_cap_list)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&asym_cap_list"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "cpu_map",
            "cpu_capacity_span(entry)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_capacity_span",
          "args": [
            "entry"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "sd_span",
            "cpu_capacity_span(entry)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_capacity_span",
          "args": [
            "entry"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&asym_cap_list",
            "link"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic LIST_HEAD(asym_cap_list);\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic inline int\nasym_cpu_capacity_classify(const struct cpumask *sd_span,\n\t\t\t   const struct cpumask *cpu_map)\n{\n\tstruct asym_cap_data *entry;\n\tint count = 0, miss = 0;\n\n\t/*\n\t * Count how many unique CPU capacities this domain spans across\n\t * (compare sched_domain CPUs mask with ones representing  available\n\t * CPUs capacities). Take into account CPUs that might be offline:\n\t * skip those.\n\t */\n\tlist_for_each_entry(entry, &asym_cap_list, link) {\n\t\tif (cpumask_intersects(sd_span, cpu_capacity_span(entry)))\n\t\t\t++count;\n\t\telse if (cpumask_intersects(cpu_map, cpu_capacity_span(entry)))\n\t\t\t++miss;\n\t}\n\n\tWARN_ON_ONCE(!count && !list_empty(&asym_cap_list));\n\n\t/* No asymmetry detected */\n\tif (count < 2)\n\t\treturn 0;\n\t/* Some of the available CPU capacity values have not been detected */\n\tif (miss)\n\t\treturn SD_ASYM_CPUCAPACITY;\n\n\t/* Full asymmetry */\n\treturn SD_ASYM_CPUCAPACITY | SD_ASYM_CPUCAPACITY_FULL;\n\n}"
  },
  {
    "function_name": "init_sched_groups_capacity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1248-1278",
    "snippet": "static void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_group_capacity",
          "args": [
            "sd",
            "cpu"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "update_group_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "8331-8384",
          "snippet": "void update_group_capacity(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *group, *sdg = sd->groups;\n\tunsigned long capacity, min_capacity, max_capacity;\n\tunsigned long interval;\n\n\tinterval = msecs_to_jiffies(sd->balance_interval);\n\tinterval = clamp(interval, 1UL, max_load_balance_interval);\n\tsdg->sgc->next_update = jiffies + interval;\n\n\tif (!child) {\n\t\tupdate_cpu_capacity(sd, cpu);\n\t\treturn;\n\t}\n\n\tcapacity = 0;\n\tmin_capacity = ULONG_MAX;\n\tmax_capacity = 0;\n\n\tif (child->flags & SD_OVERLAP) {\n\t\t/*\n\t\t * SD_OVERLAP domains cannot assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tfor_each_cpu(cpu, sched_group_span(sdg)) {\n\t\t\tunsigned long cpu_cap = capacity_of(cpu);\n\n\t\t\tcapacity += cpu_cap;\n\t\t\tmin_capacity = min(cpu_cap, min_capacity);\n\t\t\tmax_capacity = max(cpu_cap, max_capacity);\n\t\t}\n\t} else  {\n\t\t/*\n\t\t * !SD_OVERLAP domains can assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tgroup = child->groups;\n\t\tdo {\n\t\t\tstruct sched_group_capacity *sgc = group->sgc;\n\n\t\t\tcapacity += sgc->capacity;\n\t\t\tmin_capacity = min(sgc->min_capacity, min_capacity);\n\t\t\tmax_capacity = max(sgc->max_capacity, max_capacity);\n\t\t\tgroup = group->next;\n\t\t} while (group != child->groups);\n\t}\n\n\tsdg->sgc->capacity = capacity;\n\tsdg->sgc->min_capacity = min_capacity;\n\tsdg->sgc->max_capacity = max_capacity;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid update_group_capacity(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *group, *sdg = sd->groups;\n\tunsigned long capacity, min_capacity, max_capacity;\n\tunsigned long interval;\n\n\tinterval = msecs_to_jiffies(sd->balance_interval);\n\tinterval = clamp(interval, 1UL, max_load_balance_interval);\n\tsdg->sgc->next_update = jiffies + interval;\n\n\tif (!child) {\n\t\tupdate_cpu_capacity(sd, cpu);\n\t\treturn;\n\t}\n\n\tcapacity = 0;\n\tmin_capacity = ULONG_MAX;\n\tmax_capacity = 0;\n\n\tif (child->flags & SD_OVERLAP) {\n\t\t/*\n\t\t * SD_OVERLAP domains cannot assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tfor_each_cpu(cpu, sched_group_span(sdg)) {\n\t\t\tunsigned long cpu_cap = capacity_of(cpu);\n\n\t\t\tcapacity += cpu_cap;\n\t\t\tmin_capacity = min(cpu_cap, min_capacity);\n\t\t\tmax_capacity = max(cpu_cap, max_capacity);\n\t\t}\n\t} else  {\n\t\t/*\n\t\t * !SD_OVERLAP domains can assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tgroup = child->groups;\n\t\tdo {\n\t\t\tstruct sched_group_capacity *sgc = group->sgc;\n\n\t\t\tcapacity += sgc->capacity;\n\t\t\tmin_capacity = min(sgc->min_capacity, min_capacity);\n\t\t\tmax_capacity = max(sgc->max_capacity, max_capacity);\n\t\t\tgroup = group->next;\n\t\t} while (group != child->groups);\n\t}\n\n\tsdg->sgc->capacity = capacity;\n\tsdg->sgc->min_capacity = min_capacity;\n\tsdg->sgc->max_capacity = max_capacity;\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_balance_cpu",
          "args": [
            "sg"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "766-769",
          "snippet": "int group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_asym_prefer",
          "args": [
            "cpu",
            "max_cpu"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "sched_asym_prefer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "777-780",
          "snippet": "static inline bool sched_asym_prefer(int a, int b)\n{\n\treturn arch_asym_cpu_priority(a) > arch_asym_cpu_priority(b);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool sched_asym_prefer(int a, int b)\n{\n\treturn arch_asym_cpu_priority(a) > arch_asym_cpu_priority(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "sched_group_span(sg)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(sg)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sg"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}"
  },
  {
    "function_name": "build_sched_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1202-1236",
    "snippet": "static int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "covered",
            "covered",
            "sched_group_span(sg)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_group",
          "args": [
            "i",
            "sdd"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "get_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "1157-1193",
          "snippet": "static struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\tbool already_visited;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* Increase refcounts for claim_allocations: */\n\talready_visited = atomic_inc_return(&sg->ref) > 1;\n\t/* sgc visits should follow a similar trend as sg */\n\tWARN_ON(already_visited != (atomic_inc_return(&sg->sgc->ref) > 1));\n\n\t/* If we have already visited that group, it's already initialized. */\n\tif (already_visited)\n\t\treturn sg;\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t\tsg->flags = child->flags;\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\tbool already_visited;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* Increase refcounts for claim_allocations: */\n\talready_visited = atomic_inc_return(&sg->ref) > 1;\n\t/* sgc visits should follow a similar trend as sg */\n\tWARN_ON(already_visited != (atomic_inc_return(&sg->sgc->ref) > 1));\n\n\t/* If we have already visited that group, it's already initialized. */\n\tif (already_visited)\n\t\treturn sg;\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t\tsg->flags = child->flags;\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "covered"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_wrap",
          "args": [
            "i",
            "span",
            "cpu"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "covered"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "1157-1193",
    "snippet": "static struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\tbool already_visited;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* Increase refcounts for claim_allocations: */\n\talready_visited = atomic_inc_return(&sg->ref) > 1;\n\t/* sgc visits should follow a similar trend as sg */\n\tWARN_ON(already_visited != (atomic_inc_return(&sg->sgc->ref) > 1));\n\n\t/* If we have already visited that group, it's already initialized. */\n\tif (already_visited)\n\t\treturn sg;\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t\tsg->flags = child->flags;\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(sg)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "group_balance_mask(sg)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1820-1823",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "sched_group_span(sg)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "group_balance_mask(sg)",
            "sched_group_span(sg)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sched_group_span(sg)",
            "sched_domain_span(child)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "already_visited != (atomic_inc_return(&sg->sgc->ref) > 1)"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&sg->ref"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sched_domain_span(child)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\tbool already_visited;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* Increase refcounts for claim_allocations: */\n\talready_visited = atomic_inc_return(&sg->ref) > 1;\n\t/* sgc visits should follow a similar trend as sg */\n\tWARN_ON(already_visited != (atomic_inc_return(&sg->sgc->ref) > 1));\n\n\t/* If we have already visited that group, it's already initialized. */\n\tif (already_visited)\n\t\treturn sg;\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t\tsg->flags = child->flags;\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}"
  },
  {
    "function_name": "build_overlap_sched_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "991-1083",
    "snippet": "static int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Usually we build sched_group by sibling's child sched_domain\n\t\t * But for machines whose NUMA diameter are 3 or above, we move\n\t\t * to build sched_group by sibling's proper descendant's child\n\t\t * domain because sibling's child sched_domain will span out of\n\t\t * the sched_domain being built as below.\n\t\t *\n\t\t * Smallest diameter=3 topology is:\n\t\t *\n\t\t *   node   0   1   2   3\n\t\t *     0:  10  20  30  40\n\t\t *     1:  20  10  20  30\n\t\t *     2:  30  20  10  20\n\t\t *     3:  40  30  20  10\n\t\t *\n\t\t *   0 --- 1 --- 2 --- 3\n\t\t *\n\t\t * NUMA-3       0-3             N/A             N/A             0-3\n\t\t *  groups:     {0-2},{1-3}                                     {1-3},{0-2}\n\t\t *\n\t\t * NUMA-2       0-2             0-3             0-3             1-3\n\t\t *  groups:     {0-1},{1-3}     {0-2},{2-3}     {1-3},{0-1}     {2-3},{0-2}\n\t\t *\n\t\t * NUMA-1       0-1             0-2             1-3             2-3\n\t\t *  groups:     {0},{1}         {1},{2},{0}     {2},{3},{1}     {3},{2}\n\t\t *\n\t\t * NUMA-0       0               1               2               3\n\t\t *\n\t\t * The NUMA-2 groups for nodes 0 and 3 are obviously buggered, as the\n\t\t * group span isn't a subset of the domain span.\n\t\t */\n\t\tif (sibling->child &&\n\t\t    !cpumask_subset(sched_domain_span(sibling->child), span))\n\t\t\tsibling = find_descended_sibling(sd, sibling);\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sibling, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "first",
            "0"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "584-602",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_overlap_sched_group",
          "args": [
            "sibling",
            "sg"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "init_overlap_sched_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "938-964",
          "snippet": "static void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first(mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask2;\n\nstatic void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first(mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "covered",
            "covered",
            "sg_span"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_group_from_child_sched_domain",
          "args": [
            "sibling",
            "cpu"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "build_group_from_child_sched_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "914-936",
          "snippet": "static struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child) {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\t\tsg->flags = sd->child->flags;\n\t} else {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\t}\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child) {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\t\tsg->flags = sd->child->flags;\n\t} else {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\t}\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_descended_sibling",
          "args": [
            "sd",
            "sibling"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "find_descended_sibling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "966-989",
          "snippet": "static struct sched_domain *\nfind_descended_sibling(struct sched_domain *sd, struct sched_domain *sibling)\n{\n\t/*\n\t * The proper descendant would be the one whose child won't span out\n\t * of sd\n\t */\n\twhile (sibling->child &&\n\t       !cpumask_subset(sched_domain_span(sibling->child),\n\t\t\t       sched_domain_span(sd)))\n\t\tsibling = sibling->child;\n\n\t/*\n\t * As we are referencing sgc across different topology level, we need\n\t * to go down to skip those sched_domains which don't contribute to\n\t * scheduling because they will be degenerated in cpu_attach_domain\n\t */\n\twhile (sibling->child &&\n\t       cpumask_equal(sched_domain_span(sibling->child),\n\t\t\t     sched_domain_span(sibling)))\n\t\tsibling = sibling->child;\n\n\treturn sibling;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_domain *\nfind_descended_sibling(struct sched_domain *sd, struct sched_domain *sibling)\n{\n\t/*\n\t * The proper descendant would be the one whose child won't span out\n\t * of sd\n\t */\n\twhile (sibling->child &&\n\t       !cpumask_subset(sched_domain_span(sibling->child),\n\t\t\t       sched_domain_span(sd)))\n\t\tsibling = sibling->child;\n\n\t/*\n\t * As we are referencing sgc across different topology level, we need\n\t * to go down to skip those sched_domains which don't contribute to\n\t * scheduling because they will be degenerated in cpu_attach_domain\n\t */\n\twhile (sibling->child &&\n\t       cpumask_equal(sched_domain_span(sibling->child),\n\t\t\t     sched_domain_span(sibling)))\n\t\tsibling = sibling->child;\n\n\treturn sibling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "sched_domain_span(sibling->child)",
            "span"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling->child"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "sched_domain_span(sibling)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "i"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "covered"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_wrap",
          "args": [
            "i",
            "span",
            "cpu"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "covered"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Usually we build sched_group by sibling's child sched_domain\n\t\t * But for machines whose NUMA diameter are 3 or above, we move\n\t\t * to build sched_group by sibling's proper descendant's child\n\t\t * domain because sibling's child sched_domain will span out of\n\t\t * the sched_domain being built as below.\n\t\t *\n\t\t * Smallest diameter=3 topology is:\n\t\t *\n\t\t *   node   0   1   2   3\n\t\t *     0:  10  20  30  40\n\t\t *     1:  20  10  20  30\n\t\t *     2:  30  20  10  20\n\t\t *     3:  40  30  20  10\n\t\t *\n\t\t *   0 --- 1 --- 2 --- 3\n\t\t *\n\t\t * NUMA-3       0-3             N/A             N/A             0-3\n\t\t *  groups:     {0-2},{1-3}                                     {1-3},{0-2}\n\t\t *\n\t\t * NUMA-2       0-2             0-3             0-3             1-3\n\t\t *  groups:     {0-1},{1-3}     {0-2},{2-3}     {1-3},{0-1}     {2-3},{0-2}\n\t\t *\n\t\t * NUMA-1       0-1             0-2             1-3             2-3\n\t\t *  groups:     {0},{1}         {1},{2},{0}     {2},{3},{1}     {3},{2}\n\t\t *\n\t\t * NUMA-0       0               1               2               3\n\t\t *\n\t\t * The NUMA-2 groups for nodes 0 and 3 are obviously buggered, as the\n\t\t * group span isn't a subset of the domain span.\n\t\t */\n\t\tif (sibling->child &&\n\t\t    !cpumask_subset(sched_domain_span(sibling->child), span))\n\t\t\tsibling = find_descended_sibling(sd, sibling);\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sibling, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "find_descended_sibling",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "966-989",
    "snippet": "static struct sched_domain *\nfind_descended_sibling(struct sched_domain *sd, struct sched_domain *sibling)\n{\n\t/*\n\t * The proper descendant would be the one whose child won't span out\n\t * of sd\n\t */\n\twhile (sibling->child &&\n\t       !cpumask_subset(sched_domain_span(sibling->child),\n\t\t\t       sched_domain_span(sd)))\n\t\tsibling = sibling->child;\n\n\t/*\n\t * As we are referencing sgc across different topology level, we need\n\t * to go down to skip those sched_domains which don't contribute to\n\t * scheduling because they will be degenerated in cpu_attach_domain\n\t */\n\twhile (sibling->child &&\n\t       cpumask_equal(sched_domain_span(sibling->child),\n\t\t\t     sched_domain_span(sibling)))\n\t\tsibling = sibling->child;\n\n\treturn sibling;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sibling->child)",
            "sched_domain_span(sibling)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling->child"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "sched_domain_span(sibling->child)",
            "sched_domain_span(sd)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling->child"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_domain *\nfind_descended_sibling(struct sched_domain *sd, struct sched_domain *sibling)\n{\n\t/*\n\t * The proper descendant would be the one whose child won't span out\n\t * of sd\n\t */\n\twhile (sibling->child &&\n\t       !cpumask_subset(sched_domain_span(sibling->child),\n\t\t\t       sched_domain_span(sd)))\n\t\tsibling = sibling->child;\n\n\t/*\n\t * As we are referencing sgc across different topology level, we need\n\t * to go down to skip those sched_domains which don't contribute to\n\t * scheduling because they will be degenerated in cpu_attach_domain\n\t */\n\twhile (sibling->child &&\n\t       cpumask_equal(sched_domain_span(sibling->child),\n\t\t\t     sched_domain_span(sibling)))\n\t\tsibling = sibling->child;\n\n\treturn sibling;\n}"
  },
  {
    "function_name": "init_overlap_sched_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "938-964",
    "snippet": "static void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first(mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sg_span"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpumask_equal(group_balance_mask(sg), mask)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "group_balance_mask(sg)",
            "mask"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1820-1823",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "group_balance_mask(sg)",
            "mask"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "mask"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_balance_mask",
          "args": [
            "sd",
            "sg",
            "mask"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "build_balance_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "877-907",
          "snippet": "static void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask2;\n\nstatic void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first(mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}"
  },
  {
    "function_name": "build_group_from_child_sched_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "914-936",
    "snippet": "static struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child) {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\t\tsg->flags = sd->child->flags;\n\t} else {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\t}\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sg->ref"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sg_span",
            "sched_domain_span(sd)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sg_span",
            "sched_domain_span(sd->child)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->child"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child) {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\t\tsg->flags = sd->child->flags;\n\t} else {\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\t}\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}"
  },
  {
    "function_name": "build_balance_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "877-907",
    "snippet": "static void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpumask_empty(mask)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "mask"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "i",
            "mask"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sg_span",
            "sched_domain_span(sibling->child)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling->child"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "i"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "sg_span"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "mask"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}"
  },
  {
    "function_name": "group_balance_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "766-769",
    "snippet": "int group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "group_balance_mask(sg)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1820-1823",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}"
  },
  {
    "function_name": "cpu_attach_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "686-743",
    "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_top_cache_domain",
          "args": [
            "cpu"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "update_top_cache_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "653-680",
          "snippet": "static void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym_packing, cpu), sd);\n\n\tsd = lowest_flag_domain(cpu, SD_ASYM_CPUCAPACITY_FULL);\n\trcu_assign_pointer(per_cpu(sd_asym_cpucapacity, cpu), sd);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym_packing, cpu), sd);\n\n\tsd = lowest_flag_domain(cpu, SD_ASYM_CPUCAPACITY_FULL);\n\trcu_assign_pointer(per_cpu(sd_asym_cpucapacity, cpu), sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_sched_domains",
          "args": [
            "tmp"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "629-633",
          "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_sched_domain_sysctl",
          "args": [
            "cpu"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_sched_domain_sysctl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1843-1845",
          "snippet": "static inline void dirty_sched_domain_sysctl(int cpu)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void dirty_sched_domain_sysctl(int cpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rq->sd",
            "sd"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_attach_root",
          "args": [
            "rq",
            "rd"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rq_attach_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "465-500",
          "snippet": "void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n\n\tif (old_rd)\n\t\tcall_rcu(&old_rd->rcu, free_rootdomain);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n\n\tif (old_rd)\n\t\tcall_rcu(&old_rd->rcu, free_rootdomain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_domain_debug",
          "args": [
            "sd",
            "cpu"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domain_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "130-152",
          "snippet": "static void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_verbose)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_verbose)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_degenerate",
          "args": [
            "sd"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "sd_degenerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "170-185",
          "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_parent_degenerate",
          "args": [
            "tmp",
            "parent"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "sd_parent_degenerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "187-206",
          "snippet": "static int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next)\n\t\tpflags &= ~SD_DEGENERATE_GROUPS_MASK;\n\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n\nstatic int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next)\n\t\tpflags &= ~SD_DEGENERATE_GROUPS_MASK;\n\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd) {\n\t\t\tstruct sched_group *sg = sd->groups;\n\n\t\t\t/*\n\t\t\t * sched groups hold the flags of the child sched\n\t\t\t * domain for convenience. Clear such flags since\n\t\t\t * the child is being destroyed.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tsg->flags = 0;\n\t\t\t} while (sg != sd->groups);\n\n\t\t\tsd->child = NULL;\n\t\t}\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
  },
  {
    "function_name": "update_top_cache_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "653-680",
    "snippet": "static void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym_packing, cpu), sd);\n\n\tsd = lowest_flag_domain(cpu, SD_ASYM_CPUCAPACITY_FULL);\n\trcu_assign_pointer(per_cpu(sd_asym_cpucapacity, cpu), sd);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_asym_cpucapacity, cpu)",
            "sd"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sd_asym_cpucapacity",
            "cpu"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowest_flag_domain",
          "args": [
            "cpu",
            "SD_ASYM_CPUCAPACITY_FULL"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "lowest_flag_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1753-1763",
          "snippet": "static inline struct sched_domain *lowest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & flag)\n\t\t\tbreak;\n\t}\n\n\treturn sd;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline struct sched_domain *lowest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & flag)\n\t\t\tbreak;\n\t}\n\n\treturn sd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_asym_packing, cpu)",
            "sd"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "highest_flag_domain",
          "args": [
            "cpu",
            "SD_ASYM_PACKING"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "highest_flag_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1740-1751",
          "snippet": "static inline struct sched_domain *highest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd, *hsd = NULL;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (!(sd->flags & flag))\n\t\t\tbreak;\n\t\thsd = sd;\n\t}\n\n\treturn hsd;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline struct sched_domain *highest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd, *hsd = NULL;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (!(sd->flags & flag))\n\t\t\tbreak;\n\t\thsd = sd;\n\t}\n\n\treturn hsd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_numa, cpu)",
            "sd"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_llc_shared, cpu)",
            "sds"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_llc, cpu)",
            "sd"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym_packing, cpu), sd);\n\n\tsd = lowest_flag_domain(cpu, SD_ASYM_CPUCAPACITY_FULL);\n\trcu_assign_pointer(per_cpu(sd_asym_cpucapacity, cpu), sd);\n}"
  },
  {
    "function_name": "destroy_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "629-633",
    "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&sd->rcu",
            "destroy_sched_domains_rcu"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
  },
  {
    "function_name": "destroy_sched_domains_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "618-627",
    "snippet": "static void destroy_sched_domains_rcu(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\twhile (sd) {\n\t\tstruct sched_domain *parent = sd->parent;\n\t\tdestroy_sched_domain(sd);\n\t\tsd = parent;\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_sched_domain",
          "args": [
            "sd"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "629-633",
          "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structsched_domain",
            "rcu"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_sched_domains_rcu(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\twhile (sd) {\n\t\tstruct sched_domain *parent = sd->parent;\n\t\tdestroy_sched_domain(sd);\n\t\tsd = parent;\n\t}\n}"
  },
  {
    "function_name": "destroy_sched_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "604-616",
    "snippet": "static void destroy_sched_domain(struct sched_domain *sd)\n{\n\t/*\n\t * A normal sched domain may have multiple group references, an\n\t * overlapping domain, having private groups, only one.  Iterate,\n\t * dropping group/capacity references, freeing where none remain.\n\t */\n\tfree_sched_groups(sd->groups, 1);\n\n\tif (sd->shared && atomic_dec_and_test(&sd->shared->ref))\n\t\tkfree(sd->shared);\n\tkfree(sd);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sd->shared->ref"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "sd->groups",
            "1"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "584-602",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_sched_domain(struct sched_domain *sd)\n{\n\t/*\n\t * A normal sched domain may have multiple group references, an\n\t * overlapping domain, having private groups, only one.  Iterate,\n\t * dropping group/capacity references, freeing where none remain.\n\t */\n\tfree_sched_groups(sd->groups, 1);\n\n\tif (sd->shared && atomic_dec_and_test(&sd->shared->ref))\n\t\tkfree(sd->shared);\n\tkfree(sd);\n}"
  },
  {
    "function_name": "free_sched_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "584-602",
    "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sg"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sg->ref"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
  },
  {
    "function_name": "alloc_rootdomain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "568-582",
    "snippet": "static struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rootdomain",
          "args": [
            "rd"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "init_rootdomain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "515-553",
          "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rd)",
            "GFP_KERNEL"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}"
  },
  {
    "function_name": "init_defrootdomain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "561-566",
    "snippet": "void init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct root_domain def_root_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&def_root_domain.refcount",
            "1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rootdomain",
          "args": [
            "&def_root_domain"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "init_rootdomain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "515-553",
          "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstruct root_domain def_root_domain;\n\nvoid init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}"
  },
  {
    "function_name": "init_rootdomain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "515-553",
    "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->span"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->online"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->dlo_mask"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->rto_mask"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_cleanup",
          "args": [
            "&rd->cpudl"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "292-296",
          "snippet": "void cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpupri_init",
          "args": [
            "&rd->cpupri"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpupri.c",
          "lines": "278-303",
          "snippet": "int cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_init",
          "args": [
            "&rd->cpudl"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "264-286",
          "snippet": "int cpudl_init(struct cpudl *cp)\n{\n\tint i;\n\n\traw_spin_lock_init(&cp->lock);\n\tcp->size = 0;\n\n\tcp->elements = kcalloc(nr_cpu_ids,\n\t\t\t       sizeof(struct cpudl_item),\n\t\t\t       GFP_KERNEL);\n\tif (!cp->elements)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&cp->free_cpus, GFP_KERNEL)) {\n\t\tkfree(cp->elements);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_possible_cpu(i)\n\t\tcp->elements[i].idx = IDX_INVALID;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_init(struct cpudl *cp)\n{\n\tint i;\n\n\traw_spin_lock_init(&cp->lock);\n\tcp->size = 0;\n\n\tcp->elements = kcalloc(nr_cpu_ids,\n\t\t\t       sizeof(struct cpudl_item),\n\t\t\t       GFP_KERNEL);\n\tif (!cp->elements)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&cp->free_cpus, GFP_KERNEL)) {\n\t\tkfree(cp->elements);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_possible_cpu(i)\n\t\tcp->elements[i].idx = IDX_INVALID;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_bw",
          "args": [
            "&rd->dl_bw"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "423-433",
          "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct dl_bandwidth def_dl_bandwidth;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRQ_WORK_INIT_HARD",
          "args": [
            "rto_push_irq_work_func"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rd->rto_lock"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->rto_mask",
            "GFP_KERNEL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->dlo_mask",
            "GFP_KERNEL"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->online",
            "GFP_KERNEL"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->span",
            "GFP_KERNEL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\trd->rto_push_work = IRQ_WORK_INIT_HARD(rto_push_irq_work_func);\n#endif\n\n\trd->visit_gen = 0;\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "sched_put_rd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "507-513",
    "snippet": "void sched_put_rd(struct root_domain *rd)\n{\n\tif (!atomic_dec_and_test(&rd->refcount))\n\t\treturn;\n\n\tcall_rcu(&rd->rcu, free_rootdomain);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rd->rcu",
            "free_rootdomain"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rd->refcount"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid sched_put_rd(struct root_domain *rd)\n{\n\tif (!atomic_dec_and_test(&rd->refcount))\n\t\treturn;\n\n\tcall_rcu(&rd->rcu, free_rootdomain);\n}"
  },
  {
    "function_name": "sched_get_rd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "502-505",
    "snippet": "void sched_get_rd(struct root_domain *rd)\n{\n\tatomic_inc(&rd->refcount);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rd->refcount"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid sched_get_rd(struct root_domain *rd)\n{\n\tatomic_inc(&rd->refcount);\n}"
  },
  {
    "function_name": "rq_attach_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "465-500",
    "snippet": "void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n\n\tif (old_rd)\n\t\tcall_rcu(&old_rd->rcu, free_rootdomain);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old_rd->rcu",
            "free_rootdomain"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock_irqrestore",
          "args": [
            "rq",
            "flags"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1341-1345",
          "snippet": "static inline void raw_spin_rq_unlock_irqrestore(struct rq *rq, unsigned long flags)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void raw_spin_rq_unlock_irqrestore(struct rq *rq, unsigned long flags)\n{\n\traw_spin_rq_unlock(rq);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rq_online",
          "args": [
            "rq"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8955-8968",
          "snippet": "void set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "rq->cpu",
            "cpu_active_mask"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "rq->cpu",
            "rd->span"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rd->refcount"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&old_rd->refcount"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "rq->cpu",
            "old_rd->span"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rq_offline",
          "args": [
            "rq"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_offline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8970-8983",
          "snippet": "void set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "rq->cpu",
            "old_rd->online"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_lock_irqsave",
          "args": [
            "rq",
            "flags"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n\n\tif (old_rd)\n\t\tcall_rcu(&old_rd->rcu, free_rootdomain);\n}"
  },
  {
    "function_name": "free_rootdomain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "451-463",
    "snippet": "static void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tfree_pd(rd->pd);\n\tkfree(rd);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pd",
          "args": [
            "rd->pd"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "448-448",
          "snippet": "static void free_pd(struct perf_domain *pd) { }",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_pd(struct perf_domain *pd) { }"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->span"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->online"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->rto_mask"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->dlo_mask"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_cleanup",
          "args": [
            "&rd->cpudl"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "292-296",
          "snippet": "void cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpupri_cleanup",
          "args": [
            "&rd->cpupri"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpupri.c",
          "lines": "309-316",
          "snippet": "void cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structroot_domain",
            "rcu"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tfree_pd(rd->pd);\n\tkfree(rd);\n}"
  },
  {
    "function_name": "free_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "448-448",
    "snippet": "static void free_pd(struct perf_domain *pd) { }",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_pd(struct perf_domain *pd) { }"
  },
  {
    "function_name": "build_perf_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "352-446",
    "snippet": "static bool build_perf_domains(const struct cpumask *cpu_map)\n{\n\tint i, nr_pd = 0, nr_ps = 0, nr_cpus = cpumask_weight(cpu_map);\n\tstruct perf_domain *pd = NULL, *tmp;\n\tint cpu = cpumask_first(cpu_map);\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\tstruct cpufreq_policy *policy;\n\tstruct cpufreq_governor *gov;\n\n\tif (!sysctl_sched_energy_aware)\n\t\tgoto free;\n\n\t/* EAS is enabled for asymmetric CPU capacity topologies. */\n\tif (!per_cpu(sd_asym_cpucapacity, cpu)) {\n\t\tif (sched_debug()) {\n\t\t\tpr_info(\"rd %*pbl: CPUs do not have asymmetric capacities\\n\",\n\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\t/* EAS definitely does *not* handle SMT */\n\tif (sched_smt_active()) {\n\t\tpr_warn(\"rd %*pbl: Disabling EAS, SMT is not supported\\n\",\n\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tif (!arch_scale_freq_invariant()) {\n\t\tif (sched_debug()) {\n\t\t\tpr_warn(\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\",\n\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\tfor_each_cpu(i, cpu_map) {\n\t\t/* Skip already covered CPUs. */\n\t\tif (find_pd(pd, i))\n\t\t\tcontinue;\n\n\t\t/* Do not attempt EAS if schedutil is not being used. */\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tgoto free;\n\t\tgov = policy->governor;\n\t\tcpufreq_cpu_put(policy);\n\t\tif (gov != &schedutil_gov) {\n\t\t\tif (rd->pd)\n\t\t\t\tpr_warn(\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t\tgoto free;\n\t\t}\n\n\t\t/* Create the new pd and add it to the local list. */\n\t\ttmp = pd_init(i);\n\t\tif (!tmp)\n\t\t\tgoto free;\n\t\ttmp->next = pd;\n\t\tpd = tmp;\n\n\t\t/*\n\t\t * Count performance domains and performance states for the\n\t\t * complexity check.\n\t\t */\n\t\tnr_pd++;\n\t\tnr_ps += em_pd_nr_perf_states(pd->em_pd);\n\t}\n\n\t/* Bail out if the Energy Model complexity is too high. */\n\tif (nr_pd * (nr_ps + nr_cpus) > EM_MAX_COMPLEXITY) {\n\t\tWARN(1, \"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tperf_domain_debug(cpu_map, pd);\n\n\t/* Attach the new list of performance domains to the root domain. */\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, pd);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn !!pd;\n\nfree:\n\tfree_pd(pd);\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, NULL);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define EM_MAX_COMPLEXITY 2048"
    ],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tmp->rcu",
            "destroy_perf_domain_rcu"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rd->pd",
            "NULL"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pd",
          "args": [
            "pd"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "448-448",
          "snippet": "static void free_pd(struct perf_domain *pd) { }",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_pd(struct perf_domain *pd) { }"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rd->pd",
            "pd"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_domain_debug",
          "args": [
            "cpu_map",
            "pd"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "perf_domain_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "284-301",
          "snippet": "static void perf_domain_debug(const struct cpumask *cpu_map,\n\t\t\t\t\t\tstruct perf_domain *pd)\n{\n\tif (!sched_debug() || !pd)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"root_domain %*pbl:\", cpumask_pr_args(cpu_map));\n\n\twhile (pd) {\n\t\tprintk(KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\",\n\t\t\t\tcpumask_first(perf_domain_span(pd)),\n\t\t\t\tcpumask_pr_args(perf_domain_span(pd)),\n\t\t\t\tem_pd_nr_perf_states(pd->em_pd));\n\t\tpd = pd->next;\n\t}\n\n\tprintk(KERN_CONT \"\\n\");\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void perf_domain_debug(const struct cpumask *cpu_map,\n\t\t\t\t\t\tstruct perf_domain *pd)\n{\n\tif (!sched_debug() || !pd)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"root_domain %*pbl:\", cpumask_pr_args(cpu_map));\n\n\twhile (pd) {\n\t\tprintk(KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\",\n\t\t\t\tcpumask_first(perf_domain_span(pd)),\n\t\t\t\tcpumask_pr_args(perf_domain_span(pd)),\n\t\t\t\tem_pd_nr_perf_states(pd->em_pd));\n\t\tpd = pd->next;\n\t}\n\n\tprintk(KERN_CONT \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\"",
            "cpumask_pr_args(cpu_map)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_pd_nr_perf_states",
          "args": [
            "pd->em_pd"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pd_init",
          "args": [
            "i"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "pd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "265-282",
          "snippet": "static struct perf_domain *pd_init(int cpu)\n{\n\tstruct em_perf_domain *obj = em_cpu_get(cpu);\n\tstruct perf_domain *pd;\n\n\tif (!obj) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: no EM found for CPU%d\\n\", __func__, cpu);\n\t\treturn NULL;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\tpd->em_pd = obj;\n\n\treturn pd;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct perf_domain *pd_init(int cpu)\n{\n\tstruct em_perf_domain *obj = em_cpu_get(cpu);\n\tstruct perf_domain *pd;\n\n\tif (!obj) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: no EM found for CPU%d\\n\", __func__, cpu);\n\t\treturn NULL;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\tpd->em_pd = obj;\n\n\treturn pd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\"",
            "cpumask_pr_args(cpu_map)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_cpu_put",
          "args": [
            "policy"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_cpu_get",
          "args": [
            "i"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_pd",
          "args": [
            "pd",
            "i"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "find_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "254-263",
          "snippet": "static struct perf_domain *find_pd(struct perf_domain *pd, int cpu)\n{\n\twhile (pd) {\n\t\tif (cpumask_test_cpu(cpu, perf_domain_span(pd)))\n\t\t\treturn pd;\n\t\tpd = pd->next;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct perf_domain *find_pd(struct perf_domain *pd, int cpu)\n{\n\twhile (pd) {\n\t\tif (cpumask_test_cpu(cpu, perf_domain_span(pd)))\n\t\t\treturn pd;\n\t\tpd = pd->next;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\"",
            "cpumask_pr_args(cpu_map)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "157-160",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_scale_freq_invariant",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rd %*pbl: Disabling EAS, SMT is not supported\\n\"",
            "cpumask_pr_args(cpu_map)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_smt_active",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rd %*pbl: CPUs do not have asymmetric capacities\\n\"",
            "cpumask_pr_args(cpu_map)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sd_asym_cpucapacity",
            "cpu"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_map"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpu_map"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\n#define EM_MAX_COMPLEXITY 2048\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic bool build_perf_domains(const struct cpumask *cpu_map)\n{\n\tint i, nr_pd = 0, nr_ps = 0, nr_cpus = cpumask_weight(cpu_map);\n\tstruct perf_domain *pd = NULL, *tmp;\n\tint cpu = cpumask_first(cpu_map);\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\tstruct cpufreq_policy *policy;\n\tstruct cpufreq_governor *gov;\n\n\tif (!sysctl_sched_energy_aware)\n\t\tgoto free;\n\n\t/* EAS is enabled for asymmetric CPU capacity topologies. */\n\tif (!per_cpu(sd_asym_cpucapacity, cpu)) {\n\t\tif (sched_debug()) {\n\t\t\tpr_info(\"rd %*pbl: CPUs do not have asymmetric capacities\\n\",\n\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\t/* EAS definitely does *not* handle SMT */\n\tif (sched_smt_active()) {\n\t\tpr_warn(\"rd %*pbl: Disabling EAS, SMT is not supported\\n\",\n\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tif (!arch_scale_freq_invariant()) {\n\t\tif (sched_debug()) {\n\t\t\tpr_warn(\"rd %*pbl: Disabling EAS: frequency-invariant load tracking not yet supported\",\n\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t}\n\t\tgoto free;\n\t}\n\n\tfor_each_cpu(i, cpu_map) {\n\t\t/* Skip already covered CPUs. */\n\t\tif (find_pd(pd, i))\n\t\t\tcontinue;\n\n\t\t/* Do not attempt EAS if schedutil is not being used. */\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tgoto free;\n\t\tgov = policy->governor;\n\t\tcpufreq_cpu_put(policy);\n\t\tif (gov != &schedutil_gov) {\n\t\t\tif (rd->pd)\n\t\t\t\tpr_warn(\"rd %*pbl: Disabling EAS, schedutil is mandatory\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\t\tgoto free;\n\t\t}\n\n\t\t/* Create the new pd and add it to the local list. */\n\t\ttmp = pd_init(i);\n\t\tif (!tmp)\n\t\t\tgoto free;\n\t\ttmp->next = pd;\n\t\tpd = tmp;\n\n\t\t/*\n\t\t * Count performance domains and performance states for the\n\t\t * complexity check.\n\t\t */\n\t\tnr_pd++;\n\t\tnr_ps += em_pd_nr_perf_states(pd->em_pd);\n\t}\n\n\t/* Bail out if the Energy Model complexity is too high. */\n\tif (nr_pd * (nr_ps + nr_cpus) > EM_MAX_COMPLEXITY) {\n\t\tWARN(1, \"rd %*pbl: Failed to start EAS, EM complexity is too high\\n\",\n\t\t\t\t\t\tcpumask_pr_args(cpu_map));\n\t\tgoto free;\n\t}\n\n\tperf_domain_debug(cpu_map, pd);\n\n\t/* Attach the new list of performance domains to the root domain. */\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, pd);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn !!pd;\n\nfree:\n\tfree_pd(pd);\n\ttmp = rd->pd;\n\trcu_assign_pointer(rd->pd, NULL);\n\tif (tmp)\n\t\tcall_rcu(&tmp->rcu, destroy_perf_domain_rcu);\n\n\treturn false;\n}"
  },
  {
    "function_name": "sched_energy_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "311-322",
    "snippet": "static void sched_energy_set(bool has_eas)\n{\n\tif (!has_eas && static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: stopping EAS\\n\", __func__);\n\t\tstatic_branch_disable_cpuslocked(&sched_energy_present);\n\t} else if (has_eas && !static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: starting EAS\\n\", __func__);\n\t\tstatic_branch_enable_cpuslocked(&sched_energy_present);\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable_cpuslocked",
          "args": [
            "&sched_energy_present"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: starting EAS\\n\"",
            "__func__"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "157-160",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_energy_present"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable_cpuslocked",
          "args": [
            "&sched_energy_present"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: stopping EAS\\n\"",
            "__func__"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_energy_present"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void sched_energy_set(bool has_eas)\n{\n\tif (!has_eas && static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: stopping EAS\\n\", __func__);\n\t\tstatic_branch_disable_cpuslocked(&sched_energy_present);\n\t} else if (has_eas && !static_branch_unlikely(&sched_energy_present)) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: starting EAS\\n\", __func__);\n\t\tstatic_branch_enable_cpuslocked(&sched_energy_present);\n\t}\n}"
  },
  {
    "function_name": "destroy_perf_domain_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "303-309",
    "snippet": "static void destroy_perf_domain_rcu(struct rcu_head *rp)\n{\n\tstruct perf_domain *pd;\n\n\tpd = container_of(rp, struct perf_domain, rcu);\n\tfree_pd(pd);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pd",
          "args": [
            "pd"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "448-448",
          "snippet": "static void free_pd(struct perf_domain *pd) { }",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_pd(struct perf_domain *pd) { }"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rp",
            "structperf_domain",
            "rcu"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void destroy_perf_domain_rcu(struct rcu_head *rp)\n{\n\tstruct perf_domain *pd;\n\n\tpd = container_of(rp, struct perf_domain, rcu);\n\tfree_pd(pd);\n}"
  },
  {
    "function_name": "perf_domain_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "284-301",
    "snippet": "static void perf_domain_debug(const struct cpumask *cpu_map,\n\t\t\t\t\t\tstruct perf_domain *pd)\n{\n\tif (!sched_debug() || !pd)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"root_domain %*pbl:\", cpumask_pr_args(cpu_map));\n\n\twhile (pd) {\n\t\tprintk(KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\",\n\t\t\t\tcpumask_first(perf_domain_span(pd)),\n\t\t\t\tcpumask_pr_args(perf_domain_span(pd)),\n\t\t\t\tem_pd_nr_perf_states(pd->em_pd));\n\t\tpd = pd->next;\n\t}\n\n\tprintk(KERN_CONT \"\\n\");\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\"",
            "cpumask_first(perf_domain_span(pd))",
            "cpumask_pr_args(perf_domain_span(pd))",
            "em_pd_nr_perf_states(pd->em_pd)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_pd_nr_perf_states",
          "args": [
            "pd->em_pd"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "perf_domain_span(pd)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_domain_span",
          "args": [
            "pd"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "perf_domain_span(pd)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_domain_span",
          "args": [
            "pd"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "157-160",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void perf_domain_debug(const struct cpumask *cpu_map,\n\t\t\t\t\t\tstruct perf_domain *pd)\n{\n\tif (!sched_debug() || !pd)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"root_domain %*pbl:\", cpumask_pr_args(cpu_map));\n\n\twhile (pd) {\n\t\tprintk(KERN_CONT \" pd%d:{ cpus=%*pbl nr_pstate=%d }\",\n\t\t\t\tcpumask_first(perf_domain_span(pd)),\n\t\t\t\tcpumask_pr_args(perf_domain_span(pd)),\n\t\t\t\tem_pd_nr_perf_states(pd->em_pd));\n\t\tpd = pd->next;\n\t}\n\n\tprintk(KERN_CONT \"\\n\");\n}"
  },
  {
    "function_name": "pd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "265-282",
    "snippet": "static struct perf_domain *pd_init(int cpu)\n{\n\tstruct em_perf_domain *obj = em_cpu_get(cpu);\n\tstruct perf_domain *pd;\n\n\tif (!obj) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: no EM found for CPU%d\\n\", __func__, cpu);\n\t\treturn NULL;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\tpd->em_pd = obj;\n\n\treturn pd;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pd)",
            "GFP_KERNEL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: no EM found for CPU%d\\n\"",
            "__func__",
            "cpu"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "157-160",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_cpu_get",
          "args": [
            "cpu"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "em_cpu_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "295-304",
          "snippet": "struct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstruct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct perf_domain *pd_init(int cpu)\n{\n\tstruct em_perf_domain *obj = em_cpu_get(cpu);\n\tstruct perf_domain *pd;\n\n\tif (!obj) {\n\t\tif (sched_debug())\n\t\t\tpr_info(\"%s: no EM found for CPU%d\\n\", __func__, cpu);\n\t\treturn NULL;\n\t}\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\tpd->em_pd = obj;\n\n\treturn pd;\n}"
  },
  {
    "function_name": "find_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "254-263",
    "snippet": "static struct perf_domain *find_pd(struct perf_domain *pd, int cpu)\n{\n\twhile (pd) {\n\t\tif (cpumask_test_cpu(cpu, perf_domain_span(pd)))\n\t\t\treturn pd;\n\t\tpd = pd->next;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "perf_domain_span(pd)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_domain_span",
          "args": [
            "pd"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic struct perf_domain *find_pd(struct perf_domain *pd, int cpu)\n{\n\twhile (pd) {\n\t\tif (cpumask_test_cpu(cpu, perf_domain_span(pd)))\n\t\t\treturn pd;\n\t\tpd = pd->next;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "243-252",
    "snippet": "static void free_pd(struct perf_domain *pd)\n{\n\tstruct perf_domain *tmp;\n\n\twhile (pd) {\n\t\ttmp = pd->next;\n\t\tkfree(pd);\n\t\tpd = tmp;\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic void free_pd(struct perf_domain *pd)\n{\n\tstruct perf_domain *tmp;\n\n\twhile (pd) {\n\t\ttmp = pd->next;\n\t\tkfree(pd);\n\t\tpd = tmp;\n\t}\n}"
  },
  {
    "function_name": "sched_energy_aware_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "224-240",
    "snippet": "int sched_energy_aware_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret, state;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\tstate = static_branch_unlikely(&sched_energy_present);\n\t\tif (state != sysctl_sched_energy_aware)\n\t\t\trebuild_sched_domains_energy();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rebuild_sched_domains_energy",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_energy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "214-221",
          "snippet": "void rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_energy_present"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1567-1571",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nint sched_energy_aware_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret, state;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (!ret && write) {\n\t\tstate = static_branch_unlikely(&sched_energy_present);\n\t\tif (state != sysctl_sched_energy_aware)\n\t\t\trebuild_sched_domains_energy();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rebuild_sched_domains_energy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "214-221",
    "snippet": "void rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_energy_mutex"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_sched_domains",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_energy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "214-221",
          "snippet": "void rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_energy_mutex"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nvoid rebuild_sched_domains_energy(void)\n{\n\tmutex_lock(&sched_energy_mutex);\n\tsched_energy_update = true;\n\trebuild_sched_domains();\n\tsched_energy_update = false;\n\tmutex_unlock(&sched_energy_mutex);\n}"
  },
  {
    "function_name": "sd_parent_degenerate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "187-206",
    "snippet": "static int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next)\n\t\tpflags &= ~SD_DEGENERATE_GROUPS_MASK;\n\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd)",
            "sched_domain_span(parent)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "parent"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_degenerate",
          "args": [
            "parent"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "sd_degenerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "170-185",
          "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n\nstatic int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next)\n\t\tpflags &= ~SD_DEGENERATE_GROUPS_MASK;\n\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sd_degenerate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "170-185",
    "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic const unsigned int SD_DEGENERATE_GROUPS_MASK =\n#include <linux/sched/sd_flags.h>\n0;\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif ((sd->flags & SD_DEGENERATE_GROUPS_MASK) &&\n\t    (sd->groups != sd->groups->next))\n\t\treturn 0;\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sched_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "157-160",
    "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "sched_domain_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "130-152",
    "snippet": "static void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_verbose)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_domain_debug_one",
          "args": [
            "sd",
            "cpu",
            "level",
            "sched_domains_tmpmask"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domain_debug_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "34-128",
          "snippet": "static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\tunsigned long flags = sd->flags;\n\tunsigned int idx;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tfor_each_set_bit(idx, &flags, __SD_FLAG_CNT) {\n\t\tunsigned int flag = BIT(idx);\n\t\tunsigned int meta_flags = sd_flag_debug[idx].meta_flags;\n\n\t\tif ((meta_flags & SDF_SHARED_CHILD) && sd->child &&\n\t\t    !(sd->child->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in child\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\n\t\tif ((meta_flags & SDF_SHARED_PARENT) && sd->parent &&\n\t\t    !(sd->parent->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in parent\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\tunsigned long flags = sd->flags;\n\tunsigned int idx;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tfor_each_set_bit(idx, &flags, __SD_FLAG_CNT) {\n\t\tunsigned int flag = BIT(idx);\n\t\tunsigned int meta_flags = sd_flag_debug[idx].meta_flags;\n\n\t\tif ((meta_flags & SDF_SHARED_CHILD) && sd->child &&\n\t\t    !(sd->child->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in child\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\n\t\tif ((meta_flags & SDF_SHARED_PARENT) && sd->parent &&\n\t\t    !(sd->parent->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in parent\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\"",
            "cpu"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_verbose)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "sched_domain_debug_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "34-128",
    "snippet": "static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\tunsigned long flags = sd->flags;\n\tunsigned int idx;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tfor_each_set_bit(idx, &flags, __SD_FLAG_CNT) {\n\t\tunsigned int flag = BIT(idx);\n\t\tunsigned int meta_flags = sd_flag_debug[idx].meta_flags;\n\n\t\tif ((meta_flags & SDF_SHARED_CHILD) && sd->child &&\n\t\t    !(sd->child->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in child\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\n\t\tif ((meta_flags & SDF_SHARED_PARENT) && sd->parent &&\n\t\t    !(sd->parent->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in parent\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "groupmask",
            "sched_domain_span(sd->parent)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->parent"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd)",
            "groupmask"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd->child)",
            "sched_group_span(group)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "group"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1812-1815",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->child"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" cap=%lu\"",
            "group->sgc->capacity"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "group_balance_mask(group)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "group"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1820-1823",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "group_balance_mask(group)",
            "sched_group_span(group)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_group_span(group)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "groupmask",
            "groupmask",
            "sched_group_span(group)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "groupmask",
            "sched_group_span(group)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(group)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "idx"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "idx",
            "&flags",
            "__SD_FLAG_CNT"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "sched_group_span(group)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "sched_domain_span(sd)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "groupmask"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\tunsigned long flags = sd->flags;\n\tunsigned int idx;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tfor_each_set_bit(idx, &flags, __SD_FLAG_CNT) {\n\t\tunsigned int flag = BIT(idx);\n\t\tunsigned int meta_flags = sd_flag_debug[idx].meta_flags;\n\n\t\tif ((meta_flags & SDF_SHARED_CHILD) && sd->child &&\n\t\t    !(sd->child->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in child\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\n\t\tif ((meta_flags & SDF_SHARED_PARENT) && sd->parent &&\n\t\t    !(sd->parent->flags & flag))\n\t\t\tprintk(KERN_ERR \"ERROR: flag %s set here but not in parent\\n\",\n\t\t\t       sd_flag_debug[idx].name);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "23-26",
    "snippet": "static inline bool sched_debug(void)\n{\n\treturn sched_debug_verbose;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn sched_debug_verbose;\n}"
  },
  {
    "function_name": "sched_debug_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
    "lines": "15-20",
    "snippet": "static int __init sched_debug_setup(char *str)\n{\n\tsched_debug_verbose = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/sd_flags.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic int __init sched_debug_setup(char *str)\n{\n\tsched_debug_verbose = true;\n\n\treturn 0;\n}"
  }
]