[
  {
    "function_name": "udelay_test_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "149-154",
    "snippet": "static void __exit udelay_test_exit(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_remove(debugfs_lookup(DEBUGFS_FILENAME, NULL));\n\tmutex_unlock(&udelay_test_lock);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define DEBUGFS_FILENAME \"udelay_test\""
    ],
    "globals_used": [
      "static DEFINE_MUTEX(udelay_test_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "debugfs_lookup(DEBUGFS_FILENAME, NULL)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "164-170",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "DEBUGFS_FILENAME",
            "NULL"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\n#define DEBUGFS_FILENAME \"udelay_test\"\n\nstatic DEFINE_MUTEX(udelay_test_lock);\n\nstatic void __exit udelay_test_exit(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_remove(debugfs_lookup(DEBUGFS_FILENAME, NULL));\n\tmutex_unlock(&udelay_test_lock);\n}"
  },
  {
    "function_name": "udelay_test_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "137-145",
    "snippet": "static int __init udelay_test_init(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_create_file(DEBUGFS_FILENAME, S_IRUSR, NULL, NULL,\n\t\t\t    &udelay_test_debugfs_ops);\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define DEBUGFS_FILENAME \"udelay_test\""
    ],
    "globals_used": [
      "static DEFINE_MUTEX(udelay_test_lock);",
      "static const struct file_operations udelay_test_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = udelay_test_open,\n\t.read = seq_read,\n\t.write = udelay_test_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "DEBUGFS_FILENAME",
            "S_IRUSR",
            "NULL",
            "NULL",
            "&udelay_test_debugfs_ops"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\n#define DEBUGFS_FILENAME \"udelay_test\"\n\nstatic DEFINE_MUTEX(udelay_test_lock);\nstatic const struct file_operations udelay_test_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = udelay_test_open,\n\t.read = seq_read,\n\t.write = udelay_test_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init udelay_test_init(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_create_file(DEBUGFS_FILENAME, S_IRUSR, NULL, NULL,\n\t\t\t    &udelay_test_debugfs_ops);\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udelay_test_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "99-126",
    "snippet": "static ssize_t udelay_test_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *pos)\n{\n\tchar lbuf[32];\n\tint ret;\n\tint usecs;\n\tint iters;\n\n\tif (count >= sizeof(lbuf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(lbuf, buf, count))\n\t\treturn -EFAULT;\n\tlbuf[count] = '\\0';\n\n\tret = sscanf(lbuf, \"%d %d\", &usecs, &iters);\n\tif (ret < 1)\n\t\treturn -EINVAL;\n\telse if (ret < 2)\n\t\titers = DEFAULT_ITERATIONS;\n\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_usecs = usecs;\n\tudelay_test_iterations = iters;\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define DEFAULT_ITERATIONS 100"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(udelay_test_lock);",
      "static int udelay_test_usecs;",
      "static int udelay_test_iterations = DEFAULT_ITERATIONS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "lbuf",
            "\"%d %d\"",
            "&usecs",
            "&iters"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "lbuf",
            "buf",
            "count"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\n#define DEFAULT_ITERATIONS 100\n\nstatic DEFINE_MUTEX(udelay_test_lock);\nstatic int udelay_test_usecs;\nstatic int udelay_test_iterations = DEFAULT_ITERATIONS;\n\nstatic ssize_t udelay_test_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *pos)\n{\n\tchar lbuf[32];\n\tint ret;\n\tint usecs;\n\tint iters;\n\n\tif (count >= sizeof(lbuf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(lbuf, buf, count))\n\t\treturn -EFAULT;\n\tlbuf[count] = '\\0';\n\n\tret = sscanf(lbuf, \"%d %d\", &usecs, &iters);\n\tif (ret < 1)\n\t\treturn -EINVAL;\n\telse if (ret < 2)\n\t\titers = DEFAULT_ITERATIONS;\n\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_usecs = usecs;\n\tudelay_test_iterations = iters;\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "udelay_test_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "94-97",
    "snippet": "static int udelay_test_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, udelay_test_show, inode->i_private);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "udelay_test_show",
            "inode->i_private"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int udelay_test_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, udelay_test_show, inode->i_private);\n}"
  },
  {
    "function_name": "udelay_test_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "67-92",
    "snippet": "static int udelay_test_show(struct seq_file *s, void *v)\n{\n\tint usecs;\n\tint iters;\n\tint ret = 0;\n\n\tmutex_lock(&udelay_test_lock);\n\tusecs = udelay_test_usecs;\n\titers = udelay_test_iterations;\n\tmutex_unlock(&udelay_test_lock);\n\n\tif (usecs > 0 && iters > 0) {\n\t\treturn udelay_test_single(s, usecs, iters);\n\t} else if (usecs == 0) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_ts64(&ts);\n\t\tseq_printf(s, \"udelay() test (lpj=%ld kt=%lld.%09ld)\\n\",\n\t\t\t\tloops_per_jiffy, (s64)ts.tv_sec, ts.tv_nsec);\n\t\tseq_puts(s, \"usage:\\n\");\n\t\tseq_puts(s, \"echo USECS [ITERS] > \" DEBUGFS_FILENAME \"\\n\");\n\t\tseq_puts(s, \"cat \" DEBUGFS_FILENAME \"\\n\");\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [
      "#define DEBUGFS_FILENAME \"udelay_test\""
    ],
    "globals_used": [
      "static DEFINE_MUTEX(udelay_test_lock);",
      "static int udelay_test_usecs;",
      "static int udelay_test_iterations = DEFAULT_ITERATIONS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"cat \" DEBUGFS_FILENAME \"\\n\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"udelay() test (lpj=%ld kt=%lld.%09ld)\\n\"",
            "loops_per_jiffy",
            "(s64)ts.tv_sec",
            "ts.tv_nsec"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "&ts"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "950-970",
          "snippet": "void ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay_test_single",
          "args": [
            "s",
            "usecs",
            "iters"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "udelay_test_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
          "lines": "27-65",
          "snippet": "static int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)\n{\n\tint min = 0, max = 0, fail_count = 0;\n\tuint64_t sum = 0;\n\tuint64_t avg;\n\tint i;\n\t/* Allow udelay to be up to 0.5% fast */\n\tint allowed_error_ns = usecs * 5;\n\n\tfor (i = 0; i < iters; ++i) {\n\t\ts64 kt1, kt2;\n\t\tint time_passed;\n\n\t\tkt1 = ktime_get_ns();\n\t\tudelay(usecs);\n\t\tkt2 = ktime_get_ns();\n\t\ttime_passed = kt2 - kt1;\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed > max)\n\t\t\tmax = time_passed;\n\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)\n\t\t\t++fail_count;\n\t\tWARN_ON(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" FAIL=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/ktime.h>",
            "#include <linux/delay.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)\n{\n\tint min = 0, max = 0, fail_count = 0;\n\tuint64_t sum = 0;\n\tuint64_t avg;\n\tint i;\n\t/* Allow udelay to be up to 0.5% fast */\n\tint allowed_error_ns = usecs * 5;\n\n\tfor (i = 0; i < iters; ++i) {\n\t\ts64 kt1, kt2;\n\t\tint time_passed;\n\n\t\tkt1 = ktime_get_ns();\n\t\tudelay(usecs);\n\t\tkt2 = ktime_get_ns();\n\t\ttime_passed = kt2 - kt1;\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed > max)\n\t\t\tmax = time_passed;\n\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)\n\t\t\t++fail_count;\n\t\tWARN_ON(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" FAIL=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&udelay_test_lock"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\n#define DEBUGFS_FILENAME \"udelay_test\"\n\nstatic DEFINE_MUTEX(udelay_test_lock);\nstatic int udelay_test_usecs;\nstatic int udelay_test_iterations = DEFAULT_ITERATIONS;\n\nstatic int udelay_test_show(struct seq_file *s, void *v)\n{\n\tint usecs;\n\tint iters;\n\tint ret = 0;\n\n\tmutex_lock(&udelay_test_lock);\n\tusecs = udelay_test_usecs;\n\titers = udelay_test_iterations;\n\tmutex_unlock(&udelay_test_lock);\n\n\tif (usecs > 0 && iters > 0) {\n\t\treturn udelay_test_single(s, usecs, iters);\n\t} else if (usecs == 0) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_ts64(&ts);\n\t\tseq_printf(s, \"udelay() test (lpj=%ld kt=%lld.%09ld)\\n\",\n\t\t\t\tloops_per_jiffy, (s64)ts.tv_sec, ts.tv_nsec);\n\t\tseq_puts(s, \"usage:\\n\");\n\t\tseq_puts(s, \"echo USECS [ITERS] > \" DEBUGFS_FILENAME \"\\n\");\n\t\tseq_puts(s, \"cat \" DEBUGFS_FILENAME \"\\n\");\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "udelay_test_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/test_udelay.c",
    "lines": "27-65",
    "snippet": "static int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)\n{\n\tint min = 0, max = 0, fail_count = 0;\n\tuint64_t sum = 0;\n\tuint64_t avg;\n\tint i;\n\t/* Allow udelay to be up to 0.5% fast */\n\tint allowed_error_ns = usecs * 5;\n\n\tfor (i = 0; i < iters; ++i) {\n\t\ts64 kt1, kt2;\n\t\tint time_passed;\n\n\t\tkt1 = ktime_get_ns();\n\t\tudelay(usecs);\n\t\tkt2 = ktime_get_ns();\n\t\ttime_passed = kt2 - kt1;\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed > max)\n\t\t\tmax = time_passed;\n\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)\n\t\t\t++fail_count;\n\t\tWARN_ON(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" FAIL=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/module.h>",
      "#include <linux/ktime.h>",
      "#include <linux/delay.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"\\n\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\" FAIL=%d\"",
            "fail_count"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "avg",
            "iters"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "time_passed < 0"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "usecs"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n\nstatic int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)\n{\n\tint min = 0, max = 0, fail_count = 0;\n\tuint64_t sum = 0;\n\tuint64_t avg;\n\tint i;\n\t/* Allow udelay to be up to 0.5% fast */\n\tint allowed_error_ns = usecs * 5;\n\n\tfor (i = 0; i < iters; ++i) {\n\t\ts64 kt1, kt2;\n\t\tint time_passed;\n\n\t\tkt1 = ktime_get_ns();\n\t\tudelay(usecs);\n\t\tkt2 = ktime_get_ns();\n\t\ttime_passed = kt2 - kt1;\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed > max)\n\t\t\tmax = time_passed;\n\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)\n\t\t\t++fail_count;\n\t\tWARN_ON(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" FAIL=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}"
  }
]