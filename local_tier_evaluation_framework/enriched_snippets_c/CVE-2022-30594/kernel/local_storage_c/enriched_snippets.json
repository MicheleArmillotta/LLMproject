[
  {
    "function_name": "bpf_cgroup_storage_unlink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "588-605",
    "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&storage->list_cg"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&storage->node",
            "root"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_link",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "567-586",
    "snippet": "void bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup_id(cgroup);\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list_map, &map->list);\n\tlist_add(&storage->list_cg, &cgroup->bpf.storages);\n\tspin_unlock_bh(&map->lock);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&storage->list_cg",
            "&cgroup->bpf.storages"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_storage_insert(map, storage)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_insert",
          "args": [
            "map",
            "storage"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_insert",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "101-129",
          "snippet": "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "cgroup"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup_id(cgroup);\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list_map, &map->list);\n\tlist_add(&storage->list_cg, &cgroup->bpf.storages);\n\tspin_unlock_bh(&map->lock);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "551-565",
    "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&storage->rcu",
            "free_percpu_cgroup_storage_rcu"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "map"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
  },
  {
    "function_name": "free_percpu_cgroup_storage_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "542-549",
    "snippet": "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "storage->percpu_buf"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu_cgroup_storage_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "542-549",
          "snippet": "static void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_cgroup_storage",
            "rcu"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}"
  },
  {
    "function_name": "free_shared_cgroup_storage_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "533-540",
    "snippet": "static void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tkfree(storage->buf);\n\tkfree(storage);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_cgroup_storage",
            "rcu"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tkfree(storage->buf);\n\tkfree(storage);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "492-531",
    "snippet": "struct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tconst gfp_t gfp = __GFP_ZERO | GFP_USER;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tstorage = bpf_map_kmalloc_node(map, sizeof(struct bpf_cgroup_storage),\n\t\t\t\t       gfp, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = bpf_map_kmalloc_node(map, size, gfp,\n\t\t\t\t\t\t    map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t\tcheck_and_init_map_value(map, storage->buf->data);\n\t} else {\n\t\tstorage->percpu_buf = bpf_map_alloc_percpu(map, size, 8, gfp);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "storage"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_alloc_percpu",
          "args": [
            "map",
            "size",
            "8",
            "gfp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "452-463",
          "snippet": "void __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_and_init_map_value",
          "args": [
            "map",
            "storage->buf->data"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_kmalloc_node",
          "args": [
            "map",
            "size",
            "gfp",
            "map->numa_node"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kmalloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "427-438",
          "snippet": "void *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_calculate_size",
          "args": [
            "map",
            "&pages"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_calculate_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "475-490",
          "snippet": "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tconst gfp_t gfp = __GFP_ZERO | GFP_USER;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tstorage = bpf_map_kmalloc_node(map, sizeof(struct bpf_cgroup_storage),\n\t\t\t\t       gfp, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = bpf_map_kmalloc_node(map, size, gfp,\n\t\t\t\t\t\t    map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t\tcheck_and_init_map_value(map, storage->buf->data);\n\t} else {\n\t\tstorage->percpu_buf = bpf_map_alloc_percpu(map, size, 8, gfp);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_calculate_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "475-490",
    "snippet": "static size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "round_up(size, 8) * num_possible_cpus()",
            "PAGE_SIZE"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "8"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "sizeof(struct bpf_cgroup_storage) + size",
            "PAGE_SIZE"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "map"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_assign",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "463-473",
    "snippet": "int bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\n\tif (aux->cgroup_storage[stype] &&\n\t    aux->cgroup_storage[stype] != _map)\n\t\treturn -EBUSY;\n\n\taux->cgroup_storage[stype] = _map;\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "_map"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\n\tif (aux->cgroup_storage[stype] &&\n\t    aux->cgroup_storage[stype] != _map)\n\t\treturn -EBUSY;\n\n\taux->cgroup_storage[stype] = _map;\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_seq_show_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "414-447",
    "snippet": "static void cgroup_storage_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t struct seq_file *m)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map_to_storage(map), key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tseq_puts(m, \": \");\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  &READ_ONCE(storage->buf)->data[0], m);\n\t\tseq_puts(m, \"\\n\");\n\t} else {\n\t\tseq_puts(m, \": {\\n\");\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t\t  per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\t\t  m);\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t\tseq_puts(m, \"}\\n\");\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"}\\n\""
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "per_cpu_ptr(storage->percpu_buf, cpu)",
            "m"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5958-5964",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "storage->percpu_buf",
            "cpu"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tcpu%d: \"",
            "cpu"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "storage->buf"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_type",
          "args": [
            "map"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map_to_storage(map)",
            "key",
            "false"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "map"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void cgroup_storage_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t struct seq_file *m)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map_to_storage(map), key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tseq_puts(m, \": \");\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  &READ_ONCE(storage->buf)->data[0], m);\n\t\tseq_puts(m, \"\\n\");\n\t} else {\n\t\tseq_puts(m, \": {\\n\");\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t\t  per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\t\t  m);\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t\tseq_puts(m, \"}\\n\");\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cgroup_storage_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "356-412",
    "snippet": "static int cgroup_storage_check_btf(const struct bpf_map *map,\n\t\t\t\t    const struct btf *btf,\n\t\t\t\t    const struct btf_type *key_type,\n\t\t\t\t    const struct btf_type *value_type)\n{\n\tif (attach_type_isolated(map)) {\n\t\tstruct btf_member *m;\n\t\tu32 offset, size;\n\n\t\t/* Key is expected to be of struct bpf_cgroup_storage_key type,\n\t\t * which is:\n\t\t * struct bpf_cgroup_storage_key {\n\t\t *\t__u64\tcgroup_inode_id;\n\t\t *\t__u32\tattach_type;\n\t\t * };\n\t\t */\n\n\t\t/*\n\t\t * Key_type must be a structure with two fields.\n\t\t */\n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||\n\t\t    BTF_INFO_VLEN(key_type->info) != 2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * The first field must be a 64 bit integer at 0 offset.\n\t\t */\n\t\tm = (struct btf_member *)(key_type + 1);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, cgroup_inode_id);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, 0, size))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * The second field must be a 32 bit integer at 64 bit offset.\n\t\t */\n\t\tm++;\n\t\toffset = offsetof(struct bpf_cgroup_storage_key, attach_type);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, attach_type);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, offset, size))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tu32 int_data;\n\n\t\t/*\n\t\t * Key is expected to be u64, which stores the cgroup_inode_id\n\t\t */\n\n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\t\treturn -EINVAL;\n\n\t\tint_data = *(u32 *)(key_type + 1);\n\t\tif (BTF_INT_BITS(int_data) != 64 || BTF_INT_OFFSET(int_data))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_member_is_reg_int",
          "args": [
            "btf",
            "key_type",
            "m",
            "offset",
            "size"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "btf_member_is_reg_int",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "769-804",
          "snippet": "bool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size)\n{\n\tconst struct btf_type *t;\n\tu32 id, int_data;\n\tu8 nr_bits;\n\n\tid = m->type;\n\tt = btf_type_id_size(btf, &id, NULL);\n\tif (!t || !btf_type_is_int(t))\n\t\treturn false;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tif (btf_type_kflag(s)) {\n\t\tu32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\tu32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);\n\n\t\t/* if kflag set, int should be a regular int and\n\t\t * bit offset should be at byte boundary.\n\t\t */\n\t\treturn !bitfield_size &&\n\t\t       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&\n\t\t       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;\n\t}\n\n\tif (BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(m->offset) ||\n\t    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||\n\t    BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size)\n{\n\tconst struct btf_type *t;\n\tu32 id, int_data;\n\tu8 nr_bits;\n\n\tid = m->type;\n\tt = btf_type_id_size(btf, &id, NULL);\n\tif (!t || !btf_type_is_int(t))\n\t\treturn false;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tif (btf_type_kflag(s)) {\n\t\tu32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\tu32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);\n\n\t\t/* if kflag set, int should be a regular int and\n\t\t * bit offset should be at byte boundary.\n\t\t */\n\t\treturn !bitfield_size &&\n\t\t       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&\n\t\t       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;\n\t}\n\n\tif (BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(m->offset) ||\n\t    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||\n\t    BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structbpf_cgroup_storage_key",
            "attach_type"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structbpf_cgroup_storage_key",
            "cgroup_inode_id"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_VLEN",
          "args": [
            "key_type->info"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_type_isolated",
          "args": [
            "map"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_isolated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "33-36",
          "snippet": "static bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_check_btf(const struct bpf_map *map,\n\t\t\t\t    const struct btf *btf,\n\t\t\t\t    const struct btf_type *key_type,\n\t\t\t\t    const struct btf_type *value_type)\n{\n\tif (attach_type_isolated(map)) {\n\t\tstruct btf_member *m;\n\t\tu32 offset, size;\n\n\t\t/* Key is expected to be of struct bpf_cgroup_storage_key type,\n\t\t * which is:\n\t\t * struct bpf_cgroup_storage_key {\n\t\t *\t__u64\tcgroup_inode_id;\n\t\t *\t__u32\tattach_type;\n\t\t * };\n\t\t */\n\n\t\t/*\n\t\t * Key_type must be a structure with two fields.\n\t\t */\n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||\n\t\t    BTF_INFO_VLEN(key_type->info) != 2)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * The first field must be a 64 bit integer at 0 offset.\n\t\t */\n\t\tm = (struct btf_member *)(key_type + 1);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, cgroup_inode_id);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, 0, size))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * The second field must be a 32 bit integer at 64 bit offset.\n\t\t */\n\t\tm++;\n\t\toffset = offsetof(struct bpf_cgroup_storage_key, attach_type);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, attach_type);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, offset, size))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tu32 int_data;\n\n\t\t/*\n\t\t * Key is expected to be u64, which stores the cgroup_inode_id\n\t\t */\n\n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\t\treturn -EINVAL;\n\n\t\tint_data = *(u32 *)(key_type + 1);\n\t\tif (BTF_INT_BITS(int_data) != 64 || BTF_INT_OFFSET(int_data))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "351-354",
    "snippet": "static int cgroup_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cgroup_storage_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "330-349",
    "snippet": "static void cgroup_storage_map_free(struct bpf_map *_map)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct list_head *storages = &map->list;\n\tstruct bpf_cgroup_storage *storage, *stmp;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_for_each_entry_safe(storage, stmp, storages, list_map) {\n\t\tbpf_cgroup_storage_unlink(storage);\n\t\tbpf_cgroup_storage_free(storage);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&map->root));\n\tWARN_ON(!list_empty(&map->list));\n\n\tkfree(map);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&map->list)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&map->list"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&map->root)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&map->root"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_free",
          "args": [
            "storage"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "551-565",
          "snippet": "void bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_unlink",
          "args": [
            "storage"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "588-605",
          "snippet": "void bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "storage",
            "stmp",
            "storages",
            "list_map"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void cgroup_storage_map_free(struct bpf_map *_map)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct list_head *storages = &map->list;\n\tstruct bpf_cgroup_storage *storage, *stmp;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_for_each_entry_safe(storage, stmp, storages, list_map) {\n\t\tbpf_cgroup_storage_unlink(storage);\n\t\tbpf_cgroup_storage_free(storage);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&map->root));\n\tWARN_ON(!list_empty(&map->list));\n\n\tkfree(map);\n}"
  },
  {
    "function_name": "cgroup_storage_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "284-328",
    "snippet": "static struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\t__u32 max_value_size = BPF_LOCAL_STORAGE_MAX_VALUE_SIZE;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_cgroup_storage_map *map;\n\n\t/* percpu is bound by PCPU_MIN_UNIT_SIZE, non-percu\n\t * is the same as other local storages.\n\t */\n\tif (attr->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tmax_value_size = min_t(__u32, max_value_size,\n\t\t\t\t       PCPU_MIN_UNIT_SIZE);\n\n\tif (attr->key_size != sizeof(struct bpf_cgroup_storage_key) &&\n\t    attr->key_size != sizeof(__u64))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size > max_value_size)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (attr->map_flags & ~LOCAL_STORAGE_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->max_entries)\n\t\t/* max_entries is not used and enforced to be 0 */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kmalloc_node(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t   __GFP_ZERO | GFP_USER | __GFP_ACCOUNT, numa_node);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&map->map, attr);\n\n\tspin_lock_init(&map->lock);\n\tmap->root = RB_ROOT;\n\tINIT_LIST_HEAD(&map->list);\n\n\treturn &map->map;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [
      "#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&map->list"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&map->lock"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&map->map",
            "attr"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct bpf_cgroup_storage_map)",
            "__GFP_ZERO | GFP_USER | __GFP_ACCOUNT",
            "numa_node"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_flags_access_ok",
          "args": [
            "attr->map_flags"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "__u32",
            "max_value_size",
            "PCPU_MIN_UNIT_SIZE"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\n#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)\n\nstatic struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\t__u32 max_value_size = BPF_LOCAL_STORAGE_MAX_VALUE_SIZE;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_cgroup_storage_map *map;\n\n\t/* percpu is bound by PCPU_MIN_UNIT_SIZE, non-percu\n\t * is the same as other local storages.\n\t */\n\tif (attr->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tmax_value_size = min_t(__u32, max_value_size,\n\t\t\t\t       PCPU_MIN_UNIT_SIZE);\n\n\tif (attr->key_size != sizeof(struct bpf_cgroup_storage_key) &&\n\t    attr->key_size != sizeof(__u64))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size > max_value_size)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (attr->map_flags & ~LOCAL_STORAGE_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->max_entries)\n\t\t/* max_entries is not used and enforced to be 0 */\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kmalloc_node(sizeof(struct bpf_cgroup_storage_map),\n\t\t\t   __GFP_ZERO | GFP_USER | __GFP_ACCOUNT, numa_node);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&map->map, attr);\n\n\tspin_lock_init(&map->lock);\n\tmap->root = RB_ROOT;\n\tINIT_LIST_HEAD(&map->list);\n\n\treturn &map->map;\n}"
  },
  {
    "function_name": "cgroup_storage_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "244-282",
    "snippet": "static int cgroup_storage_get_next_key(struct bpf_map *_map, void *key,\n\t\t\t\t       void *_next_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (list_empty(&map->list))\n\t\tgoto enoent;\n\n\tif (key) {\n\t\tstorage = cgroup_storage_lookup(map, key, true);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\n\t\tstorage = list_next_entry(storage, list_map);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\t} else {\n\t\tstorage = list_first_entry(&map->list,\n\t\t\t\t\t struct bpf_cgroup_storage, list_map);\n\t}\n\n\tspin_unlock_bh(&map->lock);\n\n\tif (attach_type_isolated(&map->map)) {\n\t\tstruct bpf_cgroup_storage_key *next = _next_key;\n\t\t*next = storage->key;\n\t} else {\n\t\t__u64 *next = _next_key;\n\t\t*next = storage->key.cgroup_inode_id;\n\t}\n\treturn 0;\n\nenoent:\n\tspin_unlock_bh(&map->lock);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_type_isolated",
          "args": [
            "&map->map"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_isolated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "33-36",
          "snippet": "static bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&map->list",
            "structbpf_cgroup_storage",
            "list_map"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "storage",
            "list_map"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "true"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&map->list"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_get_next_key(struct bpf_map *_map, void *key,\n\t\t\t\t       void *_next_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (list_empty(&map->list))\n\t\tgoto enoent;\n\n\tif (key) {\n\t\tstorage = cgroup_storage_lookup(map, key, true);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\n\t\tstorage = list_next_entry(storage, list_map);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\t} else {\n\t\tstorage = list_first_entry(&map->list,\n\t\t\t\t\t struct bpf_cgroup_storage, list_map);\n\t}\n\n\tspin_unlock_bh(&map->lock);\n\n\tif (attach_type_isolated(&map->map)) {\n\t\tstruct bpf_cgroup_storage_key *next = _next_key;\n\t\t*next = storage->key;\n\t} else {\n\t\t__u64 *next = _next_key;\n\t\t*next = storage->key.cgroup_inode_id;\n\t}\n\treturn 0;\n\nenoent:\n\tspin_unlock_bh(&map->lock);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "bpf_percpu_cgroup_storage_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "210-242",
    "snippet": "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "per_cpu_ptr(storage->percpu_buf, cpu)",
            "value + off",
            "size"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "storage->percpu_buf",
            "cpu"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "_map->value_size",
            "8"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_percpu_cgroup_storage_copy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "181-208",
    "snippet": "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "value + off",
            "per_cpu_ptr(storage->percpu_buf, cpu)",
            "size"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "storage->percpu_buf",
            "cpu"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "_map->value_size",
            "8"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "143-179",
    "snippet": "static int cgroup_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t      void *value, u64 flags)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_storage_buffer *new;\n\n\tif (unlikely(flags & ~(BPF_F_LOCK | BPF_EXIST)))\n\t\treturn -EINVAL;\n\n\tif (unlikely((flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)))\n\t\treturn -EINVAL;\n\n\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,\n\t\t\t\t\tkey, false);\n\tif (!storage)\n\t\treturn -ENOENT;\n\n\tif (flags & BPF_F_LOCK) {\n\t\tcopy_map_value_locked(map, storage->buf->data, value, false);\n\t\treturn 0;\n\t}\n\n\tnew = bpf_map_kmalloc_node(map, struct_size(new, data, map->value_size),\n\t\t\t\t   __GFP_ZERO | GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   map->numa_node);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&new->data[0], value, map->value_size);\n\tcheck_and_init_map_value(map, new->data);\n\n\tnew = xchg(&storage->buf, new);\n\tkfree_rcu(new, rcu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "new",
            "rcu"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&storage->buf",
            "new"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_and_init_map_value",
          "args": [
            "map",
            "new->data"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->data[0]",
            "value",
            "map->value_size"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_kmalloc_node",
          "args": [
            "map",
            "struct_size(new, data, map->value_size)",
            "__GFP_ZERO | GFP_ATOMIC | __GFP_NOWARN",
            "map->numa_node"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kmalloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "427-438",
          "snippet": "void *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "new",
            "data",
            "map->value_size"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_map_value_locked",
          "args": [
            "map",
            "storage->buf->data",
            "value",
            "false"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "copy_map_value_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "337-351",
          "snippet": "void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "(struct bpf_cgroup_storage_map *)map",
            "key",
            "false"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & ~(BPF_F_LOCK | BPF_EXIST)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t      void *value, u64 flags)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_storage_buffer *new;\n\n\tif (unlikely(flags & ~(BPF_F_LOCK | BPF_EXIST)))\n\t\treturn -EINVAL;\n\n\tif (unlikely((flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)))\n\t\treturn -EINVAL;\n\n\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,\n\t\t\t\t\tkey, false);\n\tif (!storage)\n\t\treturn -ENOENT;\n\n\tif (flags & BPF_F_LOCK) {\n\t\tcopy_map_value_locked(map, storage->buf->data, value, false);\n\t\treturn 0;\n\t}\n\n\tnew = bpf_map_kmalloc_node(map, struct_size(new, data, map->value_size),\n\t\t\t\t   __GFP_ZERO | GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t   map->numa_node);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&new->data[0], value, map->value_size);\n\tcheck_and_init_map_value(map, new->data);\n\n\tnew = xchg(&storage->buf, new);\n\tkfree_rcu(new, rcu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "131-141",
    "snippet": "static void *cgroup_storage_lookup_elem(struct bpf_map *_map, void *key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage)\n\t\treturn NULL;\n\n\treturn &READ_ONCE(storage->buf)->data[0];\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "storage->buf"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_storage_lookup",
          "args": [
            "map",
            "key",
            "false"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_storage_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "65-99",
          "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_to_storage",
          "args": [
            "_map"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "map_to_storage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "28-31",
          "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic void *cgroup_storage_lookup_elem(struct bpf_map *_map, void *key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage)\n\t\treturn NULL;\n\n\treturn &READ_ONCE(storage->buf)->data[0];\n}"
  },
  {
    "function_name": "cgroup_storage_insert",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "101-129",
    "snippet": "static int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&storage->node",
            "root"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&storage->node",
            "parent",
            "new"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_key_cmp",
          "args": [
            "map",
            "&storage->key",
            "&this->key"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_key_cmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "38-63",
          "snippet": "static int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "*new",
            "structbpf_cgroup_storage",
            "node"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_storage_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "65-99",
    "snippet": "struct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_key_cmp",
          "args": [
            "map",
            "key",
            "&storage->key"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_key_cmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "38-63",
          "snippet": "static int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structbpf_cgroup_storage",
            "node"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map->lock"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_cgroup_storage_key_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "38-63",
    "snippet": "static int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_type_isolated",
          "args": [
            "&map->map"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_isolated",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "33-36",
          "snippet": "static bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "attach_type_isolated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "33-36",
    "snippet": "static bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}"
  },
  {
    "function_name": "map_to_storage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
    "lines": "28-31",
    "snippet": "static struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}",
    "includes": [
      "#include \"../cgroup/cgroup-internal.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/mm.h>",
      "#include <linux/filter.h>",
      "#include <linux/bug.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_local_storage.h>",
      "#include <linux/bpf.h>",
      "#include <linux/bpf-cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_cgroup_storage_map",
            "map"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}"
  }
]