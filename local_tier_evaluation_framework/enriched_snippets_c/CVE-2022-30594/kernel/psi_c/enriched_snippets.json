[
  {
    "function_name": "psi_proc_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1392-1401",
    "snippet": "static int __init psi_proc_init(void)\n{\n\tif (psi_enable) {\n\t\tproc_mkdir(\"pressure\", NULL);\n\t\tproc_create(\"pressure/io\", 0666, NULL, &psi_io_proc_ops);\n\t\tproc_create(\"pressure/memory\", 0666, NULL, &psi_memory_proc_ops);\n\t\tproc_create(\"pressure/cpu\", 0666, NULL, &psi_cpu_proc_ops);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct proc_ops psi_io_proc_ops = {\n\t.proc_open\t= psi_io_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_io_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};",
      "static const struct proc_ops psi_memory_proc_ops = {\n\t.proc_open\t= psi_memory_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_memory_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};",
      "static const struct proc_ops psi_cpu_proc_ops = {\n\t.proc_open\t= psi_cpu_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_cpu_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/cpu\"",
            "0666",
            "NULL",
            "&psi_cpu_proc_ops"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/memory\"",
            "0666",
            "NULL",
            "&psi_memory_proc_ops"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"pressure/io\"",
            "0666",
            "NULL",
            "&psi_io_proc_ops"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"pressure\"",
            "NULL"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic const struct proc_ops psi_io_proc_ops = {\n\t.proc_open\t= psi_io_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_io_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};\nstatic const struct proc_ops psi_memory_proc_ops = {\n\t.proc_open\t= psi_memory_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_memory_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};\nstatic const struct proc_ops psi_cpu_proc_ops = {\n\t.proc_open\t= psi_cpu_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= psi_cpu_write,\n\t.proc_poll\t= psi_fop_poll,\n\t.proc_release\t= psi_fop_release,\n};\n\nstatic int __init psi_proc_init(void)\n{\n\tif (psi_enable) {\n\t\tproc_mkdir(\"pressure\", NULL);\n\t\tproc_create(\"pressure/io\", 0666, NULL, &psi_io_proc_ops);\n\t\tproc_create(\"pressure/memory\", 0666, NULL, &psi_memory_proc_ops);\n\t\tproc_create(\"pressure/cpu\", 0666, NULL, &psi_cpu_proc_ops);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "psi_fop_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1357-1363",
    "snippet": "static int psi_fop_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpsi_trigger_replace(&seq->private, NULL);\n\treturn single_release(inode, file);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_single_release_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4903-4910",
          "snippet": "static int tracing_single_release_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn single_release(inode, file);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstatic int tracing_single_release_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn single_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_trigger_replace",
          "args": [
            "&seq->private",
            "NULL"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "psi_trigger_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1257-1267",
          "snippet": "void psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_fop_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpsi_trigger_replace(&seq->private, NULL);\n\treturn single_release(inode, file);\n}"
  },
  {
    "function_name": "psi_fop_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1350-1355",
    "snippet": "static __poll_t psi_fop_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\treturn psi_trigger_poll(&seq->private, file, wait);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_trigger_poll",
          "args": [
            "&seq->private",
            "file",
            "wait"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "psi_trigger_poll",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1269-1297",
          "snippet": "__poll_t psi_trigger_poll(void **trigger_ptr,\n\t\t\t\tstruct file *file, poll_table *wait)\n{\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tstruct psi_trigger *t;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\n\trcu_read_lock();\n\n\tt = rcu_dereference(*(void __rcu __force **)trigger_ptr);\n\tif (!t) {\n\t\trcu_read_unlock();\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\t}\n\tkref_get(&t->refcount);\n\n\trcu_read_unlock();\n\n\tpoll_wait(file, &t->event_wait, wait);\n\n\tif (cmpxchg(&t->event, 1, 0) == 1)\n\t\tret |= EPOLLPRI;\n\n\tkref_put(&t->refcount, psi_trigger_destroy);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\n__poll_t psi_trigger_poll(void **trigger_ptr,\n\t\t\t\tstruct file *file, poll_table *wait)\n{\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tstruct psi_trigger *t;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\n\trcu_read_lock();\n\n\tt = rcu_dereference(*(void __rcu __force **)trigger_ptr);\n\tif (!t) {\n\t\trcu_read_unlock();\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\t}\n\tkref_get(&t->refcount);\n\n\trcu_read_unlock();\n\n\tpoll_wait(file, &t->event_wait, wait);\n\n\tif (cmpxchg(&t->event, 1, 0) == 1)\n\t\tret |= EPOLLPRI;\n\n\tkref_put(&t->refcount, psi_trigger_destroy);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic __poll_t psi_fop_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\treturn psi_trigger_poll(&seq->private, file, wait);\n}"
  },
  {
    "function_name": "psi_cpu_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1344-1348",
    "snippet": "static ssize_t psi_cpu_write(struct file *file, const char __user *user_buf,\n\t\t\t     size_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_CPU);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_write",
          "args": [
            "file",
            "user_buf",
            "nbytes",
            "PSI_CPU"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "psi_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1299-1330",
          "snippet": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic ssize_t psi_cpu_write(struct file *file, const char __user *user_buf,\n\t\t\t     size_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_CPU);\n}"
  },
  {
    "function_name": "psi_memory_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1338-1342",
    "snippet": "static ssize_t psi_memory_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_MEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_write",
          "args": [
            "file",
            "user_buf",
            "nbytes",
            "PSI_MEM"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "psi_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1299-1330",
          "snippet": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic ssize_t psi_memory_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_MEM);\n}"
  },
  {
    "function_name": "psi_io_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1332-1336",
    "snippet": "static ssize_t psi_io_write(struct file *file, const char __user *user_buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_IO);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_write",
          "args": [
            "file",
            "user_buf",
            "nbytes",
            "PSI_IO"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "psi_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1299-1330",
          "snippet": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic ssize_t psi_io_write(struct file *file, const char __user *user_buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\treturn psi_write(file, user_buf, nbytes, PSI_IO);\n}"
  },
  {
    "function_name": "psi_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1299-1330",
    "snippet": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&seq->lock"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_trigger_replace",
          "args": [
            "&seq->private",
            "new"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "psi_trigger_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1257-1267",
          "snippet": "void psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&seq->lock"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_trigger_create",
          "args": [
            "&psi_system",
            "buf",
            "nbytes",
            "res"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "psi_trigger_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1123-1192",
          "snippet": "struct psi_trigger *psi_trigger_create(struct psi_group *group,\n\t\t\tchar *buf, size_t nbytes, enum psi_res res)\n{\n\tstruct psi_trigger *t;\n\tenum psi_states state;\n\tu32 threshold_us;\n\tu32 window_us;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (sscanf(buf, \"some %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_SOME + res * 2;\n\telse if (sscanf(buf, \"full %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_FULL + res * 2;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (state >= PSI_NONIDLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (window_us < WINDOW_MIN_US ||\n\t\twindow_us > WINDOW_MAX_US)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check threshold */\n\tif (threshold_us == 0 || threshold_us > window_us)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = kmalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt->group = group;\n\tt->state = state;\n\tt->threshold = threshold_us * NSEC_PER_USEC;\n\tt->win.size = window_us * NSEC_PER_USEC;\n\twindow_reset(&t->win, 0, 0, 0);\n\n\tt->event = 0;\n\tt->last_event_time = 0;\n\tinit_waitqueue_head(&t->event_wait);\n\tkref_init(&t->refcount);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!rcu_access_pointer(group->poll_task)) {\n\t\tstruct task_struct *task;\n\n\t\ttask = kthread_create(psi_poll_worker, group, \"psimon\");\n\t\tif (IS_ERR(task)) {\n\t\t\tkfree(t);\n\t\t\tmutex_unlock(&group->trigger_lock);\n\t\t\treturn ERR_CAST(task);\n\t\t}\n\t\tatomic_set(&group->poll_wakeup, 0);\n\t\twake_up_process(task);\n\t\trcu_assign_pointer(group->poll_task, task);\n\t}\n\n\tlist_add(&t->node, &group->triggers);\n\tgroup->poll_min_period = min(group->poll_min_period,\n\t\tdiv_u64(t->win.size, UPDATES_PER_WINDOW));\n\tgroup->nr_triggers[t->state]++;\n\tgroup->poll_states |= (1 << t->state);\n\n\tmutex_unlock(&group->trigger_lock);\n\n\treturn t;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */",
            "#define WINDOW_MAX_US 10000000\t/* Max window size is 10s */",
            "#define WINDOW_MIN_US 500000\t/* Min window size is 500ms */"
          ],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */\n#define WINDOW_MAX_US 10000000\t/* Max window size is 10s */\n#define WINDOW_MIN_US 500000\t/* Min window size is 500ms */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstruct psi_trigger *psi_trigger_create(struct psi_group *group,\n\t\t\tchar *buf, size_t nbytes, enum psi_res res)\n{\n\tstruct psi_trigger *t;\n\tenum psi_states state;\n\tu32 threshold_us;\n\tu32 window_us;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (sscanf(buf, \"some %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_SOME + res * 2;\n\telse if (sscanf(buf, \"full %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_FULL + res * 2;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (state >= PSI_NONIDLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (window_us < WINDOW_MIN_US ||\n\t\twindow_us > WINDOW_MAX_US)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check threshold */\n\tif (threshold_us == 0 || threshold_us > window_us)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = kmalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt->group = group;\n\tt->state = state;\n\tt->threshold = threshold_us * NSEC_PER_USEC;\n\tt->win.size = window_us * NSEC_PER_USEC;\n\twindow_reset(&t->win, 0, 0, 0);\n\n\tt->event = 0;\n\tt->last_event_time = 0;\n\tinit_waitqueue_head(&t->event_wait);\n\tkref_init(&t->refcount);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!rcu_access_pointer(group->poll_task)) {\n\t\tstruct task_struct *task;\n\n\t\ttask = kthread_create(psi_poll_worker, group, \"psimon\");\n\t\tif (IS_ERR(task)) {\n\t\t\tkfree(t);\n\t\t\tmutex_unlock(&group->trigger_lock);\n\t\t\treturn ERR_CAST(task);\n\t\t}\n\t\tatomic_set(&group->poll_wakeup, 0);\n\t\twake_up_process(task);\n\t\trcu_assign_pointer(group->poll_task, task);\n\t}\n\n\tlist_add(&t->node, &group->triggers);\n\tgroup->poll_min_period = min(group->poll_min_period,\n\t\tdiv_u64(t->win.size, UPDATES_PER_WINDOW));\n\tgroup->nr_triggers[t->state]++;\n\tgroup->poll_states |= (1 << t->state);\n\n\tmutex_unlock(&group->trigger_lock);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "user_buf",
            "buf_size"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nbytes",
            "sizeof(buf)"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nbytes)\n\t\treturn -EINVAL;\n\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size - 1] = '\\0';\n\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tseq = file->private_data;\n\t/* Take seq->lock to protect seq->private from concurrent writes */\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "psi_trigger_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1269-1297",
    "snippet": "__poll_t psi_trigger_poll(void **trigger_ptr,\n\t\t\t\tstruct file *file, poll_table *wait)\n{\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tstruct psi_trigger *t;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\n\trcu_read_lock();\n\n\tt = rcu_dereference(*(void __rcu __force **)trigger_ptr);\n\tif (!t) {\n\t\trcu_read_unlock();\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\t}\n\tkref_get(&t->refcount);\n\n\trcu_read_unlock();\n\n\tpoll_wait(file, &t->event_wait, wait);\n\n\tif (cmpxchg(&t->event, 1, 0) == 1)\n\t\tret |= EPOLLPRI;\n\n\tkref_put(&t->refcount, psi_trigger_destroy);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&t->refcount",
            "psi_trigger_destroy"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&t->event",
            "1",
            "0"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&t->event_wait",
            "wait"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&t->refcount"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*(void __rcu __force **)trigger_ptr"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\n__poll_t psi_trigger_poll(void **trigger_ptr,\n\t\t\t\tstruct file *file, poll_table *wait)\n{\n\t__poll_t ret = DEFAULT_POLLMASK;\n\tstruct psi_trigger *t;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\n\trcu_read_lock();\n\n\tt = rcu_dereference(*(void __rcu __force **)trigger_ptr);\n\tif (!t) {\n\t\trcu_read_unlock();\n\t\treturn DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI;\n\t}\n\tkref_get(&t->refcount);\n\n\trcu_read_unlock();\n\n\tpoll_wait(file, &t->event_wait, wait);\n\n\tif (cmpxchg(&t->event, 1, 0) == 1)\n\t\tret |= EPOLLPRI;\n\n\tkref_put(&t->refcount, psi_trigger_destroy);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "psi_trigger_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1257-1267",
    "snippet": "void psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&old->refcount",
            "psi_trigger_destroy"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trigger_ptr",
            "new"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_trigger_replace(void **trigger_ptr, struct psi_trigger *new)\n{\n\tstruct psi_trigger *old = *trigger_ptr;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\trcu_assign_pointer(*trigger_ptr, new);\n\tif (old)\n\t\tkref_put(&old->refcount, psi_trigger_destroy);\n}"
  },
  {
    "function_name": "psi_trigger_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1194-1255",
    "snippet": "static void psi_trigger_destroy(struct kref *ref)\n{\n\tstruct psi_trigger *t = container_of(ref, struct psi_trigger, refcount);\n\tstruct psi_group *group = t->group;\n\tstruct task_struct *task_to_destroy = NULL;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\t/*\n\t * Wakeup waiters to stop polling. Can happen if cgroup is deleted\n\t * from under a polling process.\n\t */\n\twake_up_interruptible(&t->event_wait);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!list_empty(&t->node)) {\n\t\tstruct psi_trigger *tmp;\n\t\tu64 period = ULLONG_MAX;\n\n\t\tlist_del(&t->node);\n\t\tgroup->nr_triggers[t->state]--;\n\t\tif (!group->nr_triggers[t->state])\n\t\t\tgroup->poll_states &= ~(1 << t->state);\n\t\t/* reset min update period for the remaining triggers */\n\t\tlist_for_each_entry(tmp, &group->triggers, node)\n\t\t\tperiod = min(period, div_u64(tmp->win.size,\n\t\t\t\t\tUPDATES_PER_WINDOW));\n\t\tgroup->poll_min_period = period;\n\t\t/* Destroy poll_task when the last trigger is destroyed */\n\t\tif (group->poll_states == 0) {\n\t\t\tgroup->polling_until = 0;\n\t\t\ttask_to_destroy = rcu_dereference_protected(\n\t\t\t\t\tgroup->poll_task,\n\t\t\t\t\tlockdep_is_held(&group->trigger_lock));\n\t\t\trcu_assign_pointer(group->poll_task, NULL);\n\t\t\tdel_timer(&group->poll_timer);\n\t\t}\n\t}\n\n\tmutex_unlock(&group->trigger_lock);\n\n\t/*\n\t * Wait for both *trigger_ptr from psi_trigger_replace and\n\t * poll_task RCUs to complete their read-side critical sections\n\t * before destroying the trigger and optionally the poll_task\n\t */\n\tsynchronize_rcu();\n\t/*\n\t * Stop kthread 'psimon' after releasing trigger_lock to prevent a\n\t * deadlock while waiting for psi_poll_work to acquire trigger_lock\n\t */\n\tif (task_to_destroy) {\n\t\t/*\n\t\t * After the RCU grace period has expired, the worker\n\t\t * can no longer be found through group->poll_task.\n\t\t */\n\t\tkthread_stop(task_to_destroy);\n\t}\n\tkfree(t);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */"
    ],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "task_to_destroy"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "626-635",
          "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include <linux/sched/cpufreq.h>\n#include \"sched.h\"\n\nstatic void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&group->poll_timer"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "group->poll_task",
            "NULL"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "group->poll_task",
            "lockdep_is_held(&group->trigger_lock)"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "period",
            "div_u64(tmp->win.size,\n\t\t\t\t\tUPDATES_PER_WINDOW)"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "tmp->win.size",
            "UPDATES_PER_WINDOW"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&group->triggers",
            "node"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&t->node"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&t->node"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&t->event_wait"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structpsi_trigger",
            "refcount"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_trigger_destroy(struct kref *ref)\n{\n\tstruct psi_trigger *t = container_of(ref, struct psi_trigger, refcount);\n\tstruct psi_group *group = t->group;\n\tstruct task_struct *task_to_destroy = NULL;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\t/*\n\t * Wakeup waiters to stop polling. Can happen if cgroup is deleted\n\t * from under a polling process.\n\t */\n\twake_up_interruptible(&t->event_wait);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!list_empty(&t->node)) {\n\t\tstruct psi_trigger *tmp;\n\t\tu64 period = ULLONG_MAX;\n\n\t\tlist_del(&t->node);\n\t\tgroup->nr_triggers[t->state]--;\n\t\tif (!group->nr_triggers[t->state])\n\t\t\tgroup->poll_states &= ~(1 << t->state);\n\t\t/* reset min update period for the remaining triggers */\n\t\tlist_for_each_entry(tmp, &group->triggers, node)\n\t\t\tperiod = min(period, div_u64(tmp->win.size,\n\t\t\t\t\tUPDATES_PER_WINDOW));\n\t\tgroup->poll_min_period = period;\n\t\t/* Destroy poll_task when the last trigger is destroyed */\n\t\tif (group->poll_states == 0) {\n\t\t\tgroup->polling_until = 0;\n\t\t\ttask_to_destroy = rcu_dereference_protected(\n\t\t\t\t\tgroup->poll_task,\n\t\t\t\t\tlockdep_is_held(&group->trigger_lock));\n\t\t\trcu_assign_pointer(group->poll_task, NULL);\n\t\t\tdel_timer(&group->poll_timer);\n\t\t}\n\t}\n\n\tmutex_unlock(&group->trigger_lock);\n\n\t/*\n\t * Wait for both *trigger_ptr from psi_trigger_replace and\n\t * poll_task RCUs to complete their read-side critical sections\n\t * before destroying the trigger and optionally the poll_task\n\t */\n\tsynchronize_rcu();\n\t/*\n\t * Stop kthread 'psimon' after releasing trigger_lock to prevent a\n\t * deadlock while waiting for psi_poll_work to acquire trigger_lock\n\t */\n\tif (task_to_destroy) {\n\t\t/*\n\t\t * After the RCU grace period has expired, the worker\n\t\t * can no longer be found through group->poll_task.\n\t\t */\n\t\tkthread_stop(task_to_destroy);\n\t}\n\tkfree(t);\n}"
  },
  {
    "function_name": "psi_trigger_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1123-1192",
    "snippet": "struct psi_trigger *psi_trigger_create(struct psi_group *group,\n\t\t\tchar *buf, size_t nbytes, enum psi_res res)\n{\n\tstruct psi_trigger *t;\n\tenum psi_states state;\n\tu32 threshold_us;\n\tu32 window_us;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (sscanf(buf, \"some %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_SOME + res * 2;\n\telse if (sscanf(buf, \"full %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_FULL + res * 2;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (state >= PSI_NONIDLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (window_us < WINDOW_MIN_US ||\n\t\twindow_us > WINDOW_MAX_US)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check threshold */\n\tif (threshold_us == 0 || threshold_us > window_us)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = kmalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt->group = group;\n\tt->state = state;\n\tt->threshold = threshold_us * NSEC_PER_USEC;\n\tt->win.size = window_us * NSEC_PER_USEC;\n\twindow_reset(&t->win, 0, 0, 0);\n\n\tt->event = 0;\n\tt->last_event_time = 0;\n\tinit_waitqueue_head(&t->event_wait);\n\tkref_init(&t->refcount);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!rcu_access_pointer(group->poll_task)) {\n\t\tstruct task_struct *task;\n\n\t\ttask = kthread_create(psi_poll_worker, group, \"psimon\");\n\t\tif (IS_ERR(task)) {\n\t\t\tkfree(t);\n\t\t\tmutex_unlock(&group->trigger_lock);\n\t\t\treturn ERR_CAST(task);\n\t\t}\n\t\tatomic_set(&group->poll_wakeup, 0);\n\t\twake_up_process(task);\n\t\trcu_assign_pointer(group->poll_task, task);\n\t}\n\n\tlist_add(&t->node, &group->triggers);\n\tgroup->poll_min_period = min(group->poll_min_period,\n\t\tdiv_u64(t->win.size, UPDATES_PER_WINDOW));\n\tgroup->nr_triggers[t->state]++;\n\tgroup->poll_states |= (1 << t->state);\n\n\tmutex_unlock(&group->trigger_lock);\n\n\treturn t;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */",
      "#define WINDOW_MAX_US 10000000\t/* Max window size is 10s */",
      "#define WINDOW_MIN_US 500000\t/* Min window size is 500ms */"
    ],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "group->poll_min_period",
            "div_u64(t->win.size, UPDATES_PER_WINDOW)"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "249-252",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "t->win.size",
            "UPDATES_PER_WINDOW"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&t->node",
            "&group->triggers"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "group->poll_task",
            "task"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&group->poll_wakeup",
            "0"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "task"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "psi_poll_worker",
            "group",
            "\"psimon\""
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "group->poll_task"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&t->refcount"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&t->event_wait"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "window_reset",
          "args": [
            "&t->win",
            "0",
            "0",
            "0"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "window_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "466-472",
          "snippet": "static void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*t)",
            "GFP_KERNEL"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"full %u %u\"",
            "&threshold_us",
            "&window_us"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"some %u %u\"",
            "&threshold_us",
            "&window_us"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */\n#define WINDOW_MAX_US 10000000\t/* Max window size is 10s */\n#define WINDOW_MIN_US 500000\t/* Min window size is 500ms */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstruct psi_trigger *psi_trigger_create(struct psi_group *group,\n\t\t\tchar *buf, size_t nbytes, enum psi_res res)\n{\n\tstruct psi_trigger *t;\n\tenum psi_states state;\n\tu32 threshold_us;\n\tu32 window_us;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (sscanf(buf, \"some %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_SOME + res * 2;\n\telse if (sscanf(buf, \"full %u %u\", &threshold_us, &window_us) == 2)\n\t\tstate = PSI_IO_FULL + res * 2;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (state >= PSI_NONIDLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (window_us < WINDOW_MIN_US ||\n\t\twindow_us > WINDOW_MAX_US)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check threshold */\n\tif (threshold_us == 0 || threshold_us > window_us)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tt = kmalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt->group = group;\n\tt->state = state;\n\tt->threshold = threshold_us * NSEC_PER_USEC;\n\tt->win.size = window_us * NSEC_PER_USEC;\n\twindow_reset(&t->win, 0, 0, 0);\n\n\tt->event = 0;\n\tt->last_event_time = 0;\n\tinit_waitqueue_head(&t->event_wait);\n\tkref_init(&t->refcount);\n\n\tmutex_lock(&group->trigger_lock);\n\n\tif (!rcu_access_pointer(group->poll_task)) {\n\t\tstruct task_struct *task;\n\n\t\ttask = kthread_create(psi_poll_worker, group, \"psimon\");\n\t\tif (IS_ERR(task)) {\n\t\t\tkfree(t);\n\t\t\tmutex_unlock(&group->trigger_lock);\n\t\t\treturn ERR_CAST(task);\n\t\t}\n\t\tatomic_set(&group->poll_wakeup, 0);\n\t\twake_up_process(task);\n\t\trcu_assign_pointer(group->poll_task, task);\n\t}\n\n\tlist_add(&t->node, &group->triggers);\n\tgroup->poll_min_period = min(group->poll_min_period,\n\t\tdiv_u64(t->win.size, UPDATES_PER_WINDOW));\n\tgroup->nr_triggers[t->state]++;\n\tgroup->poll_states |= (1 << t->state);\n\n\tmutex_unlock(&group->trigger_lock);\n\n\treturn t;\n}"
  },
  {
    "function_name": "psi_cpu_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1118-1121",
    "snippet": "static int psi_cpu_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_cpu_show);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_open",
          "args": [
            "file",
            "psi_cpu_show"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "psi_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1100-1106",
          "snippet": "static int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_cpu_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_cpu_show);\n}"
  },
  {
    "function_name": "psi_memory_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1113-1116",
    "snippet": "static int psi_memory_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_memory_show);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_open",
          "args": [
            "file",
            "psi_memory_show"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "psi_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1100-1106",
          "snippet": "static int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_memory_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_memory_show);\n}"
  },
  {
    "function_name": "psi_io_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1108-1111",
    "snippet": "static int psi_io_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_io_show);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_open",
          "args": [
            "file",
            "psi_io_show"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "psi_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1100-1106",
          "snippet": "static int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_io_open(struct inode *inode, struct file *file)\n{\n\treturn psi_open(file, psi_io_show);\n}"
  },
  {
    "function_name": "psi_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1100-1106",
    "snippet": "static int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "psi_show",
            "NULL"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_open(struct file *file, int (*psi_show)(struct seq_file *, void *))\n{\n\tif (file->f_mode & FMODE_WRITE && !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn single_open(file, psi_show, NULL);\n}"
  },
  {
    "function_name": "psi_cpu_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1095-1098",
    "snippet": "static int psi_cpu_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_CPU);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_CPU"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1048-1083",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_cpu_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_CPU);\n}"
  },
  {
    "function_name": "psi_memory_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1090-1093",
    "snippet": "static int psi_memory_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_MEM);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_MEM"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1048-1083",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_memory_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_MEM);\n}"
  },
  {
    "function_name": "psi_io_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1085-1088",
    "snippet": "static int psi_io_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_IO);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "m",
            "&psi_system",
            "PSI_IO"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "psi_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "1048-1083",
          "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic int psi_io_show(struct seq_file *m, void *v)\n{\n\treturn psi_show(m, &psi_system, PSI_IO);\n}"
  },
  {
    "function_name": "psi_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "1048-1083",
    "snippet": "int psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\"",
            "full ? \"full\" : \"some\"",
            "LOAD_INT(avg[0])",
            "LOAD_FRAC(avg[0])",
            "LOAD_INT(avg[1])",
            "LOAD_FRAC(avg[1])",
            "LOAD_INT(avg[2])",
            "LOAD_FRAC(avg[2])",
            "total"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[2]"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[2]"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[1]"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[1]"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "avg[0]"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "avg[0]"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "group->total[PSI_AVGS][res * 2 + full]",
            "NSEC_PER_USEC"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->avgs_lock"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_averages",
          "args": [
            "group",
            "now"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "update_averages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "377-428",
          "snippet": "static u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period",
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_percpu_times",
          "args": [
            "group",
            "PSI_AVGS",
            "NULL"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "collect_percpu_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "322-375",
          "snippet": "static void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->avgs_lock"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nint psi_show(struct seq_file *m, struct psi_group *group, enum psi_res res)\n{\n\tint full;\n\tu64 now;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Update averages before reporting them */\n\tmutex_lock(&group->avgs_lock);\n\tnow = sched_clock();\n\tcollect_percpu_times(group, PSI_AVGS, NULL);\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\tmutex_unlock(&group->avgs_lock);\n\n\tfor (full = 0; full < 2; full++) {\n\t\tunsigned long avg[3];\n\t\tu64 total;\n\t\tint w;\n\n\t\tfor (w = 0; w < 3; w++)\n\t\t\tavg[w] = group->avg[res * 2 + full][w];\n\t\ttotal = div_u64(group->total[PSI_AVGS][res * 2 + full],\n\t\t\t\tNSEC_PER_USEC);\n\n\t\tseq_printf(m, \"%s avg10=%lu.%02lu avg60=%lu.%02lu avg300=%lu.%02lu total=%llu\\n\",\n\t\t\t   full ? \"full\" : \"some\",\n\t\t\t   LOAD_INT(avg[0]), LOAD_FRAC(avg[0]),\n\t\t\t   LOAD_INT(avg[1]), LOAD_FRAC(avg[1]),\n\t\t\t   LOAD_INT(avg[2]), LOAD_FRAC(avg[2]),\n\t\t\t   total);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_move_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "992-1045",
    "snippet": "void cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tunsigned int task_flags;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled)) {\n\t\t/*\n\t\t * Lame to do this here, but the scheduler cannot be locked\n\t\t * from the outside, so we move cgroups from inside sched/.\n\t\t */\n\t\trcu_assign_pointer(task->cgroups, to);\n\t\treturn;\n\t}\n\n\trq = task_rq_lock(task, &rf);\n\n\t/*\n\t * We may race with schedule() dropping the rq lock between\n\t * deactivating prev and switching to next. Because the psi\n\t * updates from the deactivation are deferred to the switch\n\t * callback to save cgroup tree updates, the task's scheduling\n\t * state here is not coherent with its psi state:\n\t *\n\t * schedule()                   cgroup_move_task()\n\t *   rq_lock()\n\t *   deactivate_task()\n\t *     p->on_rq = 0\n\t *     psi_dequeue() // defers TSK_RUNNING & TSK_IOWAIT updates\n\t *   pick_next_task()\n\t *     rq_unlock()\n\t *                                rq_lock()\n\t *                                psi_task_change() // old cgroup\n\t *                                task->cgroups = to\n\t *                                psi_task_change() // new cgroup\n\t *                                rq_unlock()\n\t *     rq_lock()\n\t *   psi_sched_switch() // does deferred updates in new cgroup\n\t *\n\t * Don't rely on the scheduling state. Use psi_flags instead.\n\t */\n\ttask_flags = task->psi_flags;\n\n\tif (task_flags)\n\t\tpsi_task_change(task, task_flags, 0);\n\n\t/* See comment above */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (task_flags)\n\t\tpsi_task_change(task, 0, task_flags);\n\n\ttask_rq_unlock(rq, task, &rf);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "task",
            "&rf"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "task",
            "0",
            "task_flags"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "801-828",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->cgroups",
            "to"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "task",
            "&rf"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "582-619",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->cgroups",
            "to"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nvoid cgroup_move_task(struct task_struct *task, struct css_set *to)\n{\n\tunsigned int task_flags;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled)) {\n\t\t/*\n\t\t * Lame to do this here, but the scheduler cannot be locked\n\t\t * from the outside, so we move cgroups from inside sched/.\n\t\t */\n\t\trcu_assign_pointer(task->cgroups, to);\n\t\treturn;\n\t}\n\n\trq = task_rq_lock(task, &rf);\n\n\t/*\n\t * We may race with schedule() dropping the rq lock between\n\t * deactivating prev and switching to next. Because the psi\n\t * updates from the deactivation are deferred to the switch\n\t * callback to save cgroup tree updates, the task's scheduling\n\t * state here is not coherent with its psi state:\n\t *\n\t * schedule()                   cgroup_move_task()\n\t *   rq_lock()\n\t *   deactivate_task()\n\t *     p->on_rq = 0\n\t *     psi_dequeue() // defers TSK_RUNNING & TSK_IOWAIT updates\n\t *   pick_next_task()\n\t *     rq_unlock()\n\t *                                rq_lock()\n\t *                                psi_task_change() // old cgroup\n\t *                                task->cgroups = to\n\t *                                psi_task_change() // new cgroup\n\t *                                rq_unlock()\n\t *     rq_lock()\n\t *   psi_sched_switch() // does deferred updates in new cgroup\n\t *\n\t * Don't rely on the scheduling state. Use psi_flags instead.\n\t */\n\ttask_flags = task->psi_flags;\n\n\tif (task_flags)\n\t\tpsi_task_change(task, task_flags, 0);\n\n\t/* See comment above */\n\trcu_assign_pointer(task->cgroups, to);\n\n\tif (task_flags)\n\t\tpsi_task_change(task, 0, task_flags);\n\n\ttask_rq_unlock(rq, task, &rf);\n}"
  },
  {
    "function_name": "psi_cgroup_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "969-978",
    "snippet": "void psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.avgs_work);\n\tfree_percpu(cgroup->psi.pcpu);\n\t/* All triggers must be removed by now */\n\tWARN_ONCE(cgroup->psi.poll_states, \"psi: trigger leak\\n\");\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "cgroup->psi.poll_states",
            "\"psi: trigger leak\\n\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cgroup->psi.pcpu"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&cgroup->psi.avgs_work"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_delayed_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3310-3313",
          "snippet": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_cgroup_free(struct cgroup *cgroup)\n{\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&cgroup->psi.avgs_work);\n\tfree_percpu(cgroup->psi.pcpu);\n\t/* All triggers must be removed by now */\n\tWARN_ONCE(cgroup->psi.poll_states, \"psi: trigger leak\\n\");\n}"
  },
  {
    "function_name": "psi_cgroup_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "957-967",
    "snippet": "int psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "group_init",
          "args": [
            "&cgroup->psi"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "group_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "195-217",
          "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpsi_group_cpu"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nint psi_cgroup_alloc(struct cgroup *cgroup)\n{\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn 0;\n\n\tcgroup->psi.pcpu = alloc_percpu(struct psi_group_cpu);\n\tif (!cgroup->psi.pcpu)\n\t\treturn -ENOMEM;\n\tgroup_init(&cgroup->psi);\n\treturn 0;\n}"
  },
  {
    "function_name": "psi_memstall_leave",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "933-954",
    "snippet": "void psi_memstall_leave(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * in_memstall clearing & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we could\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->in_memstall = 0;\n\tpsi_task_change(current, TSK_MEMSTALL | TSK_MEMSTALL_RUNNING, 0);\n\n\trq_unlock_irq(rq, &rf);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1628-1634",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock_irq(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock_irq(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "current",
            "TSK_MEMSTALL | TSK_MEMSTALL_RUNNING",
            "0"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "801-828",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq_lock_irq",
          "args": [
            "&rf"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "this_rq_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1644-1654",
          "snippet": "static inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_memstall_leave(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * in_memstall clearing & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we could\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->in_memstall = 0;\n\tpsi_task_change(current, TSK_MEMSTALL | TSK_MEMSTALL_RUNNING, 0);\n\n\trq_unlock_irq(rq, &rf);\n}"
  },
  {
    "function_name": "psi_memstall_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "903-925",
    "snippet": "void psi_memstall_enter(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\t*flags = current->in_memstall;\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * in_memstall setting & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we can\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->in_memstall = 1;\n\tpsi_task_change(current, 0, TSK_MEMSTALL | TSK_MEMSTALL_RUNNING);\n\n\trq_unlock_irq(rq, &rf);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1628-1634",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock_irq(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock_irq(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_change",
          "args": [
            "current",
            "0",
            "TSK_MEMSTALL | TSK_MEMSTALL_RUNNING"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "801-828",
          "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq_lock_irq",
          "args": [
            "&rf"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "this_rq_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1644-1654",
          "snippet": "static inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_disabled"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_memstall_enter(unsigned long *flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn;\n\n\t*flags = current->in_memstall;\n\tif (*flags)\n\t\treturn;\n\t/*\n\t * in_memstall setting & accounting needs to be atomic wrt\n\t * changes to the task's scheduling state, otherwise we can\n\t * race with CPU migration.\n\t */\n\trq = this_rq_lock_irq(&rf);\n\n\tcurrent->in_memstall = 1;\n\tpsi_task_change(current, 0, TSK_MEMSTALL | TSK_MEMSTALL_RUNNING);\n\n\trq_unlock_irq(rq, &rf);\n}"
  },
  {
    "function_name": "psi_task_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "830-894",
    "snippet": "void psi_task_switch(struct task_struct *prev, struct task_struct *next,\n\t\t     bool sleep)\n{\n\tstruct psi_group *group, *common = NULL;\n\tint cpu = task_cpu(prev);\n\tvoid *iter;\n\tu64 now = cpu_clock(cpu);\n\n\tif (next->pid) {\n\t\tbool identical_state;\n\n\t\tpsi_flags_change(next, 0, TSK_ONCPU);\n\t\t/*\n\t\t * When switching between tasks that have an identical\n\t\t * runtime state, the cgroup that contains both tasks\n\t\t * we reach the first common ancestor. Iterate @next's\n\t\t * ancestors only until we encounter @prev's ONCPU.\n\t\t */\n\t\tidentical_state = prev->psi_flags == next->psi_flags;\n\t\titer = NULL;\n\t\twhile ((group = iterate_groups(next, &iter))) {\n\t\t\tif (identical_state &&\n\t\t\t    per_cpu_ptr(group->pcpu, cpu)->tasks[NR_ONCPU]) {\n\t\t\t\tcommon = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpsi_group_change(group, cpu, 0, TSK_ONCPU, now, true);\n\t\t}\n\t}\n\n\tif (prev->pid) {\n\t\tint clear = TSK_ONCPU, set = 0;\n\n\t\t/*\n\t\t * When we're going to sleep, psi_dequeue() lets us\n\t\t * handle TSK_RUNNING, TSK_MEMSTALL_RUNNING and\n\t\t * TSK_IOWAIT here, where we can combine it with\n\t\t * TSK_ONCPU and save walking common ancestors twice.\n\t\t */\n\t\tif (sleep) {\n\t\t\tclear |= TSK_RUNNING;\n\t\t\tif (prev->in_memstall)\n\t\t\t\tclear |= TSK_MEMSTALL_RUNNING;\n\t\t\tif (prev->in_iowait)\n\t\t\t\tset |= TSK_IOWAIT;\n\t\t}\n\n\t\tpsi_flags_change(prev, clear, set);\n\n\t\titer = NULL;\n\t\twhile ((group = iterate_groups(prev, &iter)) && group != common)\n\t\t\tpsi_group_change(group, cpu, clear, set, now, true);\n\n\t\t/*\n\t\t * TSK_ONCPU is handled up to the common ancestor. If we're tasked\n\t\t * with dequeuing too, finish that for the rest of the hierarchy.\n\t\t */\n\t\tif (sleep) {\n\t\t\tclear &= ~TSK_ONCPU;\n\t\t\tfor (; group; group = iterate_groups(prev, &iter))\n\t\t\t\tpsi_group_change(group, cpu, clear, set, now, true);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_group_change",
          "args": [
            "group",
            "cpu",
            "clear",
            "set",
            "now",
            "true"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "psi_group_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "692-760",
          "snippet": "static void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_groups",
          "args": [
            "prev",
            "&iter"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "762-784",
          "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_flags_change",
          "args": [
            "prev",
            "clear",
            "set"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "psi_flags_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "786-799",
          "snippet": "static void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "cpu"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "10734-10751",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "prev"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nvoid psi_task_switch(struct task_struct *prev, struct task_struct *next,\n\t\t     bool sleep)\n{\n\tstruct psi_group *group, *common = NULL;\n\tint cpu = task_cpu(prev);\n\tvoid *iter;\n\tu64 now = cpu_clock(cpu);\n\n\tif (next->pid) {\n\t\tbool identical_state;\n\n\t\tpsi_flags_change(next, 0, TSK_ONCPU);\n\t\t/*\n\t\t * When switching between tasks that have an identical\n\t\t * runtime state, the cgroup that contains both tasks\n\t\t * we reach the first common ancestor. Iterate @next's\n\t\t * ancestors only until we encounter @prev's ONCPU.\n\t\t */\n\t\tidentical_state = prev->psi_flags == next->psi_flags;\n\t\titer = NULL;\n\t\twhile ((group = iterate_groups(next, &iter))) {\n\t\t\tif (identical_state &&\n\t\t\t    per_cpu_ptr(group->pcpu, cpu)->tasks[NR_ONCPU]) {\n\t\t\t\tcommon = group;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpsi_group_change(group, cpu, 0, TSK_ONCPU, now, true);\n\t\t}\n\t}\n\n\tif (prev->pid) {\n\t\tint clear = TSK_ONCPU, set = 0;\n\n\t\t/*\n\t\t * When we're going to sleep, psi_dequeue() lets us\n\t\t * handle TSK_RUNNING, TSK_MEMSTALL_RUNNING and\n\t\t * TSK_IOWAIT here, where we can combine it with\n\t\t * TSK_ONCPU and save walking common ancestors twice.\n\t\t */\n\t\tif (sleep) {\n\t\t\tclear |= TSK_RUNNING;\n\t\t\tif (prev->in_memstall)\n\t\t\t\tclear |= TSK_MEMSTALL_RUNNING;\n\t\t\tif (prev->in_iowait)\n\t\t\t\tset |= TSK_IOWAIT;\n\t\t}\n\n\t\tpsi_flags_change(prev, clear, set);\n\n\t\titer = NULL;\n\t\twhile ((group = iterate_groups(prev, &iter)) && group != common)\n\t\t\tpsi_group_change(group, cpu, clear, set, now, true);\n\n\t\t/*\n\t\t * TSK_ONCPU is handled up to the common ancestor. If we're tasked\n\t\t * with dequeuing too, finish that for the rest of the hierarchy.\n\t\t */\n\t\tif (sleep) {\n\t\t\tclear &= ~TSK_ONCPU;\n\t\t\tfor (; group; group = iterate_groups(prev, &iter))\n\t\t\t\tpsi_group_change(group, cpu, clear, set, now, true);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "psi_task_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "801-828",
    "snippet": "void psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_group_change",
          "args": [
            "group",
            "cpu",
            "clear",
            "set",
            "now",
            "wake_clock"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "psi_group_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "692-760",
          "snippet": "static void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_groups",
          "args": [
            "task",
            "&iter"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_groups",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "762-784",
          "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_worker_last_func",
          "args": [
            "task"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "wq_worker_last_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "964-969",
          "snippet": "work_func_t wq_worker_last_func(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\treturn worker->last_func;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nwork_func_t wq_worker_last_func(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\treturn worker->last_func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "cpu"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "10734-10751",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_flags_change",
          "args": [
            "task",
            "clear",
            "set"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "psi_flags_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "786-799",
          "snippet": "static void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nvoid psi_task_change(struct task_struct *task, int clear, int set)\n{\n\tint cpu = task_cpu(task);\n\tstruct psi_group *group;\n\tbool wake_clock = true;\n\tvoid *iter = NULL;\n\tu64 now;\n\n\tif (!task->pid)\n\t\treturn;\n\n\tpsi_flags_change(task, clear, set);\n\n\tnow = cpu_clock(cpu);\n\t/*\n\t * Periodic aggregation shuts off if there is a period of no\n\t * task changes, so we wake it back up if necessary. However,\n\t * don't do this if the task change is the aggregation worker\n\t * itself going to sleep, or we'll ping-pong forever.\n\t */\n\tif (unlikely((clear & TSK_RUNNING) &&\n\t\t     (task->flags & PF_WQ_WORKER) &&\n\t\t     wq_worker_last_func(task) == psi_avgs_work))\n\t\twake_clock = false;\n\n\twhile ((group = iterate_groups(task, &iter)))\n\t\tpsi_group_change(group, cpu, clear, set, now, wake_clock);\n}"
  },
  {
    "function_name": "psi_flags_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "786-799",
    "snippet": "static void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\"",
            "task->pid",
            "task->comm",
            "task_cpu(task)",
            "task->psi_flags",
            "clear",
            "set"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void psi_flags_change(struct task_struct *task, int clear, int set)\n{\n\tif (((task->psi_flags & set) ||\n\t     (task->psi_flags & clear) != clear) &&\n\t    !psi_bug) {\n\t\tprintk_deferred(KERN_ERR \"psi: inconsistent task state! task=%d:%s cpu=%d psi_flags=%x clear=%x set=%x\\n\",\n\t\t\t\ttask->pid, task->comm, task_cpu(task),\n\t\t\t\ttask->psi_flags, clear, set);\n\t\tpsi_bug = 1;\n\t}\n\n\ttask->psi_flags &= ~clear;\n\ttask->psi_flags |= set;\n}"
  },
  {
    "function_name": "iterate_groups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "762-784",
    "snippet": "static struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_psi",
          "args": [
            "cgroup"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgroup"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "*iter"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&psi_cgroups_enabled"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nstatic struct psi_group *iterate_groups(struct task_struct *task, void **iter)\n{\n\tif (*iter == &psi_system)\n\t\treturn NULL;\n\n#ifdef CONFIG_CGROUPS\n\tif (static_branch_likely(&psi_cgroups_enabled)) {\n\t\tstruct cgroup *cgroup = NULL;\n\n\t\tif (!*iter)\n\t\t\tcgroup = task->cgroups->dfl_cgrp;\n\t\telse\n\t\t\tcgroup = cgroup_parent(*iter);\n\n\t\tif (cgroup && cgroup_parent(cgroup)) {\n\t\t\t*iter = cgroup;\n\t\t\treturn cgroup_psi(cgroup);\n\t\t}\n\t}\n#endif\n\t*iter = &psi_system;\n\treturn &psi_system;\n}"
  },
  {
    "function_name": "psi_group_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "692-760",
    "snippet": "static void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&group->avgs_work",
            "PSI_FREQ"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayed_work_pending",
          "args": [
            "&group->avgs_work"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_schedule_poll_work",
          "args": [
            "group",
            "1"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "psi_schedule_poll_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "571-595",
          "snippet": "static void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&groupc->seq"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_curr",
          "args": [
            "cpu"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_state",
          "args": [
            "groupc->tasks",
            "s"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "test_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "233-255",
          "snippet": "static bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn unlikely(tasks[NR_IOWAIT]);\n\tcase PSI_IO_FULL:\n\t\treturn unlikely(tasks[NR_IOWAIT] && !tasks[NR_RUNNING]);\n\tcase PSI_MEM_SOME:\n\t\treturn unlikely(tasks[NR_MEMSTALL]);\n\tcase PSI_MEM_FULL:\n\t\treturn unlikely(tasks[NR_MEMSTALL] &&\n\t\t\ttasks[NR_RUNNING] == tasks[NR_MEMSTALL_RUNNING]);\n\tcase PSI_CPU_SOME:\n\t\treturn unlikely(tasks[NR_RUNNING] > tasks[NR_ONCPU]);\n\tcase PSI_CPU_FULL:\n\t\treturn unlikely(tasks[NR_RUNNING] && !tasks[NR_ONCPU]);\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn unlikely(tasks[NR_IOWAIT]);\n\tcase PSI_IO_FULL:\n\t\treturn unlikely(tasks[NR_IOWAIT] && !tasks[NR_RUNNING]);\n\tcase PSI_MEM_SOME:\n\t\treturn unlikely(tasks[NR_MEMSTALL]);\n\tcase PSI_MEM_FULL:\n\t\treturn unlikely(tasks[NR_MEMSTALL] &&\n\t\t\ttasks[NR_RUNNING] == tasks[NR_MEMSTALL_RUNNING]);\n\tcase PSI_CPU_SOME:\n\t\treturn unlikely(tasks[NR_RUNNING] > tasks[NR_ONCPU]);\n\tcase PSI_CPU_FULL:\n\t\treturn unlikely(tasks[NR_RUNNING] && !tasks[NR_ONCPU]);\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\"",
            "cpu",
            "t",
            "groupc->tasks[0]",
            "groupc->tasks[1]",
            "groupc->tasks[2]",
            "groupc->tasks[3]",
            "groupc->tasks[4]",
            "clear",
            "set"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_times",
          "args": [
            "groupc",
            "now"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "record_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "663-690",
          "snippet": "static void record_times(struct psi_group_cpu *groupc, u64 now)\n{\n\tu32 delta;\n\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (groupc->state_mask & (1 << PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_CPU_SOME)) {\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_CPU_FULL))\n\t\t\tgroupc->times[PSI_CPU_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void record_times(struct psi_group_cpu *groupc, u64 now)\n{\n\tu32 delta;\n\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (groupc->state_mask & (1 << PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_CPU_SOME)) {\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_CPU_FULL))\n\t\t\tgroupc->times[PSI_CPU_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&groupc->seq"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_group_change(struct psi_group *group, int cpu,\n\t\t\t     unsigned int clear, unsigned int set, u64 now,\n\t\t\t     bool wake_clock)\n{\n\tstruct psi_group_cpu *groupc;\n\tu32 state_mask = 0;\n\tunsigned int t, m;\n\tenum psi_states s;\n\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\n\t/*\n\t * First we assess the aggregate resource states this CPU's\n\t * tasks have been in since the last change, and account any\n\t * SOME and FULL time these may have resulted in.\n\t *\n\t * Then we update the task counts according to the state\n\t * change requested through the @clear and @set bits.\n\t */\n\twrite_seqcount_begin(&groupc->seq);\n\n\trecord_times(groupc, now);\n\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t]) {\n\t\t\tgroupc->tasks[t]--;\n\t\t} else if (!psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tgroupc->tasks[3], groupc->tasks[4],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t}\n\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\n\t/* Calculate state mask representing active states */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\n\t/*\n\t * Since we care about lost potential, a memstall is FULL\n\t * when there are no other working tasks, but also when\n\t * the CPU is actively reclaiming and nothing productive\n\t * could run even if it were runnable. So when the current\n\t * task in a cgroup is in_memstall, the corresponding groupc\n\t * on that cpu is in PSI_MEM_FULL state.\n\t */\n\tif (unlikely(groupc->tasks[NR_ONCPU] && cpu_curr(cpu)->in_memstall))\n\t\tstate_mask |= (1 << PSI_MEM_FULL);\n\n\tgroupc->state_mask = state_mask;\n\n\twrite_seqcount_end(&groupc->seq);\n\n\tif (state_mask & group->poll_states)\n\t\tpsi_schedule_poll_work(group, 1);\n\n\tif (wake_clock && !delayed_work_pending(&group->avgs_work))\n\t\tschedule_delayed_work(&group->avgs_work, PSI_FREQ);\n}"
  },
  {
    "function_name": "record_times",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "663-690",
    "snippet": "static void record_times(struct psi_group_cpu *groupc, u64 now)\n{\n\tu32 delta;\n\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (groupc->state_mask & (1 << PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_CPU_SOME)) {\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_CPU_FULL))\n\t\t\tgroupc->times[PSI_CPU_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void record_times(struct psi_group_cpu *groupc, u64 now)\n{\n\tu32 delta;\n\n\tdelta = now - groupc->state_start;\n\tgroupc->state_start = now;\n\n\tif (groupc->state_mask & (1 << PSI_IO_SOME)) {\n\t\tgroupc->times[PSI_IO_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_IO_FULL))\n\t\t\tgroupc->times[PSI_IO_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_MEM_SOME)) {\n\t\tgroupc->times[PSI_MEM_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_MEM_FULL))\n\t\t\tgroupc->times[PSI_MEM_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_CPU_SOME)) {\n\t\tgroupc->times[PSI_CPU_SOME] += delta;\n\t\tif (groupc->state_mask & (1 << PSI_CPU_FULL))\n\t\t\tgroupc->times[PSI_CPU_FULL] += delta;\n\t}\n\n\tif (groupc->state_mask & (1 << PSI_NONIDLE))\n\t\tgroupc->times[PSI_NONIDLE] += delta;\n}"
  },
  {
    "function_name": "poll_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "655-661",
    "snippet": "static void poll_timer_fn(struct timer_list *t)\n{\n\tstruct psi_group *group = from_timer(group, t, poll_timer);\n\n\tatomic_set(&group->poll_wakeup, 1);\n\twake_up_interruptible(&group->poll_wait);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&group->poll_wait"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&group->poll_wakeup",
            "1"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "group",
            "t",
            "poll_timer"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void poll_timer_fn(struct timer_list *t)\n{\n\tstruct psi_group *group = from_timer(group, t, poll_timer);\n\n\tatomic_set(&group->poll_wakeup, 1);\n\twake_up_interruptible(&group->poll_wait);\n}"
  },
  {
    "function_name": "psi_poll_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "637-653",
    "snippet": "static int psi_poll_worker(void *data)\n{\n\tstruct psi_group *group = (struct psi_group *)data;\n\n\tsched_set_fifo_low(current);\n\n\twhile (true) {\n\t\twait_event_interruptible(group->poll_wait,\n\t\t\t\tatomic_cmpxchg(&group->poll_wakeup, 1, 0) ||\n\t\t\t\tkthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tpsi_poll_work(group);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_poll_work",
          "args": [
            "group"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "psi_poll_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "637-653",
          "snippet": "static int psi_poll_worker(void *data)\n{\n\tstruct psi_group *group = (struct psi_group *)data;\n\n\tsched_set_fifo_low(current);\n\n\twhile (true) {\n\t\twait_event_interruptible(group->poll_wait,\n\t\t\t\tatomic_cmpxchg(&group->poll_wakeup, 1, 0) ||\n\t\t\t\tkthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tpsi_poll_work(group);\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "is_kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "425-428",
          "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "group->poll_wait",
            "atomic_cmpxchg(&group->poll_wakeup, 1, 0) ||\n\t\t\t\tkthread_should_stop()"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&group->poll_wakeup",
            "1",
            "0"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_set_fifo_low",
          "args": [
            "current"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int psi_poll_worker(void *data)\n{\n\tstruct psi_group *group = (struct psi_group *)data;\n\n\tsched_set_fifo_low(current);\n\n\twhile (true) {\n\t\twait_event_interruptible(group->poll_wait,\n\t\t\t\tatomic_cmpxchg(&group->poll_wakeup, 1, 0) ||\n\t\t\t\tkthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tpsi_poll_work(group);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "psi_poll_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "597-635",
    "snippet": "static void psi_poll_work(struct psi_group *group)\n{\n\tu32 changed_states;\n\tu64 now;\n\n\tmutex_lock(&group->trigger_lock);\n\n\tnow = sched_clock();\n\n\tcollect_percpu_times(group, PSI_POLL, &changed_states);\n\n\tif (changed_states & group->poll_states) {\n\t\t/* Initialize trigger windows when entering polling mode */\n\t\tif (now > group->polling_until)\n\t\t\tinit_triggers(group, now);\n\n\t\t/*\n\t\t * Keep the monitor active for at least the duration of the\n\t\t * minimum tracking window as long as monitor states are\n\t\t * changing.\n\t\t */\n\t\tgroup->polling_until = now +\n\t\t\tgroup->poll_min_period * UPDATES_PER_WINDOW;\n\t}\n\n\tif (now > group->polling_until) {\n\t\tgroup->polling_next_update = ULLONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (now >= group->polling_next_update)\n\t\tgroup->polling_next_update = update_triggers(group, now);\n\n\tpsi_schedule_poll_work(group,\n\t\tnsecs_to_jiffies(group->polling_next_update - now) + 1);\n\nout:\n\tmutex_unlock(&group->trigger_lock);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_schedule_poll_work",
          "args": [
            "group",
            "nsecs_to_jiffies(group->polling_next_update - now) + 1"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "psi_schedule_poll_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "571-595",
          "snippet": "static void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsecs_to_jiffies",
          "args": [
            "group->polling_next_update - now"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "754-757",
          "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_triggers",
          "args": [
            "group",
            "now"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "update_triggers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "523-568",
          "snippet": "static u64 update_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\tbool new_stall = false;\n\tu64 *total = group->total[PSI_POLL];\n\n\t/*\n\t * On subsequent updates, calculate growth deltas and let\n\t * watchers know when their specified thresholds are exceeded.\n\t */\n\tlist_for_each_entry(t, &group->triggers, node) {\n\t\tu64 growth;\n\n\t\t/* Check for stall activity */\n\t\tif (group->polling_total[t->state] == total[t->state])\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Multiple triggers might be looking at the same state,\n\t\t * remember to update group->polling_total[] once we've\n\t\t * been through all of them. Also remember to extend the\n\t\t * polling time if we see new stall activity.\n\t\t */\n\t\tnew_stall = true;\n\n\t\t/* Calculate growth since last update */\n\t\tgrowth = window_update(&t->win, now, total[t->state]);\n\t\tif (growth < t->threshold)\n\t\t\tcontinue;\n\n\t\t/* Limit event signaling to once per window */\n\t\tif (now < t->last_event_time + t->win.size)\n\t\t\tcontinue;\n\n\t\t/* Generate an event */\n\t\tif (cmpxchg(&t->event, 0, 1) == 0)\n\t\t\twake_up_interruptible(&t->event_wait);\n\t\tt->last_event_time = now;\n\t}\n\n\tif (new_stall)\n\t\tmemcpy(group->polling_total, total,\n\t\t\t\tsizeof(group->polling_total));\n\n\treturn now + group->poll_min_period;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic u64 update_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\tbool new_stall = false;\n\tu64 *total = group->total[PSI_POLL];\n\n\t/*\n\t * On subsequent updates, calculate growth deltas and let\n\t * watchers know when their specified thresholds are exceeded.\n\t */\n\tlist_for_each_entry(t, &group->triggers, node) {\n\t\tu64 growth;\n\n\t\t/* Check for stall activity */\n\t\tif (group->polling_total[t->state] == total[t->state])\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Multiple triggers might be looking at the same state,\n\t\t * remember to update group->polling_total[] once we've\n\t\t * been through all of them. Also remember to extend the\n\t\t * polling time if we see new stall activity.\n\t\t */\n\t\tnew_stall = true;\n\n\t\t/* Calculate growth since last update */\n\t\tgrowth = window_update(&t->win, now, total[t->state]);\n\t\tif (growth < t->threshold)\n\t\t\tcontinue;\n\n\t\t/* Limit event signaling to once per window */\n\t\tif (now < t->last_event_time + t->win.size)\n\t\t\tcontinue;\n\n\t\t/* Generate an event */\n\t\tif (cmpxchg(&t->event, 0, 1) == 0)\n\t\t\twake_up_interruptible(&t->event_wait);\n\t\tt->last_event_time = now;\n\t}\n\n\tif (new_stall)\n\t\tmemcpy(group->polling_total, total,\n\t\t\t\tsizeof(group->polling_total));\n\n\treturn now + group->poll_min_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_triggers",
          "args": [
            "group",
            "now"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "init_triggers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "511-521",
          "snippet": "static void init_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\n\tlist_for_each_entry(t, &group->triggers, node)\n\t\twindow_reset(&t->win, now,\n\t\t\t\tgroup->total[PSI_POLL][t->state], 0);\n\tmemcpy(group->polling_total, group->total[PSI_POLL],\n\t\t   sizeof(group->polling_total));\n\tgroup->polling_next_update = now + group->poll_min_period;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void init_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\n\tlist_for_each_entry(t, &group->triggers, node)\n\t\twindow_reset(&t->win, now,\n\t\t\t\tgroup->total[PSI_POLL][t->state], 0);\n\tmemcpy(group->polling_total, group->total[PSI_POLL],\n\t\t   sizeof(group->polling_total));\n\tgroup->polling_next_update = now + group->poll_min_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_percpu_times",
          "args": [
            "group",
            "PSI_POLL",
            "&changed_states"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "collect_percpu_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "322-375",
          "snippet": "static void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define UPDATES_PER_WINDOW 10\t/* 10 updates per window */\n\nstatic void psi_poll_work(struct psi_group *group)\n{\n\tu32 changed_states;\n\tu64 now;\n\n\tmutex_lock(&group->trigger_lock);\n\n\tnow = sched_clock();\n\n\tcollect_percpu_times(group, PSI_POLL, &changed_states);\n\n\tif (changed_states & group->poll_states) {\n\t\t/* Initialize trigger windows when entering polling mode */\n\t\tif (now > group->polling_until)\n\t\t\tinit_triggers(group, now);\n\n\t\t/*\n\t\t * Keep the monitor active for at least the duration of the\n\t\t * minimum tracking window as long as monitor states are\n\t\t * changing.\n\t\t */\n\t\tgroup->polling_until = now +\n\t\t\tgroup->poll_min_period * UPDATES_PER_WINDOW;\n\t}\n\n\tif (now > group->polling_until) {\n\t\tgroup->polling_next_update = ULLONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (now >= group->polling_next_update)\n\t\tgroup->polling_next_update = update_triggers(group, now);\n\n\tpsi_schedule_poll_work(group,\n\t\tnsecs_to_jiffies(group->polling_next_update - now) + 1);\n\nout:\n\tmutex_unlock(&group->trigger_lock);\n}"
  },
  {
    "function_name": "psi_schedule_poll_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "571-595",
    "snippet": "static void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&group->poll_timer",
            "jiffies + delay"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "task"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "group->poll_task"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&group->poll_timer"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void psi_schedule_poll_work(struct psi_group *group, unsigned long delay)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Do not reschedule if already scheduled.\n\t * Possible race with a timer scheduled after this check but before\n\t * mod_timer below can be tolerated because group->polling_next_update\n\t * will keep updates on schedule.\n\t */\n\tif (timer_pending(&group->poll_timer))\n\t\treturn;\n\n\trcu_read_lock();\n\n\ttask = rcu_dereference(group->poll_task);\n\t/*\n\t * kworker might be NULL in case psi_trigger_destroy races with\n\t * psi_task_change (hotpath) which can't use locks\n\t */\n\tif (likely(task))\n\t\tmod_timer(&group->poll_timer, jiffies + delay);\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_triggers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "523-568",
    "snippet": "static u64 update_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\tbool new_stall = false;\n\tu64 *total = group->total[PSI_POLL];\n\n\t/*\n\t * On subsequent updates, calculate growth deltas and let\n\t * watchers know when their specified thresholds are exceeded.\n\t */\n\tlist_for_each_entry(t, &group->triggers, node) {\n\t\tu64 growth;\n\n\t\t/* Check for stall activity */\n\t\tif (group->polling_total[t->state] == total[t->state])\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Multiple triggers might be looking at the same state,\n\t\t * remember to update group->polling_total[] once we've\n\t\t * been through all of them. Also remember to extend the\n\t\t * polling time if we see new stall activity.\n\t\t */\n\t\tnew_stall = true;\n\n\t\t/* Calculate growth since last update */\n\t\tgrowth = window_update(&t->win, now, total[t->state]);\n\t\tif (growth < t->threshold)\n\t\t\tcontinue;\n\n\t\t/* Limit event signaling to once per window */\n\t\tif (now < t->last_event_time + t->win.size)\n\t\t\tcontinue;\n\n\t\t/* Generate an event */\n\t\tif (cmpxchg(&t->event, 0, 1) == 0)\n\t\t\twake_up_interruptible(&t->event_wait);\n\t\tt->last_event_time = now;\n\t}\n\n\tif (new_stall)\n\t\tmemcpy(group->polling_total, total,\n\t\t\t\tsizeof(group->polling_total));\n\n\treturn now + group->poll_min_period;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "group->polling_total",
            "total",
            "sizeof(group->polling_total)"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&t->event_wait"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&t->event",
            "0",
            "1"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "window_update",
          "args": [
            "&t->win",
            "now",
            "total[t->state]"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "window_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "485-509",
          "snippet": "static u64 window_update(struct psi_window *win, u64 now, u64 value)\n{\n\tu64 elapsed;\n\tu64 growth;\n\n\telapsed = now - win->start_time;\n\tgrowth = value - win->start_value;\n\t/*\n\t * After each tracking window passes win->start_value and\n\t * win->start_time get reset and win->prev_growth stores\n\t * the average per-window growth of the previous window.\n\t * win->prev_growth is then used to interpolate additional\n\t * growth from the previous window assuming it was linear.\n\t */\n\tif (elapsed > win->size)\n\t\twindow_reset(win, now, value, growth);\n\telse {\n\t\tu32 remaining;\n\n\t\tremaining = win->size - elapsed;\n\t\tgrowth += div64_u64(win->prev_growth * remaining, win->size);\n\t}\n\n\treturn growth;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 window_update(struct psi_window *win, u64 now, u64 value)\n{\n\tu64 elapsed;\n\tu64 growth;\n\n\telapsed = now - win->start_time;\n\tgrowth = value - win->start_value;\n\t/*\n\t * After each tracking window passes win->start_value and\n\t * win->start_time get reset and win->prev_growth stores\n\t * the average per-window growth of the previous window.\n\t * win->prev_growth is then used to interpolate additional\n\t * growth from the previous window assuming it was linear.\n\t */\n\tif (elapsed > win->size)\n\t\twindow_reset(win, now, value, growth);\n\telse {\n\t\tu32 remaining;\n\n\t\tremaining = win->size - elapsed;\n\t\tgrowth += div64_u64(win->prev_growth * remaining, win->size);\n\t}\n\n\treturn growth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "t",
            "&group->triggers",
            "node"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic u64 update_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\tbool new_stall = false;\n\tu64 *total = group->total[PSI_POLL];\n\n\t/*\n\t * On subsequent updates, calculate growth deltas and let\n\t * watchers know when their specified thresholds are exceeded.\n\t */\n\tlist_for_each_entry(t, &group->triggers, node) {\n\t\tu64 growth;\n\n\t\t/* Check for stall activity */\n\t\tif (group->polling_total[t->state] == total[t->state])\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Multiple triggers might be looking at the same state,\n\t\t * remember to update group->polling_total[] once we've\n\t\t * been through all of them. Also remember to extend the\n\t\t * polling time if we see new stall activity.\n\t\t */\n\t\tnew_stall = true;\n\n\t\t/* Calculate growth since last update */\n\t\tgrowth = window_update(&t->win, now, total[t->state]);\n\t\tif (growth < t->threshold)\n\t\t\tcontinue;\n\n\t\t/* Limit event signaling to once per window */\n\t\tif (now < t->last_event_time + t->win.size)\n\t\t\tcontinue;\n\n\t\t/* Generate an event */\n\t\tif (cmpxchg(&t->event, 0, 1) == 0)\n\t\t\twake_up_interruptible(&t->event_wait);\n\t\tt->last_event_time = now;\n\t}\n\n\tif (new_stall)\n\t\tmemcpy(group->polling_total, total,\n\t\t\t\tsizeof(group->polling_total));\n\n\treturn now + group->poll_min_period;\n}"
  },
  {
    "function_name": "init_triggers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "511-521",
    "snippet": "static void init_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\n\tlist_for_each_entry(t, &group->triggers, node)\n\t\twindow_reset(&t->win, now,\n\t\t\t\tgroup->total[PSI_POLL][t->state], 0);\n\tmemcpy(group->polling_total, group->total[PSI_POLL],\n\t\t   sizeof(group->polling_total));\n\tgroup->polling_next_update = now + group->poll_min_period;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "group->polling_total",
            "group->total[PSI_POLL]",
            "sizeof(group->polling_total)"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "window_reset",
          "args": [
            "&t->win",
            "now",
            "group->total[PSI_POLL][t->state]",
            "0"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "window_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "466-472",
          "snippet": "static void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "t",
            "&group->triggers",
            "node"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic void init_triggers(struct psi_group *group, u64 now)\n{\n\tstruct psi_trigger *t;\n\n\tlist_for_each_entry(t, &group->triggers, node)\n\t\twindow_reset(&t->win, now,\n\t\t\t\tgroup->total[PSI_POLL][t->state], 0);\n\tmemcpy(group->polling_total, group->total[PSI_POLL],\n\t\t   sizeof(group->polling_total));\n\tgroup->polling_next_update = now + group->poll_min_period;\n}"
  },
  {
    "function_name": "window_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "485-509",
    "snippet": "static u64 window_update(struct psi_window *win, u64 now, u64 value)\n{\n\tu64 elapsed;\n\tu64 growth;\n\n\telapsed = now - win->start_time;\n\tgrowth = value - win->start_value;\n\t/*\n\t * After each tracking window passes win->start_value and\n\t * win->start_time get reset and win->prev_growth stores\n\t * the average per-window growth of the previous window.\n\t * win->prev_growth is then used to interpolate additional\n\t * growth from the previous window assuming it was linear.\n\t */\n\tif (elapsed > win->size)\n\t\twindow_reset(win, now, value, growth);\n\telse {\n\t\tu32 remaining;\n\n\t\tremaining = win->size - elapsed;\n\t\tgrowth += div64_u64(win->prev_growth * remaining, win->size);\n\t}\n\n\treturn growth;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "win->prev_growth * remaining",
            "win->size"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "window_reset",
          "args": [
            "win",
            "now",
            "value",
            "growth"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "window_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "466-472",
          "snippet": "static void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 window_update(struct psi_window *win, u64 now, u64 value)\n{\n\tu64 elapsed;\n\tu64 growth;\n\n\telapsed = now - win->start_time;\n\tgrowth = value - win->start_value;\n\t/*\n\t * After each tracking window passes win->start_value and\n\t * win->start_time get reset and win->prev_growth stores\n\t * the average per-window growth of the previous window.\n\t * win->prev_growth is then used to interpolate additional\n\t * growth from the previous window assuming it was linear.\n\t */\n\tif (elapsed > win->size)\n\t\twindow_reset(win, now, value, growth);\n\telse {\n\t\tu32 remaining;\n\n\t\tremaining = win->size - elapsed;\n\t\tgrowth += div64_u64(win->prev_growth * remaining, win->size);\n\t}\n\n\treturn growth;\n}"
  },
  {
    "function_name": "window_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "466-472",
    "snippet": "static void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void window_reset(struct psi_window *win, u64 now, u64 value,\n\t\t\t u64 prev_growth)\n{\n\twin->start_time = now;\n\twin->start_value = value;\n\twin->prev_growth = prev_growth;\n}"
  },
  {
    "function_name": "psi_avgs_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "430-463",
    "snippet": "static void psi_avgs_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct psi_group *group;\n\tu32 changed_states;\n\tbool nonidle;\n\tu64 now;\n\n\tdwork = to_delayed_work(work);\n\tgroup = container_of(dwork, struct psi_group, avgs_work);\n\n\tmutex_lock(&group->avgs_lock);\n\n\tnow = sched_clock();\n\n\tcollect_percpu_times(group, PSI_AVGS, &changed_states);\n\tnonidle = changed_states & (1 << PSI_NONIDLE);\n\t/*\n\t * If there is task activity, periodically fold the per-cpu\n\t * times and feed samples into the running averages. If things\n\t * are idle and there is no data to process, stop the clock.\n\t * Once restarted, we'll catch up the running averages in one\n\t * go - see calc_avgs() and missed_periods.\n\t */\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\n\tif (nonidle) {\n\t\tschedule_delayed_work(dwork, nsecs_to_jiffies(\n\t\t\t\tgroup->avg_next_update - now) + 1);\n\t}\n\n\tmutex_unlock(&group->avgs_lock);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void psi_avgs_work(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->avgs_lock"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "dwork",
            "nsecs_to_jiffies(\n\t\t\t\tgroup->avg_next_update - now) + 1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsecs_to_jiffies",
          "args": [
            "group->avg_next_update - now"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "754-757",
          "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_averages",
          "args": [
            "group",
            "now"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "update_averages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "377-428",
          "snippet": "static u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period",
            "static void poll_timer_fn(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_percpu_times",
          "args": [
            "group",
            "PSI_AVGS",
            "&changed_states"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "collect_percpu_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "322-375",
          "snippet": "static void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->avgs_lock"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structpsi_group",
            "avgs_work"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void psi_avgs_work(struct work_struct *work);\n\nstatic void psi_avgs_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct psi_group *group;\n\tu32 changed_states;\n\tbool nonidle;\n\tu64 now;\n\n\tdwork = to_delayed_work(work);\n\tgroup = container_of(dwork, struct psi_group, avgs_work);\n\n\tmutex_lock(&group->avgs_lock);\n\n\tnow = sched_clock();\n\n\tcollect_percpu_times(group, PSI_AVGS, &changed_states);\n\tnonidle = changed_states & (1 << PSI_NONIDLE);\n\t/*\n\t * If there is task activity, periodically fold the per-cpu\n\t * times and feed samples into the running averages. If things\n\t * are idle and there is no data to process, stop the clock.\n\t * Once restarted, we'll catch up the running averages in one\n\t * go - see calc_avgs() and missed_periods.\n\t */\n\tif (now >= group->avg_next_update)\n\t\tgroup->avg_next_update = update_averages(group, now);\n\n\tif (nonidle) {\n\t\tschedule_delayed_work(dwork, nsecs_to_jiffies(\n\t\t\t\tgroup->avg_next_update - now) + 1);\n\t}\n\n\tmutex_unlock(&group->avgs_lock);\n}"
  },
  {
    "function_name": "update_averages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "377-428",
    "snippet": "static u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 psi_period",
      "static void poll_timer_fn(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_avgs",
          "args": [
            "group->avg[s]",
            "missed_periods",
            "sample",
            "period"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "calc_avgs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "302-320",
          "snippet": "static void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [
            "#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */",
            "#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */",
            "#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */\n#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */\n#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */\n\nstatic void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "now - expires",
            "psi_period"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\nstatic void poll_timer_fn(struct timer_list *t);\n\nstatic u64 update_averages(struct psi_group *group, u64 now)\n{\n\tunsigned long missed_periods = 0;\n\tu64 expires, period;\n\tu64 avg_next_update;\n\tint s;\n\n\t/* avgX= */\n\texpires = group->avg_next_update;\n\tif (now - expires >= psi_period)\n\t\tmissed_periods = div_u64(now - expires, psi_period);\n\n\t/*\n\t * The periodic clock tick can get delayed for various\n\t * reasons, especially on loaded systems. To avoid clock\n\t * drift, we schedule the clock in fixed psi_period intervals.\n\t * But the deltas we sample out of the per-cpu buckets above\n\t * are based on the actual time elapsing between clock ticks.\n\t */\n\tavg_next_update = expires + ((1 + missed_periods) * psi_period);\n\tperiod = now - (group->avg_last_update + (missed_periods * psi_period));\n\tgroup->avg_last_update = now;\n\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++) {\n\t\tu32 sample;\n\n\t\tsample = group->total[PSI_AVGS][s] - group->avg_total[s];\n\t\t/*\n\t\t * Due to the lockless sampling of the time buckets,\n\t\t * recorded time deltas can slip into the next period,\n\t\t * which under full pressure can result in samples in\n\t\t * excess of the period length.\n\t\t *\n\t\t * We don't want to report non-sensical pressures in\n\t\t * excess of 100%, nor do we want to drop such events\n\t\t * on the floor. Instead we punt any overage into the\n\t\t * future until pressure subsides. By doing this we\n\t\t * don't underreport the occurring pressure curve, we\n\t\t * just report it delayed by one period length.\n\t\t *\n\t\t * The error isn't cumulative. As soon as another\n\t\t * delta slips from a period P to P+1, by definition\n\t\t * it frees up its time T in P.\n\t\t */\n\t\tif (sample > period)\n\t\t\tsample = period;\n\t\tgroup->avg_total[s] += sample;\n\t\tcalc_avgs(group->avg[s], missed_periods, sample, period);\n\t}\n\n\treturn avg_next_update;\n}"
  },
  {
    "function_name": "collect_percpu_times",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "322-375",
    "snippet": "static void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "deltas[s]",
            "max(nonidle_total, 1UL)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nonidle_total",
            "1UL"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "254-257",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsecs_to_jiffies",
          "args": [
            "times[PSI_NONIDLE]"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "nsecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "754-757",
          "snippet": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_recent_times",
          "args": [
            "group",
            "cpu",
            "aggregator",
            "times",
            "&cpu_changed_states"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "get_recent_times",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "257-300",
          "snippet": "static void get_recent_times(struct psi_group *group, int cpu,\n\t\t\t     enum psi_aggregators aggregator, u32 *times,\n\t\t\t     u32 *pchanged_states)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tu64 now, state_start;\n\tenum psi_states s;\n\tunsigned int seq;\n\tu32 state_mask;\n\n\t*pchanged_states = 0;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tstate_mask = groupc->state_mask;\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (state_mask & (1 << s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[aggregator][s];\n\t\tgroupc->times_prev[aggregator][s] = times[s];\n\n\t\ttimes[s] = delta;\n\t\tif (delta)\n\t\t\t*pchanged_states |= (1 << s);\n\t}\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void get_recent_times(struct psi_group *group, int cpu,\n\t\t\t     enum psi_aggregators aggregator, u32 *times,\n\t\t\t     u32 *pchanged_states)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tu64 now, state_start;\n\tenum psi_states s;\n\tunsigned int seq;\n\tu32 state_mask;\n\n\t*pchanged_states = 0;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tstate_mask = groupc->state_mask;\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (state_mask & (1 << s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[aggregator][s];\n\t\tgroupc->times_prev[aggregator][s] = times[s];\n\n\t\ttimes[s] = delta;\n\t\tif (delta)\n\t\t\t*pchanged_states |= (1 << s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic void collect_percpu_times(struct psi_group *group,\n\t\t\t\t enum psi_aggregators aggregator,\n\t\t\t\t u32 *pchanged_states)\n{\n\tu64 deltas[NR_PSI_STATES - 1] = { 0, };\n\tunsigned long nonidle_total = 0;\n\tu32 changed_states = 0;\n\tint cpu;\n\tint s;\n\n\t/*\n\t * Collect the per-cpu time buckets and average them into a\n\t * single time sample that is normalized to wallclock time.\n\t *\n\t * For averaging, each CPU is weighted by its non-idle time in\n\t * the sampling period. This eliminates artifacts from uneven\n\t * loading, or even entirely idle CPUs.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tu32 times[NR_PSI_STATES];\n\t\tu32 nonidle;\n\t\tu32 cpu_changed_states;\n\n\t\tget_recent_times(group, cpu, aggregator, times,\n\t\t\t\t&cpu_changed_states);\n\t\tchanged_states |= cpu_changed_states;\n\n\t\tnonidle = nsecs_to_jiffies(times[PSI_NONIDLE]);\n\t\tnonidle_total += nonidle;\n\n\t\tfor (s = 0; s < PSI_NONIDLE; s++)\n\t\t\tdeltas[s] += (u64)times[s] * nonidle;\n\t}\n\n\t/*\n\t * Integrate the sample into the running statistics that are\n\t * reported to userspace: the cumulative stall times and the\n\t * decaying averages.\n\t *\n\t * Pressure percentages are sampled at PSI_FREQ. We might be\n\t * called more often when the user polls more frequently than\n\t * that; we might be called less often when there is no task\n\t * activity, thus no data, and clock ticks are sporadic. The\n\t * below handles both.\n\t */\n\n\t/* total= */\n\tfor (s = 0; s < NR_PSI_STATES - 1; s++)\n\t\tgroup->total[aggregator][s] +=\n\t\t\t\tdiv_u64(deltas[s], max(nonidle_total, 1UL));\n\n\tif (pchanged_states)\n\t\t*pchanged_states = changed_states;\n}"
  },
  {
    "function_name": "calc_avgs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "302-320",
    "snippet": "static void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */",
      "#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */",
      "#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[2]",
            "EXP_300s",
            "pct"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[1]",
            "EXP_60s",
            "pct"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load",
          "args": [
            "avg[0]",
            "EXP_10s",
            "pct"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "time * 100",
            "period"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_n",
          "args": [
            "avg[2]",
            "EXP_300s",
            "0",
            "missed_periods"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_n",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "156-161",
          "snippet": "unsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define EXP_300s\t2034\t\t/* 1/exp(2s/300s) */\n#define EXP_60s\t\t1981\t\t/* 1/exp(2s/60s) */\n#define EXP_10s\t\t1677\t\t/* 1/exp(2s/10s) as fixed-point */\n\nstatic void calc_avgs(unsigned long avg[3], int missed_periods,\n\t\t      u64 time, u64 period)\n{\n\tunsigned long pct;\n\n\t/* Fill in zeroes for periods of no activity */\n\tif (missed_periods) {\n\t\tavg[0] = calc_load_n(avg[0], EXP_10s, 0, missed_periods);\n\t\tavg[1] = calc_load_n(avg[1], EXP_60s, 0, missed_periods);\n\t\tavg[2] = calc_load_n(avg[2], EXP_300s, 0, missed_periods);\n\t}\n\n\t/* Sample the most recent active period */\n\tpct = div_u64(time * 100, period);\n\tpct *= FIXED_1;\n\tavg[0] = calc_load(avg[0], EXP_10s, pct);\n\tavg[1] = calc_load(avg[1], EXP_60s, pct);\n\tavg[2] = calc_load(avg[2], EXP_300s, pct);\n}"
  },
  {
    "function_name": "get_recent_times",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "257-300",
    "snippet": "static void get_recent_times(struct psi_group *group, int cpu,\n\t\t\t     enum psi_aggregators aggregator, u32 *times,\n\t\t\t     u32 *pchanged_states)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tu64 now, state_start;\n\tenum psi_states s;\n\tunsigned int seq;\n\tu32 state_mask;\n\n\t*pchanged_states = 0;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tstate_mask = groupc->state_mask;\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (state_mask & (1 << s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[aggregator][s];\n\t\tgroupc->times_prev[aggregator][s] = times[s];\n\n\t\ttimes[s] = delta;\n\t\tif (delta)\n\t\t\t*pchanged_states |= (1 << s);\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&groupc->seq",
            "seq"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "times",
            "groupc->times",
            "sizeof(groupc->times)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock",
          "args": [
            "cpu"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "10734-10751",
          "snippet": "static int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&groupc->seq"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic void get_recent_times(struct psi_group *group, int cpu,\n\t\t\t     enum psi_aggregators aggregator, u32 *times,\n\t\t\t     u32 *pchanged_states)\n{\n\tstruct psi_group_cpu *groupc = per_cpu_ptr(group->pcpu, cpu);\n\tu64 now, state_start;\n\tenum psi_states s;\n\tunsigned int seq;\n\tu32 state_mask;\n\n\t*pchanged_states = 0;\n\n\t/* Snapshot a coherent view of the CPU state */\n\tdo {\n\t\tseq = read_seqcount_begin(&groupc->seq);\n\t\tnow = cpu_clock(cpu);\n\t\tmemcpy(times, groupc->times, sizeof(groupc->times));\n\t\tstate_mask = groupc->state_mask;\n\t\tstate_start = groupc->state_start;\n\t} while (read_seqcount_retry(&groupc->seq, seq));\n\n\t/* Calculate state time deltas against the previous snapshot */\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tu32 delta;\n\t\t/*\n\t\t * In addition to already concluded states, we also\n\t\t * incorporate currently active states on the CPU,\n\t\t * since states may last for many sampling periods.\n\t\t *\n\t\t * This way we keep our delta sampling buckets small\n\t\t * (u32) and our reported pressure close to what's\n\t\t * actually happening.\n\t\t */\n\t\tif (state_mask & (1 << s))\n\t\t\ttimes[s] += now - state_start;\n\n\t\tdelta = times[s] - groupc->times_prev[aggregator][s];\n\t\tgroupc->times_prev[aggregator][s] = times[s];\n\n\t\ttimes[s] = delta;\n\t\tif (delta)\n\t\t\t*pchanged_states |= (1 << s);\n\t}\n}"
  },
  {
    "function_name": "test_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "233-255",
    "snippet": "static bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn unlikely(tasks[NR_IOWAIT]);\n\tcase PSI_IO_FULL:\n\t\treturn unlikely(tasks[NR_IOWAIT] && !tasks[NR_RUNNING]);\n\tcase PSI_MEM_SOME:\n\t\treturn unlikely(tasks[NR_MEMSTALL]);\n\tcase PSI_MEM_FULL:\n\t\treturn unlikely(tasks[NR_MEMSTALL] &&\n\t\t\ttasks[NR_RUNNING] == tasks[NR_MEMSTALL_RUNNING]);\n\tcase PSI_CPU_SOME:\n\t\treturn unlikely(tasks[NR_RUNNING] > tasks[NR_ONCPU]);\n\tcase PSI_CPU_FULL:\n\t\treturn unlikely(tasks[NR_RUNNING] && !tasks[NR_ONCPU]);\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_RUNNING] && !tasks[NR_ONCPU]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_RUNNING] > tasks[NR_ONCPU]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_MEMSTALL] &&\n\t\t\ttasks[NR_RUNNING] == tasks[NR_MEMSTALL_RUNNING]"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_MEMSTALL]"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_IOWAIT] && !tasks[NR_RUNNING]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tasks[NR_IOWAIT]"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic bool test_state(unsigned int *tasks, enum psi_states state)\n{\n\tswitch (state) {\n\tcase PSI_IO_SOME:\n\t\treturn unlikely(tasks[NR_IOWAIT]);\n\tcase PSI_IO_FULL:\n\t\treturn unlikely(tasks[NR_IOWAIT] && !tasks[NR_RUNNING]);\n\tcase PSI_MEM_SOME:\n\t\treturn unlikely(tasks[NR_MEMSTALL]);\n\tcase PSI_MEM_FULL:\n\t\treturn unlikely(tasks[NR_MEMSTALL] &&\n\t\t\ttasks[NR_RUNNING] == tasks[NR_MEMSTALL_RUNNING]);\n\tcase PSI_CPU_SOME:\n\t\treturn unlikely(tasks[NR_RUNNING] > tasks[NR_ONCPU]);\n\tcase PSI_CPU_FULL:\n\t\treturn unlikely(tasks[NR_RUNNING] && !tasks[NR_ONCPU]);\n\tcase PSI_NONIDLE:\n\t\treturn tasks[NR_IOWAIT] || tasks[NR_MEMSTALL] ||\n\t\t\ttasks[NR_RUNNING];\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "psi_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "219-231",
    "snippet": "void __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\n\tif (!cgroup_psi_enabled())\n\t\tstatic_branch_disable(&psi_cgroups_enabled);\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [
      "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
    ],
    "globals_used": [
      "static u64 psi_period",
      "struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "group_init",
          "args": [
            "&psi_system"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "group_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
          "lines": "195-217",
          "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>",
            "#include \"../workqueue_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 psi_period"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_nsecs",
          "args": [
            "PSI_FREQ"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&psi_cgroups_enabled"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&psi_disabled"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nstatic u64 psi_period;\nstruct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nvoid __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\n\tif (!cgroup_psi_enabled())\n\t\tstatic_branch_disable(&psi_cgroups_enabled);\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}"
  },
  {
    "function_name": "group_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "195-217",
    "snippet": "static void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 psi_period"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "group->poll_task",
            "NULL"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&group->poll_timer",
            "poll_timer_fn",
            "0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&group->poll_wait"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "group->polling_total",
            "0",
            "sizeof(group->polling_total)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "group->nr_triggers",
            "0",
            "sizeof(group->nr_triggers)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&group->triggers"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&group->trigger_lock"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&group->avgs_work",
            "psi_avgs_work"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "group->pcpu",
            "cpu"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic u64 psi_period;\n\nstatic void group_init(struct psi_group *group)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tseqcount_init(&per_cpu_ptr(group->pcpu, cpu)->seq);\n\tgroup->avg_last_update = sched_clock();\n\tgroup->avg_next_update = group->avg_last_update + psi_period;\n\tINIT_DELAYED_WORK(&group->avgs_work, psi_avgs_work);\n\tmutex_init(&group->avgs_lock);\n\t/* Init trigger-related members */\n\tmutex_init(&group->trigger_lock);\n\tINIT_LIST_HEAD(&group->triggers);\n\tmemset(group->nr_triggers, 0, sizeof(group->nr_triggers));\n\tgroup->poll_states = 0;\n\tgroup->poll_min_period = U32_MAX;\n\tmemset(group->polling_total, 0, sizeof(group->polling_total));\n\tgroup->polling_next_update = ULLONG_MAX;\n\tgroup->polling_until = 0;\n\tinit_waitqueue_head(&group->poll_wait);\n\ttimer_setup(&group->poll_timer, poll_timer_fn, 0);\n\trcu_assign_pointer(group->poll_task, NULL);\n}"
  },
  {
    "function_name": "setup_psi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/psi.c",
    "lines": "165-168",
    "snippet": "static int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/psi.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/loadavg.h>",
      "#include \"../workqueue_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&psi_enable"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/uaccess.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n#include \"../workqueue_internal.h\"\n\nstatic int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}"
  }
]