[
  {
    "function_name": "dma_direct_set_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "608-631",
    "snippet": "int dma_direct_set_offset(struct device *dev, phys_addr_t cpu_start,\n\t\t\t dma_addr_t dma_start, u64 size)\n{\n\tstruct bus_dma_region *map;\n\tu64 offset = (u64)cpu_start - (u64)dma_start;\n\n\tif (dev->dma_range_map) {\n\t\tdev_err(dev, \"attempt to add DMA range to existing map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!offset)\n\t\treturn 0;\n\n\tmap = kcalloc(2, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap[0].cpu_start = cpu_start;\n\tmap[0].dma_start = dma_start;\n\tmap[0].offset = offset;\n\tmap[0].size = size;\n\tdev->dma_range_map = map;\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "2",
            "sizeof(*map)",
            "GFP_KERNEL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"attempt to add DMA range to existing map\\n\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_set_offset(struct device *dev, phys_addr_t cpu_start,\n\t\t\t dma_addr_t dma_start, u64 size)\n{\n\tstruct bus_dma_region *map;\n\tu64 offset = (u64)cpu_start - (u64)dma_start;\n\n\tif (dev->dma_range_map) {\n\t\tdev_err(dev, \"attempt to add DMA range to existing map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!offset)\n\t\treturn 0;\n\n\tmap = kcalloc(2, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap[0].cpu_start = cpu_start;\n\tmap[0].dma_start = dma_start;\n\tmap[0].offset = offset;\n\tmap[0].size = size;\n\tdev->dma_range_map = map;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_direct_need_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "586-590",
    "snippet": "bool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dev_is_dma_coherent(dev) ||\n\t       is_swiotlb_buffer(dev, dma_to_phys(dev, dma_addr));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "dma_to_phys(dev, dma_addr)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dev_is_dma_coherent(dev) ||\n\t       is_swiotlb_buffer(dev, dma_to_phys(dev, dma_addr));\n}"
  },
  {
    "function_name": "dma_direct_max_mapping_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "577-584",
    "snippet": "size_t dma_direct_max_mapping_size(struct device *dev)\n{\n\t/* If SWIOTLB is active, use its maximum mapping size */\n\tif (is_swiotlb_active(dev) &&\n\t    (dma_addressing_limited(dev) || is_swiotlb_force_bounce(dev)))\n\t\treturn swiotlb_max_mapping_size(dev);\n\treturn SIZE_MAX;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_max_mapping_size",
          "args": [
            "dev"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_max_mapping_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "748-751",
          "snippet": "size_t swiotlb_max_mapping_size(struct device *dev)\n{\n\treturn ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nsize_t swiotlb_max_mapping_size(struct device *dev)\n{\n\treturn ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_force_bounce",
          "args": [
            "dev"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_addressing_limited",
          "args": [
            "dev"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_active",
          "args": [
            "dev"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "is_swiotlb_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "753-758",
          "snippet": "bool is_swiotlb_active(struct device *dev)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\n\treturn mem && mem->nslabs;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nbool is_swiotlb_active(struct device *dev)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\n\treturn mem && mem->nslabs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nsize_t dma_direct_max_mapping_size(struct device *dev)\n{\n\t/* If SWIOTLB is active, use its maximum mapping size */\n\tif (is_swiotlb_active(dev) &&\n\t    (dma_addressing_limited(dev) || is_swiotlb_force_bounce(dev)))\n\t\treturn swiotlb_max_mapping_size(dev);\n\treturn SIZE_MAX;\n}"
  },
  {
    "function_name": "dma_direct_supported",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "554-575",
    "snippet": "int dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask = (max_pfn - 1) << PAGE_SHIFT;\n\n\t/*\n\t * Because 32-bit DMA masks are so common we expect every architecture\n\t * to be able to satisfy them - either by not supporting more physical\n\t * memory, or by providing a ZONE_DMA32.  If neither is the case, the\n\t * architecture needs to use an IOMMU instead of the direct mapping.\n\t */\n\tif (mask >= DMA_BIT_MASK(32))\n\t\treturn 1;\n\n\t/*\n\t * This check needs to be against the actual bit mask value, so use\n\t * phys_to_dma_unencrypted() here so that the SME encryption mask isn't\n\t * part of the check.\n\t */\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));\n\treturn mask >= phys_to_dma_unencrypted(dev, min_mask);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int zone_dma_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma_unencrypted",
          "args": [
            "dev",
            "min_mask"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "min_mask",
            "DMA_BIT_MASK(zone_dma_bits)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "zone_dma_bits"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int zone_dma_bits;\n\nint dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask = (max_pfn - 1) << PAGE_SHIFT;\n\n\t/*\n\t * Because 32-bit DMA masks are so common we expect every architecture\n\t * to be able to satisfy them - either by not supporting more physical\n\t * memory, or by providing a ZONE_DMA32.  If neither is the case, the\n\t * architecture needs to use an IOMMU instead of the direct mapping.\n\t */\n\tif (mask >= DMA_BIT_MASK(32))\n\t\treturn 1;\n\n\t/*\n\t * This check needs to be against the actual bit mask value, so use\n\t * phys_to_dma_unencrypted() here so that the SME encryption mask isn't\n\t * part of the check.\n\t */\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));\n\treturn mask >= phys_to_dma_unencrypted(dev, min_mask);\n}"
  },
  {
    "function_name": "dma_direct_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "532-552",
    "snippet": "int dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long pfn = PHYS_PFN(dma_to_phys(dev, dma_addr));\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\tif (dma_mmap_from_global_coherent(vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (vma->vm_pgoff >= count || user_count > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "pfn + vma->vm_pgoff",
            "user_count << PAGE_SHIFT",
            "vma->vm_page_prot"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mmap_from_global_coherent",
          "args": [
            "vma",
            "cpu_addr",
            "size",
            "&ret"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dma_mmap_from_global_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "293-301",
          "snippet": "int dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *vaddr,\n\t\t\t\t   size_t size, int *ret)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn 0;\n\n\treturn __dma_mmap_from_coherent(dma_coherent_default_memory, vma,\n\t\t\t\t\tvaddr, size, ret);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *vaddr,\n\t\t\t\t   size_t size, int *ret)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn 0;\n\n\treturn __dma_mmap_from_coherent(dma_coherent_default_memory, vma,\n\t\t\t\t\tvaddr, size, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_mmap_from_dev_coherent",
          "args": [
            "dev",
            "vma",
            "cpu_addr",
            "size",
            "&ret"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dma_mmap_from_dev_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "263-269",
          "snippet": "int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_pgprot",
          "args": [
            "dev",
            "vma->vm_page_prot",
            "attrs"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "dma_pgprot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "408-419",
          "snippet": "pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\npgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "dma_to_phys(dev, dma_addr)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long pfn = PHYS_PFN(dma_to_phys(dev, dma_addr));\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\tif (dma_mmap_from_global_coherent(vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (vma->vm_pgoff >= count || user_count > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "dma_direct_can_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "526-530",
    "snippet": "bool dma_direct_can_mmap(struct device *dev)\n{\n\treturn dev_is_dma_coherent(dev) ||\n\t\tIS_ENABLED(CONFIG_DMA_NONCOHERENT_MMAP);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_NONCOHERENT_MMAP"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nbool dma_direct_can_mmap(struct device *dev)\n{\n\treturn dev_is_dma_coherent(dev) ||\n\t\tIS_ENABLED(CONFIG_DMA_NONCOHERENT_MMAP);\n}"
  },
  {
    "function_name": "dma_direct_get_sgtable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "513-524",
    "snippet": "int dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tstruct page *page = dma_direct_to_page(dev, dma_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "sgt->sgl",
            "page",
            "PAGE_ALIGN(size)",
            "0"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_alloc_table",
          "args": [
            "sgt",
            "1",
            "GFP_KERNEL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_to_page",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "33-37",
          "snippet": "static inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tstruct page *page = dma_direct_to_page(dev, dma_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_direct_map_resource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "497-511",
    "snippet": "dma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr = paddr;\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, false))) {\n\t\tdev_err_once(dev,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\tWARN_ON_ONCE(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err_once",
          "args": [
            "dev",
            "\"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\"",
            "&dma_addr",
            "size",
            "*dev->dma_mask",
            "dev->bus_dma_limit"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dma_capable(dev, dma_addr, size, false)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dma_addr",
            "size",
            "false"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\ndma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr = paddr;\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, false))) {\n\t\tdev_err_once(dev,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\tWARN_ON_ONCE(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}"
  },
  {
    "function_name": "dma_direct_map_sg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "476-495",
    "snippet": "int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = dma_direct_map_page(dev, sg_page(sg),\n\t\t\t\tsg->offset, sg->length, dir, attrs);\n\t\tif (sg->dma_address == DMA_MAPPING_ERROR)\n\t\t\tgoto out_unmap;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nents;\n\nout_unmap:\n\tdma_direct_unmap_sg(dev, sgl, i, dir, attrs | DMA_ATTR_SKIP_CPU_SYNC);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_unmap_sg",
          "args": [
            "dev",
            "sgl",
            "i",
            "dir",
            "attrs | DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_unmap_sg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "464-473",
          "snippet": "void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_map_page",
          "args": [
            "dev",
            "sg_page(sg)",
            "sg->offset",
            "sg->length",
            "dir",
            "attrs"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_map_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "83-106",
          "snippet": "static inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "sg"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nint dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tsg->dma_address = dma_direct_map_page(dev, sg_page(sg),\n\t\t\t\tsg->offset, sg->length, dir, attrs);\n\t\tif (sg->dma_address == DMA_MAPPING_ERROR)\n\t\t\tgoto out_unmap;\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nents;\n\nout_unmap:\n\tdma_direct_unmap_sg(dev, sgl, i, dir, attrs | DMA_ATTR_SKIP_CPU_SYNC);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "dma_direct_unmap_sg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "464-473",
    "snippet": "void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_direct_unmap_page",
          "args": [
            "dev",
            "sg->dma_address",
            "sg_dma_len(sg)",
            "dir",
            "attrs"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_unmap_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "108-118",
          "snippet": "static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i)\n\t\tdma_direct_unmap_page(dev, sg->dma_address, sg_dma_len(sg), dir,\n\t\t\t     attrs);\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "440-462",
    "snippet": "void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_cpu(paddr, sg->length, dir);\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_cpu(dev, paddr, sg->length,\n\t\t\t\t\t\t    dir);\n\n\t\tif (dir == DMA_FROM_DEVICE)\n\t\t\tarch_dma_mark_clean(paddr, sg->length);\n\t}\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_cpu_all();\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu_all",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_mark_clean",
          "args": [
            "paddr",
            "sg->length"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_sync_single_for_cpu",
          "args": [
            "dev",
            "paddr",
            "sg->length",
            "dir"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "705-712",
          "snippet": "void swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swiotlb_buffer(dev, paddr)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "paddr"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "paddr",
            "sg->length",
            "dir"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "sg_dma_address(sg)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_cpu(paddr, sg->length, dir);\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_cpu(dev, paddr, sg->length,\n\t\t\t\t\t\t    dir);\n\n\t\tif (dir == DMA_FROM_DEVICE)\n\t\t\tarch_dma_mark_clean(paddr, sg->length);\n\t}\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_cpu_all();\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "417-434",
    "snippet": "void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_device(dev, paddr, sg->length,\n\t\t\t\t\t\t       dir);\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_device(paddr, sg->length,\n\t\t\t\t\tdir);\n\t}\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "paddr",
            "sg->length",
            "dir"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_sync_single_for_device",
          "args": [
            "dev",
            "paddr",
            "sg->length",
            "dir"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "696-703",
          "snippet": "void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swiotlb_buffer(dev, paddr)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "paddr"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "sg_dma_address(sg)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sgl",
            "sg",
            "nents",
            "i"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_device(dev, paddr, sg->length,\n\t\t\t\t\t\t       dir);\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_device(paddr, sg->length,\n\t\t\t\t\tdir);\n\t}\n}"
  },
  {
    "function_name": "dma_direct_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "398-413",
    "snippet": "void dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_direct_free_pages",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "97-103",
          "snippet": "static void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_set_encrypted",
          "args": [
            "dev",
            "vaddr",
            "1 << page_order"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_encrypted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "85-95",
          "snippet": "static int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_free_from_pool",
          "args": [
            "dev",
            "vaddr",
            "size"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "283-295",
          "snippet": "bool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nbool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_COHERENT_POOL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tunsigned int page_order = get_order(size);\n\tvoid *vaddr = page_address(page);\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, 1 << page_order))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}"
  },
  {
    "function_name": "dma_direct_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "364-396",
    "snippet": "struct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_direct_free_pages",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "97-103",
          "snippet": "static void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_set_decrypted",
          "args": [
            "dev",
            "ret",
            "size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_decrypted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "78-83",
          "snippet": "static int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"Rejecting highmem page from CMA.\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_alloc_pages",
          "args": [
            "dev",
            "size",
            "gfp"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "117-157",
          "snippet": "static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc_from_pool",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "168-185",
          "snippet": "static void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_use_pool",
          "args": [
            "dev",
            "gfp"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_use_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "163-166",
          "snippet": "static bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstruct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here,\n\t\t * so log an error and fail.\n\t\t */\n\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\tgoto out_free_pages;\n\t}\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dma_direct_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "319-362",
    "snippet": "void dma_direct_free(struct device *dev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int page_order = get_order(size);\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev)) {\n\t\t/* cpu_addr is a struct page cookie, not a kernel address */\n\t\tdma_free_contiguous(dev, cpu_addr, size);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev) &&\n\t    !is_swiotlb_for_alloc(dev)) {\n\t\tarch_dma_free(dev, size, cpu_addr, dma_addr, attrs);\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev)) {\n\t\tif (!dma_release_from_global_coherent(page_order, cpu_addr))\n\t\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, cpu_addr, PAGE_ALIGN(size)))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_DMA_REMAP) && is_vmalloc_addr(cpu_addr)) {\n\t\tvunmap(cpu_addr);\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_DMA_CLEAR_UNCACHED))\n\t\t\tarch_dma_clear_uncached(cpu_addr, size);\n\t\tif (dma_set_encrypted(dev, cpu_addr, 1 << page_order))\n\t\t\treturn;\n\t}\n\n\t__dma_direct_free_pages(dev, dma_direct_to_page(dev, dma_addr), size);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_direct_free_pages",
          "args": [
            "dev",
            "dma_direct_to_page(dev, dma_addr)",
            "size"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "97-103",
          "snippet": "static void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_to_page",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "33-37",
          "snippet": "static inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_set_encrypted",
          "args": [
            "dev",
            "cpu_addr",
            "1 << page_order"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_encrypted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "85-95",
          "snippet": "static int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_clear_uncached",
          "args": [
            "cpu_addr",
            "size"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_CLEAR_UNCACHED"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "cpu_addr"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "cpu_addr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_REMAP"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_from_pool",
          "args": [
            "dev",
            "cpu_addr",
            "PAGE_ALIGN(size)"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "283-295",
          "snippet": "bool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nbool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_COHERENT_POOL"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_release_from_global_coherent",
          "args": [
            "page_order",
            "cpu_addr"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "dma_release_from_global_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "284-291",
          "snippet": "int dma_release_from_global_coherent(int order, void *vaddr)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn 0;\n\n\treturn __dma_release_from_coherent(dma_coherent_default_memory, order,\n\t\t\tvaddr);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_release_from_global_coherent(int order, void *vaddr)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn 0;\n\n\treturn __dma_release_from_coherent(dma_coherent_default_memory, order,\n\t\t\tvaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_GLOBAL_POOL"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_free",
          "args": [
            "dev",
            "size",
            "cpu_addr",
            "dma_addr",
            "attrs"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_GLOBAL_POOL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_DIRECT_REMAP"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_SET_UNCACHED"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_contiguous",
          "args": [
            "dev",
            "cpu_addr",
            "size"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "347-370",
          "snippet": "void dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid dma_direct_free(struct device *dev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int page_order = get_order(size);\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev)) {\n\t\t/* cpu_addr is a struct page cookie, not a kernel address */\n\t\tdma_free_contiguous(dev, cpu_addr, size);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev) &&\n\t    !is_swiotlb_for_alloc(dev)) {\n\t\tarch_dma_free(dev, size, cpu_addr, dma_addr, attrs);\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev)) {\n\t\tif (!dma_release_from_global_coherent(page_order, cpu_addr))\n\t\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\t/* If cpu_addr is not from an atomic pool, dma_free_from_pool() fails */\n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, cpu_addr, PAGE_ALIGN(size)))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_DMA_REMAP) && is_vmalloc_addr(cpu_addr)) {\n\t\tvunmap(cpu_addr);\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_DMA_CLEAR_UNCACHED))\n\t\t\tarch_dma_clear_uncached(cpu_addr, size);\n\t\tif (dma_set_encrypted(dev, cpu_addr, 1 << page_order))\n\t\t\treturn;\n\t}\n\n\t__dma_direct_free_pages(dev, dma_direct_to_page(dev, dma_addr), size);\n}"
  },
  {
    "function_name": "dma_direct_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "205-317",
    "snippet": "void *dma_direct_alloc(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tbool remap = false, set_uncached = false;\n\tstruct page *page;\n\tvoid *ret;\n\n\tsize = PAGE_ALIGN(size);\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_no_mapping(dev, size, dma_handle, gfp);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\t/*\n\t\t * Fallback to the arch handler if it exists.  This should\n\t\t * eventually go away.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t\t    !is_swiotlb_for_alloc(dev))\n\t\t\treturn arch_dma_alloc(dev, size, dma_handle, gfp,\n\t\t\t\t\t      attrs);\n\n\t\t/*\n\t\t * If there is a global pool, always allocate from it for\n\t\t * non-coherent devices.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL))\n\t\t\treturn dma_alloc_from_global_coherent(dev, size,\n\t\t\t\t\tdma_handle);\n\n\t\t/*\n\t\t * Otherwise remap if the architecture is asking for it.  But\n\t\t * given that remapping memory is a blocking operation we'll\n\t\t * instead have to dip into the atomic pools.\n\t\t */\n\t\tremap = IS_ENABLED(CONFIG_DMA_DIRECT_REMAP);\n\t\tif (remap) {\n\t\t\tif (dma_direct_use_pool(dev, gfp))\n\t\t\t\treturn dma_direct_alloc_from_pool(dev, size,\n\t\t\t\t\t\tdma_handle, gfp);\n\t\t} else {\n\t\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED))\n\t\t\t\treturn NULL;\n\t\t\tset_uncached = true;\n\t\t}\n\t}\n\n\t/*\n\t * Decrypting memory may block, so allocate the memory from the atomic\n\t * pools if we can't block.\n\t */\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\t/* we always manually zero the memory once we are done */\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup,\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here, so\n\t\t * log an error and fail.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_DMA_REMAP)) {\n\t\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\t\tgoto out_free_pages;\n\t\t}\n\t\tremap = true;\n\t\tset_uncached = false;\n\t}\n\n\tif (remap) {\n\t\t/* remove any dirty cache lines on the kernel alias */\n\t\tarch_dma_prep_coherent(page, size);\n\n\t\t/* create a coherent mapping */\n\t\tret = dma_common_contiguous_remap(page, size,\n\t\t\t\tdma_pgprot(dev, PAGE_KERNEL, attrs),\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ret)\n\t\t\tgoto out_free_pages;\n\t} else {\n\t\tret = page_address(page);\n\t\tif (dma_set_decrypted(dev, ret, size))\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemset(ret, 0, size);\n\n\tif (set_uncached) {\n\t\tarch_dma_prep_coherent(page, size);\n\t\tret = arch_dma_set_uncached(ret, size);\n\t\tif (IS_ERR(ret))\n\t\t\tgoto out_encrypt_pages;\n\t}\n\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n\nout_encrypt_pages:\n\tif (dma_set_encrypted(dev, page_address(page), size))\n\t\treturn NULL;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_direct_free_pages",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "97-103",
          "snippet": "static void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_set_encrypted",
          "args": [
            "dev",
            "page_address(page)",
            "size"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_encrypted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "85-95",
          "snippet": "static int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_set_uncached",
          "args": [
            "ret",
            "size"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_prep_coherent",
          "args": [
            "page",
            "size"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_set_decrypted",
          "args": [
            "dev",
            "ret",
            "size"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "dma_set_decrypted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "78-83",
          "snippet": "static int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_common_contiguous_remap",
          "args": [
            "page",
            "size",
            "dma_pgprot(dev, PAGE_KERNEL, attrs)",
            "__builtin_return_address(0)"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "dma_common_contiguous_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/remap.c",
          "lines": "38-55",
          "snippet": "void *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tstruct page **pages;\n\tvoid *vaddr;\n\tint i;\n\n\tpages = kmalloc_array(count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\tfor (i = 0; i < count; i++)\n\t\tpages[i] = nth_page(page, i);\n\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/dma-map-ops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/dma-map-ops.h>\n\nvoid *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tstruct page **pages;\n\tvoid *vaddr;\n\tint i;\n\n\tpages = kmalloc_array(count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\tfor (i = 0; i < count; i++)\n\t\tpages[i] = nth_page(page, i);\n\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_pgprot",
          "args": [
            "dev",
            "PAGE_KERNEL",
            "attrs"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dma_pgprot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "408-419",
          "snippet": "pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\npgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_prep_coherent",
          "args": [
            "page",
            "size"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"Rejecting highmem page from CMA.\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_REMAP"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_alloc_pages",
          "args": [
            "dev",
            "size",
            "gfp & ~__GFP_ZERO"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "117-157",
          "snippet": "static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc_from_pool",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "168-185",
          "snippet": "static void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_use_pool",
          "args": [
            "dev",
            "gfp"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_use_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "163-166",
          "snippet": "static bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_SET_UNCACHED"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_DIRECT_REMAP"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_from_global_coherent",
          "args": [
            "dev",
            "size",
            "dma_handle"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_from_global_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "274-282",
          "snippet": "void *dma_alloc_from_global_coherent(struct device *dev, ssize_t size,\n\t\t\t\t     dma_addr_t *dma_handle)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn NULL;\n\n\treturn __dma_alloc_from_coherent(dev, dma_coherent_default_memory, size,\n\t\t\t\t\t dma_handle);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nvoid *dma_alloc_from_global_coherent(struct device *dev, ssize_t size,\n\t\t\t\t     dma_addr_t *dma_handle)\n{\n\tif (!dma_coherent_default_memory)\n\t\treturn NULL;\n\n\treturn __dma_alloc_from_coherent(dev, dma_coherent_default_memory, size,\n\t\t\t\t\t dma_handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_GLOBAL_POOL"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_alloc",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp",
            "attrs"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_GLOBAL_POOL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_DIRECT_REMAP"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_SET_UNCACHED"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc_no_mapping",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_no_mapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "187-203",
          "snippet": "static void *dma_direct_alloc_no_mapping(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\n\t/* remove any dirty cache lines on the kernel alias */\n\tif (!PageHighMem(page))\n\t\tarch_dma_prep_coherent(page, size);\n\n\t/* return the page pointer as the opaque cookie */\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void *dma_direct_alloc_no_mapping(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\n\t/* remove any dirty cache lines on the kernel alias */\n\tif (!PageHighMem(page))\n\t\tarch_dma_prep_coherent(page, size);\n\n\t/* return the page pointer as the opaque cookie */\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nvoid *dma_direct_alloc(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tbool remap = false, set_uncached = false;\n\tstruct page *page;\n\tvoid *ret;\n\n\tsize = PAGE_ALIGN(size);\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_no_mapping(dev, size, dma_handle, gfp);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\t/*\n\t\t * Fallback to the arch handler if it exists.  This should\n\t\t * eventually go away.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t\t    !is_swiotlb_for_alloc(dev))\n\t\t\treturn arch_dma_alloc(dev, size, dma_handle, gfp,\n\t\t\t\t\t      attrs);\n\n\t\t/*\n\t\t * If there is a global pool, always allocate from it for\n\t\t * non-coherent devices.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL))\n\t\t\treturn dma_alloc_from_global_coherent(dev, size,\n\t\t\t\t\tdma_handle);\n\n\t\t/*\n\t\t * Otherwise remap if the architecture is asking for it.  But\n\t\t * given that remapping memory is a blocking operation we'll\n\t\t * instead have to dip into the atomic pools.\n\t\t */\n\t\tremap = IS_ENABLED(CONFIG_DMA_DIRECT_REMAP);\n\t\tif (remap) {\n\t\t\tif (dma_direct_use_pool(dev, gfp))\n\t\t\t\treturn dma_direct_alloc_from_pool(dev, size,\n\t\t\t\t\t\tdma_handle, gfp);\n\t\t} else {\n\t\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED))\n\t\t\t\treturn NULL;\n\t\t\tset_uncached = true;\n\t\t}\n\t}\n\n\t/*\n\t * Decrypting memory may block, so allocate the memory from the atomic\n\t * pools if we can't block.\n\t */\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\t/* we always manually zero the memory once we are done */\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\tif (PageHighMem(page)) {\n\t\t/*\n\t\t * Depending on the cma= arguments and per-arch setup,\n\t\t * dma_alloc_contiguous could return highmem pages.\n\t\t * Without remapping there is no way to return them here, so\n\t\t * log an error and fail.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_DMA_REMAP)) {\n\t\t\tdev_info(dev, \"Rejecting highmem page from CMA.\\n\");\n\t\t\tgoto out_free_pages;\n\t\t}\n\t\tremap = true;\n\t\tset_uncached = false;\n\t}\n\n\tif (remap) {\n\t\t/* remove any dirty cache lines on the kernel alias */\n\t\tarch_dma_prep_coherent(page, size);\n\n\t\t/* create a coherent mapping */\n\t\tret = dma_common_contiguous_remap(page, size,\n\t\t\t\tdma_pgprot(dev, PAGE_KERNEL, attrs),\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ret)\n\t\t\tgoto out_free_pages;\n\t} else {\n\t\tret = page_address(page);\n\t\tif (dma_set_decrypted(dev, ret, size))\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemset(ret, 0, size);\n\n\tif (set_uncached) {\n\t\tarch_dma_prep_coherent(page, size);\n\t\tret = arch_dma_set_uncached(ret, size);\n\t\tif (IS_ERR(ret))\n\t\t\tgoto out_encrypt_pages;\n\t}\n\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n\nout_encrypt_pages:\n\tif (dma_set_encrypted(dev, page_address(page), size))\n\t\treturn NULL;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dma_direct_alloc_no_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "187-203",
    "snippet": "static void *dma_direct_alloc_no_mapping(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\n\t/* remove any dirty cache lines on the kernel alias */\n\tif (!PageHighMem(page))\n\t\tarch_dma_prep_coherent(page, size);\n\n\t/* return the page pointer as the opaque cookie */\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_prep_coherent",
          "args": [
            "page",
            "size"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_direct_alloc_pages",
          "args": [
            "dev",
            "size",
            "gfp & ~__GFP_ZERO"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_direct_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "117-157",
          "snippet": "static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void *dma_direct_alloc_no_mapping(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO);\n\tif (!page)\n\t\treturn NULL;\n\n\t/* remove any dirty cache lines on the kernel alias */\n\tif (!PageHighMem(page))\n\t\tarch_dma_prep_coherent(page, size);\n\n\t/* return the page pointer as the opaque cookie */\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\n}"
  },
  {
    "function_name": "dma_direct_alloc_from_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "168-185",
    "snippet": "static void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "page_to_phys(page)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_from_pool",
          "args": [
            "dev",
            "size",
            "&ret",
            "gfp",
            "dma_coherent_ok"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "265-281",
          "snippet": "struct page *dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tvoid **cpu_addr, gfp_t gfp,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tstruct gen_pool *pool = NULL;\n\tstruct page *page;\n\n\twhile ((pool = dma_guess_pool(pool, gfp))) {\n\t\tpage = __dma_alloc_from_pool(dev, size, pool, cpu_addr,\n\t\t\t\t\t     phys_addr_ok);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\tWARN(1, \"Failed to get suitable pool for %s\\n\", dev_name(dev));\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstruct page *dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tvoid **cpu_addr, gfp_t gfp,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tstruct gen_pool *pool = NULL;\n\tstruct page *page;\n\n\twhile ((pool = dma_guess_pool(pool, gfp))) {\n\t\tpage = __dma_alloc_from_pool(dev, size, pool, cpu_addr,\n\t\t\t\t\t     phys_addr_ok);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\tWARN(1, \"Failed to get suitable pool for %s\\n\", dev_name(dev));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_optimal_gfp_mask",
          "args": [
            "dev",
            "dev->coherent_dma_mask",
            "&phys_mask"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_optimal_gfp_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "47-66",
          "snippet": "static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int zone_dma_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int zone_dma_bits;\n\nstatic gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DMA_COHERENT_POOL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_mask;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_mask);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_direct_use_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "163-166",
    "snippet": "static bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}"
  },
  {
    "function_name": "__dma_direct_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "117-157",
    "snippet": "static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "64"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_contiguous",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "347-370",
          "snippet": "void dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_coherent_ok",
          "args": [
            "dev",
            "page_to_phys(page)",
            "size"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "dma_coherent_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "68-76",
          "snippet": "static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "gfp",
            "get_order(size)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_contiguous",
          "args": [
            "dev",
            "size",
            "gfp"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "304-334",
          "snippet": "struct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp)\n{\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tint nid = dev_to_node(dev);\n#endif\n\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (!gfpflags_allow_blocking(gfp))\n\t\treturn NULL;\n\tif (dev->cma_area)\n\t\treturn cma_alloc_aligned(dev->cma_area, size, gfp);\n\tif (size <= PAGE_SIZE)\n\t\treturn NULL;\n\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tif (nid != NUMA_NO_NODE && !(gfp & (GFP_DMA | GFP_DMA32))) {\n\t\tstruct cma *cma = dma_contiguous_pernuma_area[nid];\n\t\tstruct page *page;\n\n\t\tif (cma) {\n\t\t\tpage = cma_alloc_aligned(cma, size, gfp);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\tif (!dma_contiguous_default_area)\n\t\treturn NULL;\n\n\treturn cma_alloc_aligned(dma_contiguous_default_area, size, gfp);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nstruct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp)\n{\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tint nid = dev_to_node(dev);\n#endif\n\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (!gfpflags_allow_blocking(gfp))\n\t\treturn NULL;\n\tif (dev->cma_area)\n\t\treturn cma_alloc_aligned(dev->cma_area, size, gfp);\n\tif (size <= PAGE_SIZE)\n\t\treturn NULL;\n\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tif (nid != NUMA_NO_NODE && !(gfp & (GFP_DMA | GFP_DMA32))) {\n\t\tstruct cma *cma = dma_contiguous_pernuma_area[nid];\n\t\tstruct page *page;\n\n\t\tif (cma) {\n\t\t\tpage = cma_alloc_aligned(cma, size, gfp);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\tif (!dma_contiguous_default_area)\n\t\treturn NULL;\n\n\treturn cma_alloc_aligned(dma_contiguous_default_area, size, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_optimal_gfp_mask",
          "args": [
            "dev",
            "dev->coherent_dma_mask",
            "&phys_limit"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_optimal_gfp_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "47-66",
          "snippet": "static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int zone_dma_bits"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int zone_dma_bits;\n\nstatic gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_direct_alloc_swiotlb",
          "args": [
            "dev",
            "size"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_alloc_swiotlb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "105-115",
          "snippet": "static struct page *dma_direct_alloc_swiotlb(struct device *dev, size_t size)\n{\n\tstruct page *page = swiotlb_alloc(dev, size);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tswiotlb_free(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *dma_direct_alloc_swiotlb(struct device *dev, size_t size)\n{\n\tstruct page *page = swiotlb_alloc(dev, size);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tswiotlb_free(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swiotlb_for_alloc",
          "args": [
            "dev"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PAGE_ALIGNED(size)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "size"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,\n\t\t\t\t\t   &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "dma_direct_alloc_swiotlb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "105-115",
    "snippet": "static struct page *dma_direct_alloc_swiotlb(struct device *dev, size_t size)\n{\n\tstruct page *page = swiotlb_alloc(dev, size);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tswiotlb_free(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_free",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "820-830",
          "snippet": "bool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nbool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_coherent_ok",
          "args": [
            "dev",
            "page_to_phys(page)",
            "size"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "dma_coherent_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "68-76",
          "snippet": "static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_alloc",
          "args": [
            "dev",
            "size"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "802-818",
          "snippet": "struct page *swiotlb_alloc(struct device *dev, size_t size)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tphys_addr_t tlb_addr;\n\tint index;\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tindex = swiotlb_find_slots(dev, 0, size, 0);\n\tif (index == -1)\n\t\treturn NULL;\n\n\ttlb_addr = slot_addr(mem->start, index);\n\n\treturn pfn_to_page(PFN_DOWN(tlb_addr));\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nstruct page *swiotlb_alloc(struct device *dev, size_t size)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tphys_addr_t tlb_addr;\n\tint index;\n\n\tif (!mem)\n\t\treturn NULL;\n\n\tindex = swiotlb_find_slots(dev, 0, size, 0);\n\tif (index == -1)\n\t\treturn NULL;\n\n\ttlb_addr = slot_addr(mem->start, index);\n\n\treturn pfn_to_page(PFN_DOWN(tlb_addr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic struct page *dma_direct_alloc_swiotlb(struct device *dev, size_t size)\n{\n\tstruct page *page = swiotlb_alloc(dev, size);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tswiotlb_free(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "__dma_direct_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "97-103",
    "snippet": "static void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_free_contiguous",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "347-370",
          "snippet": "void dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "swiotlb_free",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "820-830",
          "snippet": "bool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nbool swiotlb_free(struct device *dev, struct page *page, size_t size)\n{\n\tphys_addr_t tlb_addr = page_to_phys(page);\n\n\tif (!is_swiotlb_buffer(dev, tlb_addr))\n\t\treturn false;\n\n\tswiotlb_release_slots(dev, tlb_addr);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}"
  },
  {
    "function_name": "dma_set_encrypted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "85-95",
    "snippet": "static int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"leaking DMA memory that can't be re-encrypted\\n\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_encrypted",
          "args": [
            "(unsigned long)vaddr",
            "1 << get_order(size)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, 1 << get_order(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_set_decrypted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "78-83",
    "snippet": "static int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)vaddr",
            "1 << get_order(size)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, 1 << get_order(size));\n}"
  },
  {
    "function_name": "dma_coherent_ok",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "68-76",
    "snippet": "static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_not_zero",
          "args": [
            "dev->coherent_dma_mask",
            "dev->bus_dma_limit"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "phys"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}"
  },
  {
    "function_name": "dma_direct_optimal_gfp_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "47-66",
    "snippet": "static gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int zone_dma_bits"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "zone_dma_bits"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "dma_limit"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_not_zero",
          "args": [
            "dma_mask",
            "dev->bus_dma_limit"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nunsigned int zone_dma_bits;\n\nstatic gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,\n\t\t\t\t  u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(dma_mask, dev->bus_dma_limit);\n\n\t/*\n\t * Optimistically try the zone that the physical address mask falls\n\t * into first.  If that returns memory that isn't actually addressable\n\t * we will fallback to the next lower zone and try again.\n\t *\n\t * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding\n\t * zones.\n\t */\n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_direct_get_required_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "39-45",
    "snippet": "u64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "max_dma"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma_direct",
          "args": [
            "dev",
            "phys"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "max_pfn - 1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nu64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}"
  },
  {
    "function_name": "dma_direct_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "33-37",
    "snippet": "static inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "PHYS_PFN(dma_to_phys(dev, dma_addr))"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "dma_to_phys(dev, dma_addr)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}"
  },
  {
    "function_name": "phys_to_dma_direct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
    "lines": "25-31",
    "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
    "includes": [
      "#include \"direct.h\"",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pfn.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/memblock.h> /* for max_pfn */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "phys_to_dma_unencrypted",
          "args": [
            "dev",
            "phys"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_dma_unencrypted",
          "args": [
            "dev"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
  }
]