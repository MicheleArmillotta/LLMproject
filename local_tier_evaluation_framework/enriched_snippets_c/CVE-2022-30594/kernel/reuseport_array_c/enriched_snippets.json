[
  {
    "function_name": "reuseport_array_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "321-338",
    "snippet": "static int reuseport_array_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = (u32 *)next_key;\n\n\tif (index >= array->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == array->map.max_entries - 1)\n\t\treturn -ENOENT;\n\n\t*next = index + 1;\n\treturn 0;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reuseport_array",
          "args": [
            "map"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "151-168",
          "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic int reuseport_array_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = (u32 *)next_key;\n\n\tif (index >= array->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == array->map.max_entries - 1)\n\t\treturn -ENOENT;\n\n\t*next = index + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_fd_reuseport_array_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "237-318",
    "snippet": "int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tuintptr_t sk_user_data;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |\n\t\tSK_USER_DATA_BPF;\n\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "socket->file"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&reuseport_lock"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&free_osk->sk_callback_lock"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "free_osk->sk_user_data",
            "NULL"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&free_osk->sk_callback_lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "332-335",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "array->ptrs[index]",
            "nsk"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "nsk->sk_user_data",
            "(void *)sk_user_data"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuseport_array_update_check",
          "args": [
            "array",
            "nsk",
            "osk",
            "reuse",
            "map_flags"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_update_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "192-230",
          "snippet": "static int\nreuseport_array_update_check(const struct reuseport_array *array,\n\t\t\t     const struct sock *nsk,\n\t\t\t     const struct sock *osk,\n\t\t\t     const struct sock_reuseport *nsk_reuse,\n\t\t\t     u32 map_flags)\n{\n\tif (osk && map_flags == BPF_NOEXIST)\n\t\treturn -EEXIST;\n\n\tif (!osk && map_flags == BPF_EXIST)\n\t\treturn -ENOENT;\n\n\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * sk must be hashed (i.e. listening in the TCP case or binded\n\t * in the UDP case) and\n\t * it must also be a SO_REUSEPORT sk (i.e. reuse cannot be NULL).\n\t *\n\t * Also, sk will be used in bpf helper that is protected by\n\t * rcu_read_lock().\n\t */\n\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)\n\t\treturn -EINVAL;\n\n\t/* READ_ONCE because the sk->sk_callback_lock may not be held here */\n\tif (READ_ONCE(nsk->sk_user_data))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic int\nreuseport_array_update_check(const struct reuseport_array *array,\n\t\t\t     const struct sock *nsk,\n\t\t\t     const struct sock *osk,\n\t\t\t     const struct sock_reuseport *nsk_reuse,\n\t\t\t     u32 map_flags)\n{\n\tif (osk && map_flags == BPF_NOEXIST)\n\t\treturn -EEXIST;\n\n\tif (!osk && map_flags == BPF_EXIST)\n\t\treturn -ENOENT;\n\n\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * sk must be hashed (i.e. listening in the TCP case or binded\n\t * in the UDP case) and\n\t * it must also be a SO_REUSEPORT sk (i.e. reuse cannot be NULL).\n\t *\n\t * Also, sk will be used in bpf helper that is protected by\n\t * rcu_read_lock().\n\t */\n\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)\n\t\treturn -EINVAL;\n\n\t/* READ_ONCE because the sk->sk_callback_lock may not be held here */\n\tif (READ_ONCE(nsk->sk_user_data))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "nsk->sk_reuseport_cb",
            "lockdep_is_held(&reuseport_lock)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&reuseport_lock"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "array->ptrs[index]",
            "lockdep_is_held(&reuseport_lock)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&reuseport_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "nsk->sk_reuseport_cb"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "array->ptrs[index]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sockfd_lookup",
          "args": [
            "fd",
            "&err"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuseport_array",
          "args": [
            "map"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "151-168",
          "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tuintptr_t sk_user_data;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |\n\t\tSK_USER_DATA_BPF;\n\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}"
  },
  {
    "function_name": "reuseport_array_update_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "192-230",
    "snippet": "static int\nreuseport_array_update_check(const struct reuseport_array *array,\n\t\t\t     const struct sock *nsk,\n\t\t\t     const struct sock *osk,\n\t\t\t     const struct sock_reuseport *nsk_reuse,\n\t\t\t     u32 map_flags)\n{\n\tif (osk && map_flags == BPF_NOEXIST)\n\t\treturn -EEXIST;\n\n\tif (!osk && map_flags == BPF_EXIST)\n\t\treturn -ENOENT;\n\n\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * sk must be hashed (i.e. listening in the TCP case or binded\n\t * in the UDP case) and\n\t * it must also be a SO_REUSEPORT sk (i.e. reuse cannot be NULL).\n\t *\n\t * Also, sk will be used in bpf helper that is protected by\n\t * rcu_read_lock().\n\t */\n\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)\n\t\treturn -EINVAL;\n\n\t/* READ_ONCE because the sk->sk_callback_lock may not be held here */\n\tif (READ_ONCE(nsk->sk_user_data))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nsk->sk_user_data"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_hashed",
          "args": [
            "nsk"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_flag",
          "args": [
            "nsk",
            "SOCK_RCU_FREE"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic int\nreuseport_array_update_check(const struct reuseport_array *array,\n\t\t\t     const struct sock *nsk,\n\t\t\t     const struct sock *osk,\n\t\t\t     const struct sock_reuseport *nsk_reuse,\n\t\t\t     u32 map_flags)\n{\n\tif (osk && map_flags == BPF_NOEXIST)\n\t\treturn -EEXIST;\n\n\tif (!osk && map_flags == BPF_EXIST)\n\t\treturn -ENOENT;\n\n\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * sk must be hashed (i.e. listening in the TCP case or binded\n\t * in the UDP case) and\n\t * it must also be a SO_REUSEPORT sk (i.e. reuse cannot be NULL).\n\t *\n\t * Also, sk will be used in bpf helper that is protected by\n\t * rcu_read_lock().\n\t */\n\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)\n\t\treturn -EINVAL;\n\n\t/* READ_ONCE because the sk->sk_callback_lock may not be held here */\n\tif (READ_ONCE(nsk->sk_user_data))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_fd_reuseport_array_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "170-190",
    "snippet": "int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = __sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sock_gen_cookie",
          "args": [
            "sk"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuseport_array_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "52-61",
          "snippet": "static void *reuseport_array_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn rcu_dereference(array->ptrs[index]);\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic void *reuseport_array_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn rcu_dereference(array->ptrs[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = __sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}"
  },
  {
    "function_name": "reuseport_array_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "151-168",
    "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&array->map",
            "attr"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "struct_size(array, ptrs, attr->max_entries)",
            "numa_node"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "array",
            "ptrs",
            "attr->max_entries"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
  },
  {
    "function_name": "reuseport_array_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "96-149",
    "snippet": "static void reuseport_array_free(struct bpf_map *map)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *sk;\n\tu32 i;\n\n\t/*\n\t * ops->map_*_elem() will not be able to access this\n\t * array now. Hence, this function only races with\n\t * bpf_sk_reuseport_detach() which was triggered by\n\t * close() or disconnect().\n\t *\n\t * This function and bpf_sk_reuseport_detach() are\n\t * both removing sk from \"array\".  Who removes it\n\t * first does not matter.\n\t *\n\t * The only concern here is bpf_sk_reuseport_detach()\n\t * may access \"array\" which is being freed here.\n\t * bpf_sk_reuseport_detach() access this \"array\"\n\t * through sk->sk_user_data _and_ with sk->sk_callback_lock\n\t * held which is enough because this \"array\" is not freed\n\t * until all sk->sk_user_data has stopped referencing this \"array\".\n\t *\n\t * Hence, due to the above, taking \"reuseport_lock\" is not\n\t * needed here.\n\t */\n\n\t/*\n\t * Since reuseport_lock is not taken, sk is accessed under\n\t * rcu_read_lock()\n\t */\n\trcu_read_lock();\n\tfor (i = 0; i < map->max_entries; i++) {\n\t\tsk = rcu_dereference(array->ptrs[i]);\n\t\tif (sk) {\n\t\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\t\t/*\n\t\t\t * No need for WRITE_ONCE(). At this point,\n\t\t\t * no one is reading it without taking the\n\t\t\t * sk->sk_callback_lock.\n\t\t\t */\n\t\t\tsk->sk_user_data = NULL;\n\t\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\t\tRCU_INIT_POINTER(array->ptrs[i], NULL);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Once reaching here, all sk->sk_user_data is not\n\t * referenceing this \"array\".  \"array\" can be freed now.\n\t */\n\tbpf_map_area_free(array);\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "array"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "array->ptrs[i]",
            "NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "332-335",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "array->ptrs[i]"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "reuseport_array",
          "args": [
            "map"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "151-168",
          "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic void reuseport_array_free(struct bpf_map *map)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *sk;\n\tu32 i;\n\n\t/*\n\t * ops->map_*_elem() will not be able to access this\n\t * array now. Hence, this function only races with\n\t * bpf_sk_reuseport_detach() which was triggered by\n\t * close() or disconnect().\n\t *\n\t * This function and bpf_sk_reuseport_detach() are\n\t * both removing sk from \"array\".  Who removes it\n\t * first does not matter.\n\t *\n\t * The only concern here is bpf_sk_reuseport_detach()\n\t * may access \"array\" which is being freed here.\n\t * bpf_sk_reuseport_detach() access this \"array\"\n\t * through sk->sk_user_data _and_ with sk->sk_callback_lock\n\t * held which is enough because this \"array\" is not freed\n\t * until all sk->sk_user_data has stopped referencing this \"array\".\n\t *\n\t * Hence, due to the above, taking \"reuseport_lock\" is not\n\t * needed here.\n\t */\n\n\t/*\n\t * Since reuseport_lock is not taken, sk is accessed under\n\t * rcu_read_lock()\n\t */\n\trcu_read_lock();\n\tfor (i = 0; i < map->max_entries; i++) {\n\t\tsk = rcu_dereference(array->ptrs[i]);\n\t\tif (sk) {\n\t\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\t\t/*\n\t\t\t * No need for WRITE_ONCE(). At this point,\n\t\t\t * no one is reading it without taking the\n\t\t\t * sk->sk_callback_lock.\n\t\t\t */\n\t\t\tsk->sk_user_data = NULL;\n\t\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\t\tRCU_INIT_POINTER(array->ptrs[i], NULL);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * Once reaching here, all sk->sk_user_data is not\n\t * referenceing this \"array\".  \"array\" can be freed now.\n\t */\n\tbpf_map_area_free(array);\n}"
  },
  {
    "function_name": "reuseport_array_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "64-94",
    "snippet": "static int reuseport_array_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\tstruct sock *sk;\n\tint err;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (!rcu_access_pointer(array->ptrs[index]))\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&reuseport_lock);\n\n\tsk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t       lockdep_is_held(&reuseport_lock));\n\tif (sk) {\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\tRCU_INIT_POINTER(array->ptrs[index], NULL);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&reuseport_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "array->ptrs[index]",
            "NULL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sk->sk_user_data",
            "NULL"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "332-335",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "array->ptrs[index]",
            "lockdep_is_held(&reuseport_lock)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&reuseport_lock"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&reuseport_lock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "array->ptrs[index]"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuseport_array",
          "args": [
            "map"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "151-168",
          "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic int reuseport_array_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\tstruct sock *sk;\n\tint err;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (!rcu_access_pointer(array->ptrs[index]))\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&reuseport_lock);\n\n\tsk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t       lockdep_is_held(&reuseport_lock));\n\tif (sk) {\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\tRCU_INIT_POINTER(array->ptrs[index], NULL);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "reuseport_array_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "52-61",
    "snippet": "static void *reuseport_array_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn rcu_dereference(array->ptrs[index]);\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "array->ptrs[index]"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuseport_array",
          "args": [
            "map"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "reuseport_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "151-168",
          "snippet": "static struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* allocate all map elements and zero-initialize them */\n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic void *reuseport_array_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn rcu_dereference(array->ptrs[index]);\n}"
  },
  {
    "function_name": "reuseport_array_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "43-50",
    "snippet": "static int reuseport_array_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32) &&\n\t    attr->value_size != sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn array_map_alloc_check(attr);\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_map_alloc_check",
          "args": [
            "attr"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_alloc_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "730-739",
          "snippet": "static int fd_array_map_alloc_check(union bpf_attr *attr)\n{\n\t/* only file descriptors can be stored in this type of map */\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\t/* Program read-only/write-only not supported for special maps yet. */\n\tif (attr->map_flags & (BPF_F_RDONLY_PROG | BPF_F_WRONLY_PROG))\n\t\treturn -EINVAL;\n\treturn array_map_alloc_check(attr);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_array_map_alloc_check(union bpf_attr *attr)\n{\n\t/* only file descriptors can be stored in this type of map */\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\t/* Program read-only/write-only not supported for special maps yet. */\n\tif (attr->map_flags & (BPF_F_RDONLY_PROG | BPF_F_WRONLY_PROG))\n\t\treturn -EINVAL;\n\treturn array_map_alloc_check(attr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic int reuseport_array_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32) &&\n\t    attr->value_size != sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn array_map_alloc_check(attr);\n}"
  },
  {
    "function_name": "bpf_sk_reuseport_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "21-41",
    "snippet": "void bpf_sk_reuseport_detach(struct sock *sk)\n{\n\tuintptr_t sk_user_data;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk_user_data = (uintptr_t)sk->sk_user_data;\n\tif (sk_user_data & SK_USER_DATA_BPF) {\n\t\tstruct sock __rcu **socks;\n\n\t\tsocks = (void *)(sk_user_data & SK_USER_DATA_PTRMASK);\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\t/*\n\t\t * Do not move this NULL assignment outside of\n\t\t * sk->sk_callback_lock because there is\n\t\t * a race with reuseport_array_free()\n\t\t * which does not hold the reuseport_lock.\n\t\t */\n\t\tRCU_INIT_POINTER(*socks, NULL);\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "364-367",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*socks",
            "NULL"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sk->sk_user_data",
            "NULL"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_bh",
          "args": [
            "&sk->sk_callback_lock"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "332-335",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nvoid bpf_sk_reuseport_detach(struct sock *sk)\n{\n\tuintptr_t sk_user_data;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk_user_data = (uintptr_t)sk->sk_user_data;\n\tif (sk_user_data & SK_USER_DATA_BPF) {\n\t\tstruct sock __rcu **socks;\n\n\t\tsocks = (void *)(sk_user_data & SK_USER_DATA_PTRMASK);\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\t/*\n\t\t * Do not move this NULL assignment outside of\n\t\t * sk->sk_callback_lock because there is\n\t\t * a race with reuseport_array_free()\n\t\t * which does not hold the reuseport_lock.\n\t\t */\n\t\tRCU_INIT_POINTER(*socks, NULL);\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}"
  },
  {
    "function_name": "reuseport_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
    "lines": "15-18",
    "snippet": "static struct reuseport_array *reuseport_array(struct bpf_map *map)\n{\n\treturn (struct reuseport_array *)map;\n}",
    "includes": [
      "#include <net/sock_reuseport.h>",
      "#include <linux/sock_diag.h>",
      "#include <linux/err.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nstatic struct reuseport_array *reuseport_array(struct bpf_map *map)\n{\n\treturn (struct reuseport_array *)map;\n}"
  }
]