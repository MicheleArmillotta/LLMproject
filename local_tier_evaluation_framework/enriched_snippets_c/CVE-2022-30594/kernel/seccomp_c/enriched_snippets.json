[
  {
    "function_name": "proc_pid_seccomp_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2377-2415",
    "snippet": "int proc_pid_seccomp_cache(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tstruct seccomp_filter *f;\n\tunsigned long flags;\n\n\t/*\n\t * We don't want some sandboxed process to know what their seccomp\n\t * filters consist of.\n\t */\n\tif (!file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn -ESRCH;\n\n\tf = READ_ONCE(task->seccomp.filter);\n\tif (!f) {\n\t\tunlock_task_sighand(task, &flags);\n\t\treturn 0;\n\t}\n\n\t/* prevent filter from being freed while we are printing it */\n\t__get_seccomp_filter(f);\n\tunlock_task_sighand(task, &flags);\n\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_NATIVE_NAME,\n\t\t\t\t    f->cache.allow_native,\n\t\t\t\t    SECCOMP_ARCH_NATIVE_NR);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_COMPAT_NAME,\n\t\t\t\t    f->cache.allow_compat,\n\t\t\t\t    SECCOMP_ARCH_COMPAT_NR);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\t__put_seccomp_filter(f);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "f"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_seccomp_cache_arch",
          "args": [
            "m",
            "SECCOMP_ARCH_COMPAT_NAME",
            "f->cache.allow_compat",
            "SECCOMP_ARCH_COMPAT_NR"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_seccomp_cache_arch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2364-2375",
          "snippet": "static void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,\n\t\t\t\t\tconst void *bitmap, size_t bitmap_size)\n{\n\tint nr;\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\tbool cached = test_bit(nr, bitmap);\n\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";\n\n\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,\n\t\t\t\t\tconst void *bitmap, size_t bitmap_size)\n{\n\tint nr;\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\tbool cached = test_bit(nr, bitmap);\n\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";\n\n\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "f"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "909-912",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "task->seccomp.filter"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "m->file",
            "&init_user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "466-477",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nint proc_pid_seccomp_cache(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tstruct seccomp_filter *f;\n\tunsigned long flags;\n\n\t/*\n\t * We don't want some sandboxed process to know what their seccomp\n\t * filters consist of.\n\t */\n\tif (!file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn -ESRCH;\n\n\tf = READ_ONCE(task->seccomp.filter);\n\tif (!f) {\n\t\tunlock_task_sighand(task, &flags);\n\t\treturn 0;\n\t}\n\n\t/* prevent filter from being freed while we are printing it */\n\t__get_seccomp_filter(f);\n\tunlock_task_sighand(task, &flags);\n\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_NATIVE_NAME,\n\t\t\t\t    f->cache.allow_native,\n\t\t\t\t    SECCOMP_ARCH_NATIVE_NR);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_COMPAT_NAME,\n\t\t\t\t    f->cache.allow_compat,\n\t\t\t\t    SECCOMP_ARCH_COMPAT_NR);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\t__put_seccomp_filter(f);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_pid_seccomp_cache_arch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2364-2375",
    "snippet": "static void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,\n\t\t\t\t\tconst void *bitmap, size_t bitmap_size)\n{\n\tint nr;\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\tbool cached = test_bit(nr, bitmap);\n\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";\n\n\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %d %s\\n\"",
            "name",
            "nr",
            "status"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "nr",
            "bitmap"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,\n\t\t\t\t\tconst void *bitmap, size_t bitmap_size)\n{\n\tint nr;\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\tbool cached = test_bit(nr, bitmap);\n\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";\n\n\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);\n\t}\n}"
  },
  {
    "function_name": "seccomp_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2345-2356",
    "snippet": "static int __init seccomp_sysctl_init(void)\n{\n\tstruct ctl_table_header *hdr;\n\n\thdr = register_sysctl_paths(seccomp_sysctl_path, seccomp_sysctl_table);\n\tif (!hdr)\n\t\tpr_warn(\"sysctl registration failed\\n\");\n\telse\n\t\tkmemleak_not_leak(hdr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "hdr"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"sysctl registration failed\\n\""
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "seccomp_sysctl_path",
            "seccomp_sysctl_table"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __init seccomp_sysctl_init(void)\n{\n\tstruct ctl_table_header *hdr;\n\n\thdr = register_sysctl_paths(seccomp_sysctl_path, seccomp_sysctl_table);\n\tif (!hdr)\n\t\tpr_warn(\"sysctl registration failed\\n\");\n\telse\n\t\tkmemleak_not_leak(hdr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_actions_logged_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2304-2321",
    "snippet": "static int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret;\n\n\tif (write) {\n\t\tu32 actions_logged = 0;\n\t\tu32 old_actions_logged = seccomp_actions_logged;\n\n\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,\n\t\t\t\t\t   &actions_logged);\n\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);\n\t} else\n\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_actions_logged",
          "args": [
            "ro_table",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "read_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2225-2241",
          "snippet": "static int read_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int read_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_actions_logged",
          "args": [
            "actions_logged",
            "old_actions_logged",
            "ret"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "audit_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2272-2302",
          "snippet": "static void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_actions_logged",
          "args": [
            "ro_table",
            "buffer",
            "lenp",
            "ppos",
            "&actions_logged"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "write_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2243-2270",
          "snippet": "static int write_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_ALLOW\t\t(1 << 6)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_ALLOW\t\t(1 << 6)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int write_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret;\n\n\tif (write) {\n\t\tu32 actions_logged = 0;\n\t\tu32 old_actions_logged = seccomp_actions_logged;\n\n\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,\n\t\t\t\t\t   &actions_logged);\n\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);\n\t} else\n\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_actions_logged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2272-2302",
    "snippet": "static void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_seccomp_actions_logged",
          "args": [
            "new",
            "old",
            "!ret"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "audit_seccomp_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2972-2989",
          "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_names_from_actions_logged",
          "args": [
            "old_names",
            "sizeof(old_names)",
            "old_actions_logged",
            "\",\""
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_names_from_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2159-2191",
          "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "old_names",
            "0",
            "sizeof(old_names)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}"
  },
  {
    "function_name": "write_actions_logged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2243-2270",
    "snippet": "static int write_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define SECCOMP_LOG_ALLOW\t\t(1 << 6)"
    ],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_actions_logged_from_names",
          "args": [
            "actions_logged",
            "table.data"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_actions_logged_from_names",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2208-2223",
          "snippet": "static bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&table",
            "1",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1543-1547",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_ALLOW\t\t(1 << 6)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int write_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_actions_logged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2225-2241",
    "snippet": "static int read_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&table",
            "0",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1543-1547",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_names_from_actions_logged",
          "args": [
            "names",
            "sizeof(names)",
            "seccomp_actions_logged",
            "\" \""
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_names_from_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2159-2191",
          "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names)"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic int read_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "seccomp_actions_logged_from_names",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2208-2223",
    "snippet": "static bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_action_logged_from_name",
          "args": [
            "&action_logged",
            "name"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_action_logged_from_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2193-2206",
          "snippet": "static bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&names",
            "\" \""
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_action_logged_from_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2193-2206",
    "snippet": "static bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cur->name",
            "name"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "seccomp_names_from_actions_logged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2159-2191",
    "snippet": "static bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "names",
            "cur->name",
            "size"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "names",
            "sep",
            "size"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_get_metadata",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2084-2117",
    "snippet": "long seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data",
            "&kmd",
            "size"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filter"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filter"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nth_filter",
          "args": [
            "task",
            "kmd.filter_off"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "get_nth_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2000-2044",
          "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kmd.filter_off",
            "data",
            "sizeof(kmd.filter_off)"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "size",
            "sizeof(kmd)"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_get_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2046-2082",
    "snippet": "long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data",
            "fprog->filter",
            "bpf_classic_proglen(fprog)"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_classic_proglen",
          "args": [
            "fprog"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filter"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filter"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nth_filter",
          "args": [
            "task",
            "filter_off"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "get_nth_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "2000-2044",
          "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t/* This must be a new non-cBPF filter, since we save\n\t\t * every cBPF filter's orig_prog above when\n\t\t * CONFIG_CHECKPOINT_RESTORE is enabled.\n\t\t */\n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_nth_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "2000-2044",
    "snippet": "static struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "orig"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "909-912",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "count != 1 || !filter"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t/*\n\t * Note: this is only correct because the caller should be the (ptrace)\n\t * tracer of the task, otherwise lock_task_sighand is needed.\n\t */\n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}"
  },
  {
    "function_name": "prctl_set_seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1972-1997",
    "snippet": "long prctl_set_seccomp(unsigned long seccomp_mode, void __user *filter)\n{\n\tunsigned int op;\n\tvoid __user *uargs;\n\n\tswitch (seccomp_mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\top = SECCOMP_SET_MODE_STRICT;\n\t\t/*\n\t\t * Setting strict mode through prctl always ignored filter,\n\t\t * so make sure it is always NULL here to pass the internal\n\t\t * check in do_seccomp().\n\t\t */\n\t\tuargs = NULL;\n\t\tbreak;\n\tcase SECCOMP_MODE_FILTER:\n\t\top = SECCOMP_SET_MODE_FILTER;\n\t\tuargs = filter;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* prctl interface doesn't have flags, so they are always zero. */\n\treturn do_seccomp(op, 0, uargs);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_seccomp",
          "args": [
            "op",
            "0",
            "uargs"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "do_seccomp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1934-1957",
          "snippet": "static long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       void __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tcase SECCOMP_GET_NOTIF_SIZES:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_notif_sizes(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       void __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tcase SECCOMP_GET_NOTIF_SIZES:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_notif_sizes(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong prctl_set_seccomp(unsigned long seccomp_mode, void __user *filter)\n{\n\tunsigned int op;\n\tvoid __user *uargs;\n\n\tswitch (seccomp_mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\top = SECCOMP_SET_MODE_STRICT;\n\t\t/*\n\t\t * Setting strict mode through prctl always ignored filter,\n\t\t * so make sure it is always NULL here to pass the internal\n\t\t * check in do_seccomp().\n\t\t */\n\t\tuargs = NULL;\n\t\tbreak;\n\tcase SECCOMP_MODE_FILTER:\n\t\top = SECCOMP_SET_MODE_FILTER;\n\t\tuargs = filter;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* prctl interface doesn't have flags, so they are always zero. */\n\treturn do_seccomp(op, 0, uargs);\n}"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1934-1957",
    "snippet": "static long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       void __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tcase SECCOMP_GET_NOTIF_SIZES:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_notif_sizes(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_get_notif_sizes",
          "args": [
            "uargs"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_get_notif_sizes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1919-1931",
          "snippet": "static long seccomp_get_notif_sizes(void __user *usizes)\n{\n\tstruct seccomp_notif_sizes sizes = {\n\t\t.seccomp_notif = sizeof(struct seccomp_notif),\n\t\t.seccomp_notif_resp = sizeof(struct seccomp_notif_resp),\n\t\t.seccomp_data = sizeof(struct seccomp_data),\n\t};\n\n\tif (copy_to_user(usizes, &sizes, sizeof(sizes)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_notif_sizes(void __user *usizes)\n{\n\tstruct seccomp_notif_sizes sizes = {\n\t\t.seccomp_notif = sizeof(struct seccomp_notif),\n\t\t.seccomp_notif_resp = sizeof(struct seccomp_notif_resp),\n\t\t.seccomp_data = sizeof(struct seccomp_data),\n\t};\n\n\tif (copy_to_user(usizes, &sizes, sizeof(sizes)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_get_action_avail",
          "args": [
            "uargs"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_get_action_avail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1895-1917",
          "snippet": "static long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_USER_NOTIF:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_USER_NOTIF:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_set_mode_filter",
          "args": [
            "flags",
            "uargs"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_set_mode_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1888-1892",
          "snippet": "static inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_set_mode_strict",
          "args": [],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_set_mode_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1329-1349",
          "snippet": "static long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       void __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tcase SECCOMP_GET_NOTIF_SIZES:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_notif_sizes(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "seccomp_get_notif_sizes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1919-1931",
    "snippet": "static long seccomp_get_notif_sizes(void __user *usizes)\n{\n\tstruct seccomp_notif_sizes sizes = {\n\t\t.seccomp_notif = sizeof(struct seccomp_notif),\n\t\t.seccomp_notif_resp = sizeof(struct seccomp_notif_resp),\n\t\t.seccomp_data = sizeof(struct seccomp_data),\n\t};\n\n\tif (copy_to_user(usizes, &sizes, sizeof(sizes)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "usizes",
            "&sizes",
            "sizeof(sizes)"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_notif_sizes(void __user *usizes)\n{\n\tstruct seccomp_notif_sizes sizes = {\n\t\t.seccomp_notif = sizeof(struct seccomp_notif),\n\t\t.seccomp_notif_resp = sizeof(struct seccomp_notif_resp),\n\t\t.seccomp_data = sizeof(struct seccomp_data),\n\t};\n\n\tif (copy_to_user(usizes, &sizes, sizeof(sizes)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_get_action_avail",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1895-1917",
    "snippet": "static long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_USER_NOTIF:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&action",
            "uaction",
            "sizeof(action)"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_USER_NOTIF:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_set_mode_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1888-1892",
    "snippet": "static inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "seccomp_set_mode_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1797-1886",
    "snippet": "static long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t    const char __user *filter)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;\n\tstruct seccomp_filter *prepared = NULL;\n\tlong ret = -EINVAL;\n\tint listener = -1;\n\tstruct file *listener_f = NULL;\n\n\t/* Validate flags. */\n\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/*\n\t * In the successful case, NEW_LISTENER returns the new listener fd.\n\t * But in the failure case, TSYNC returns the thread that died. If you\n\t * combine these two flags, there's no way to tell whether something\n\t * succeeded or failed. So, let's disallow this combination if the user\n\t * has not explicitly requested no errors from TSYNC.\n\t */\n\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&\n\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&\n\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))\n\t\treturn -EINVAL;\n\n\t/* Prepare the new filter before holding any locks. */\n\tprepared = seccomp_prepare_user_filter(filter);\n\tif (IS_ERR(prepared))\n\t\treturn PTR_ERR(prepared);\n\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tlistener = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (listener < 0) {\n\t\t\tret = listener;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tlistener_f = init_listener(prepared);\n\t\tif (IS_ERR(listener_f)) {\n\t\t\tput_unused_fd(listener);\n\t\t\tret = PTR_ERR(listener_f);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we cannot change seccomp or nnp state via TSYNC\n\t * while another thread is in the middle of calling exec.\n\t */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&\n\t    mutex_lock_killable(&current->signal->cred_guard_mutex))\n\t\tgoto out_put_fd;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n\tif (has_duplicate_listener(prepared)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = seccomp_attach_filter(flags, prepared);\n\tif (ret)\n\t\tgoto out;\n\t/* Do not free the successfully attached filter. */\n\tprepared = NULL;\n\n\tseccomp_assign_mode(current, seccomp_mode, flags);\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_put_fd:\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tif (ret) {\n\t\t\tlistener_f->private_data = NULL;\n\t\t\tfput(listener_f);\n\t\t\tput_unused_fd(listener);\n\t\t\tseccomp_notify_detach(prepared);\n\t\t} else {\n\t\t\tfd_install(listener, listener_f);\n\t\t\tret = listener;\n\t\t}\n\t}\nout_free:\n\tseccomp_filter_free(prepared);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_filter_free",
          "args": [
            "prepared"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "512-518",
          "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "listener",
            "listener_f"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_notify_detach",
          "args": [
            "prepared"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1358-1389",
          "snippet": "static void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "listener"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "listener_f"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "current",
            "seccomp_mode",
            "flags"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "438-454",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_attach_filter",
          "args": [
            "flags",
            "prepared"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_attach_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "861-907",
          "snippet": "static long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret) {\n\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)\n\t\t\t\treturn -ESRCH;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tseccomp_cache_prepare(filter);\n\tcurrent->seccomp.filter = filter;\n\tatomic_inc(&current->seccomp.filter_count);\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))\n\nstatic long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret) {\n\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)\n\t\t\t\treturn -ESRCH;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tseccomp_cache_prepare(filter);\n\tcurrent->seccomp.filter = filter;\n\tatomic_inc(&current->seccomp.filter_count);\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_duplicate_listener",
          "args": [
            "prepared"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "has_duplicate_listener",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1767-1782",
          "snippet": "static bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_may_assign_mode",
          "args": [
            "seccomp_mode"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_may_assign_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "426-434",
          "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_killable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "574-577",
          "snippet": "int __sched mutex_lock_killable(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_killable(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_KILLABLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "listener_f"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "listener"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "listener_f"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_listener",
          "args": [
            "prepared"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "init_listener",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1731-1757",
          "snippet": "static struct file *init_listener(struct seccomp_filter *filter)\n{\n\tstruct file *ret;\n\n\tret = ERR_PTR(-ENOMEM);\n\tfilter->notif = kzalloc(sizeof(*(filter->notif)), GFP_KERNEL);\n\tif (!filter->notif)\n\t\tgoto out;\n\n\tsema_init(&filter->notif->request, 0);\n\tfilter->notif->next_id = get_random_u64();\n\tINIT_LIST_HEAD(&filter->notif->notifications);\n\n\tret = anon_inode_getfile(\"seccomp notify\", &seccomp_notify_ops,\n\t\t\t\t filter, O_RDWR);\n\tif (IS_ERR(ret))\n\t\tgoto out_notif;\n\n\t/* The file has a reference to it now */\n\t__get_seccomp_filter(filter);\n\nout_notif:\n\tif (IS_ERR(ret))\n\t\tseccomp_notify_free(filter);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct file *init_listener(struct seccomp_filter *filter)\n{\n\tstruct file *ret;\n\n\tret = ERR_PTR(-ENOMEM);\n\tfilter->notif = kzalloc(sizeof(*(filter->notif)), GFP_KERNEL);\n\tif (!filter->notif)\n\t\tgoto out;\n\n\tsema_init(&filter->notif->request, 0);\n\tfilter->notif->next_id = get_random_u64();\n\tINIT_LIST_HEAD(&filter->notif->notifications);\n\n\tret = anon_inode_getfile(\"seccomp notify\", &seccomp_notify_ops,\n\t\t\t\t filter, O_RDWR);\n\tif (IS_ERR(ret))\n\t\tgoto out_notif;\n\n\t/* The file has a reference to it now */\n\t__get_seccomp_filter(filter);\n\nout_notif:\n\tif (IS_ERR(ret))\n\t\tseccomp_notify_free(filter);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "O_CLOEXEC"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prepared"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prepared"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_prepare_user_filter",
          "args": [
            "filter"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_prepare_user_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "685-705",
          "snippet": "static struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t    const char __user *filter)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;\n\tstruct seccomp_filter *prepared = NULL;\n\tlong ret = -EINVAL;\n\tint listener = -1;\n\tstruct file *listener_f = NULL;\n\n\t/* Validate flags. */\n\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/*\n\t * In the successful case, NEW_LISTENER returns the new listener fd.\n\t * But in the failure case, TSYNC returns the thread that died. If you\n\t * combine these two flags, there's no way to tell whether something\n\t * succeeded or failed. So, let's disallow this combination if the user\n\t * has not explicitly requested no errors from TSYNC.\n\t */\n\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&\n\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&\n\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))\n\t\treturn -EINVAL;\n\n\t/* Prepare the new filter before holding any locks. */\n\tprepared = seccomp_prepare_user_filter(filter);\n\tif (IS_ERR(prepared))\n\t\treturn PTR_ERR(prepared);\n\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tlistener = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (listener < 0) {\n\t\t\tret = listener;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tlistener_f = init_listener(prepared);\n\t\tif (IS_ERR(listener_f)) {\n\t\t\tput_unused_fd(listener);\n\t\t\tret = PTR_ERR(listener_f);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure we cannot change seccomp or nnp state via TSYNC\n\t * while another thread is in the middle of calling exec.\n\t */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&\n\t    mutex_lock_killable(&current->signal->cred_guard_mutex))\n\t\tgoto out_put_fd;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n\tif (has_duplicate_listener(prepared)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = seccomp_attach_filter(flags, prepared);\n\tif (ret)\n\t\tgoto out;\n\t/* Do not free the successfully attached filter. */\n\tprepared = NULL;\n\n\tseccomp_assign_mode(current, seccomp_mode, flags);\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_put_fd:\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tif (ret) {\n\t\t\tlistener_f->private_data = NULL;\n\t\t\tfput(listener_f);\n\t\t\tput_unused_fd(listener);\n\t\t\tseccomp_notify_detach(prepared);\n\t\t} else {\n\t\t\tfd_install(listener, listener_f);\n\t\t\tret = listener;\n\t\t}\n\t}\nout_free:\n\tseccomp_filter_free(prepared);\n\treturn ret;\n}"
  },
  {
    "function_name": "has_duplicate_listener",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1767-1782",
    "snippet": "static bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "init_listener",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1731-1757",
    "snippet": "static struct file *init_listener(struct seccomp_filter *filter)\n{\n\tstruct file *ret;\n\n\tret = ERR_PTR(-ENOMEM);\n\tfilter->notif = kzalloc(sizeof(*(filter->notif)), GFP_KERNEL);\n\tif (!filter->notif)\n\t\tgoto out;\n\n\tsema_init(&filter->notif->request, 0);\n\tfilter->notif->next_id = get_random_u64();\n\tINIT_LIST_HEAD(&filter->notif->notifications);\n\n\tret = anon_inode_getfile(\"seccomp notify\", &seccomp_notify_ops,\n\t\t\t\t filter, O_RDWR);\n\tif (IS_ERR(ret))\n\t\tgoto out_notif;\n\n\t/* The file has a reference to it now */\n\t__get_seccomp_filter(filter);\n\nout_notif:\n\tif (IS_ERR(ret))\n\t\tseccomp_notify_free(filter);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_notify_free",
          "args": [
            "filter"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1352-1356",
          "snippet": "static void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "909-912",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "\"seccomp notify\"",
            "&seccomp_notify_ops",
            "filter",
            "O_RDWR"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&filter->notif->notifications"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_u64",
          "args": [],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&filter->notif->request",
            "0"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*(filter->notif))",
            "GFP_KERNEL"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct file *init_listener(struct seccomp_filter *filter)\n{\n\tstruct file *ret;\n\n\tret = ERR_PTR(-ENOMEM);\n\tfilter->notif = kzalloc(sizeof(*(filter->notif)), GFP_KERNEL);\n\tif (!filter->notif)\n\t\tgoto out;\n\n\tsema_init(&filter->notif->request, 0);\n\tfilter->notif->next_id = get_random_u64();\n\tINIT_LIST_HEAD(&filter->notif->notifications);\n\n\tret = anon_inode_getfile(\"seccomp notify\", &seccomp_notify_ops,\n\t\t\t\t filter, O_RDWR);\n\tif (IS_ERR(ret))\n\t\tgoto out_notif;\n\n\t/* The file has a reference to it now */\n\t__get_seccomp_filter(filter);\n\nout_notif:\n\tif (IS_ERR(ret))\n\t\tseccomp_notify_free(filter);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_notify_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1695-1722",
    "snippet": "static __poll_t seccomp_notify_poll(struct file *file,\n\t\t\t\t    struct poll_table_struct *poll_tab)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\t__poll_t ret = 0;\n\tstruct seccomp_knotif *cur;\n\n\tpoll_wait(file, &filter->wqh, poll_tab);\n\n\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)\n\t\treturn EPOLLERR;\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT)\n\t\t\tret |= EPOLLIN | EPOLLRDNORM;\n\t\tif (cur->state == SECCOMP_NOTIFY_SENT)\n\t\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (refcount_read(&filter->users) == 0)\n\t\tret |= EPOLLHUP;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&filter->users"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&filter->notif->notifications",
            "list"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "568-571",
          "snippet": "int __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&filter->wqh",
            "poll_tab"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic __poll_t seccomp_notify_poll(struct file *file,\n\t\t\t\t    struct poll_table_struct *poll_tab)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\t__poll_t ret = 0;\n\tstruct seccomp_knotif *cur;\n\n\tpoll_wait(file, &filter->wqh, poll_tab);\n\n\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)\n\t\treturn EPOLLERR;\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT)\n\t\t\tret |= EPOLLIN | EPOLLRDNORM;\n\t\tif (cur->state == SECCOMP_NOTIFY_SENT)\n\t\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (refcount_read(&filter->users) == 0)\n\t\tret |= EPOLLHUP;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_notify_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1668-1693",
    "snippet": "static long seccomp_notify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\tvoid __user *buf = (void __user *)arg;\n\n\t/* Fixed-size ioctls */\n\tswitch (cmd) {\n\tcase SECCOMP_IOCTL_NOTIF_RECV:\n\t\treturn seccomp_notify_recv(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_SEND:\n\t\treturn seccomp_notify_send(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:\n\t\treturn seccomp_notify_id_valid(filter, buf);\n\t}\n\n\t/* Extensible Argument ioctls */\n#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))\n\tswitch (EA_IOCTL(cmd)) {\n\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):\n\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR\tSECCOMP_IOR(2, __u64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_notify_addfd",
          "args": [
            "filter",
            "buf",
            "_IOC_SIZE(cmd)"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_addfd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1554-1666",
          "snippet": "static long seccomp_notify_addfd(struct seccomp_filter *filter,\n\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,\n\t\t\t\t unsigned int size)\n{\n\tstruct seccomp_notif_addfd addfd;\n\tstruct seccomp_knotif *knotif;\n\tstruct seccomp_kaddfd kaddfd;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);\n\n\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addfd.newfd_flags & ~O_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))\n\t\treturn -EINVAL;\n\n\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))\n\t\treturn -EINVAL;\n\n\tkaddfd.file = fget(addfd.srcfd);\n\tif (!kaddfd.file)\n\t\treturn -EBADF;\n\n\tkaddfd.ioctl_flags = addfd.flags;\n\tkaddfd.flags = addfd.newfd_flags;\n\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;\n\tkaddfd.fd = addfd.newfd;\n\tinit_completion(&kaddfd.completion);\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tknotif = find_notification(filter, addfd.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We do not want to allow for FD injection to occur before the\n\t * notification has been picked up by a userspace handler, or after\n\t * the notification has been replied to.\n\t */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/*\n\t\t * Disallow queuing an atomic addfd + send reply while there are\n\t\t * some addfd requests still to process.\n\t\t *\n\t\t * There is no clear reason to support it and allows us to keep\n\t\t * the loop on the other side straight-forward.\n\t\t */\n\t\tif (!list_empty(&knotif->addfd)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Allow exactly only one reply */\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t}\n\n\tlist_add(&kaddfd.list, &knotif->addfd);\n\tcomplete(&knotif->ready);\n\tmutex_unlock(&filter->notify_lock);\n\n\t/* Now we wait for it to be processed or be interrupted */\n\tret = wait_for_completion_interruptible(&kaddfd.completion);\n\tif (ret == 0) {\n\t\t/*\n\t\t * We had a successful completion. The other side has already\n\t\t * removed us from the addfd queue, and\n\t\t * wait_for_completion_interruptible has a memory barrier upon\n\t\t * success that lets us read this value directly without\n\t\t * locking.\n\t\t */\n\t\tret = kaddfd.ret;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&filter->notify_lock);\n\t/*\n\t * Even though we were woken up by a signal and not a successful\n\t * completion, a completion may have happened in the mean time.\n\t *\n\t * We need to check again if the addfd request has been handled,\n\t * and if not, we will remove it from the queue.\n\t */\n\tif (list_empty(&kaddfd.list))\n\t\tret = kaddfd.ret;\n\telse\n\t\tlist_del(&kaddfd.list);\n\nout_unlock:\n\tmutex_unlock(&filter->notify_lock);\nout:\n\tfput(kaddfd.file);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_addfd(struct seccomp_filter *filter,\n\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,\n\t\t\t\t unsigned int size)\n{\n\tstruct seccomp_notif_addfd addfd;\n\tstruct seccomp_knotif *knotif;\n\tstruct seccomp_kaddfd kaddfd;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);\n\n\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addfd.newfd_flags & ~O_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))\n\t\treturn -EINVAL;\n\n\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))\n\t\treturn -EINVAL;\n\n\tkaddfd.file = fget(addfd.srcfd);\n\tif (!kaddfd.file)\n\t\treturn -EBADF;\n\n\tkaddfd.ioctl_flags = addfd.flags;\n\tkaddfd.flags = addfd.newfd_flags;\n\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;\n\tkaddfd.fd = addfd.newfd;\n\tinit_completion(&kaddfd.completion);\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tknotif = find_notification(filter, addfd.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We do not want to allow for FD injection to occur before the\n\t * notification has been picked up by a userspace handler, or after\n\t * the notification has been replied to.\n\t */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/*\n\t\t * Disallow queuing an atomic addfd + send reply while there are\n\t\t * some addfd requests still to process.\n\t\t *\n\t\t * There is no clear reason to support it and allows us to keep\n\t\t * the loop on the other side straight-forward.\n\t\t */\n\t\tif (!list_empty(&knotif->addfd)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Allow exactly only one reply */\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t}\n\n\tlist_add(&kaddfd.list, &knotif->addfd);\n\tcomplete(&knotif->ready);\n\tmutex_unlock(&filter->notify_lock);\n\n\t/* Now we wait for it to be processed or be interrupted */\n\tret = wait_for_completion_interruptible(&kaddfd.completion);\n\tif (ret == 0) {\n\t\t/*\n\t\t * We had a successful completion. The other side has already\n\t\t * removed us from the addfd queue, and\n\t\t * wait_for_completion_interruptible has a memory barrier upon\n\t\t * success that lets us read this value directly without\n\t\t * locking.\n\t\t */\n\t\tret = kaddfd.ret;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&filter->notify_lock);\n\t/*\n\t * Even though we were woken up by a signal and not a successful\n\t * completion, a completion may have happened in the mean time.\n\t *\n\t * We need to check again if the addfd request has been handled,\n\t * and if not, we will remove it from the queue.\n\t */\n\tif (list_empty(&kaddfd.list))\n\t\tret = kaddfd.ret;\n\telse\n\t\tlist_del(&kaddfd.list);\n\nout_unlock:\n\tmutex_unlock(&filter->notify_lock);\nout:\n\tfput(kaddfd.file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_SIZE",
          "args": [
            "cmd"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EA_IOCTL",
          "args": [
            "SECCOMP_IOCTL_NOTIF_ADDFD"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EA_IOCTL",
          "args": [
            "cmd"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_notify_id_valid",
          "args": [
            "filter",
            "buf"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_id_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1530-1552",
          "snippet": "static long seccomp_notify_id_valid(struct seccomp_filter *filter,\n\t\t\t\t    void __user *buf)\n{\n\tstruct seccomp_knotif *knotif;\n\tu64 id;\n\tlong ret;\n\n\tif (copy_from_user(&id, buf, sizeof(id)))\n\t\treturn -EFAULT;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, id);\n\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)\n\t\tret = 0;\n\telse\n\t\tret = -ENOENT;\n\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_id_valid(struct seccomp_filter *filter,\n\t\t\t\t    void __user *buf)\n{\n\tstruct seccomp_knotif *knotif;\n\tu64 id;\n\tlong ret;\n\n\tif (copy_from_user(&id, buf, sizeof(id)))\n\t\treturn -EFAULT;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, id);\n\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)\n\t\tret = 0;\n\telse\n\t\tret = -ENOENT;\n\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_notify_send",
          "args": [
            "filter",
            "buf"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_send",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1486-1528",
          "snippet": "static long seccomp_notify_send(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_knotif *knotif;\n\tlong ret;\n\n\tif (copy_from_user(&resp, buf, sizeof(resp)))\n\t\treturn -EFAULT;\n\n\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn -EINVAL;\n\n\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&\n\t    (resp.error || resp.val))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, resp.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Allow exactly one reply. */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\tknotif->error = resp.error;\n\tknotif->val = resp.val;\n\tknotif->flags = resp.flags;\n\tcomplete(&knotif->ready);\nout:\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_send(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_knotif *knotif;\n\tlong ret;\n\n\tif (copy_from_user(&resp, buf, sizeof(resp)))\n\t\treturn -EFAULT;\n\n\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn -EINVAL;\n\n\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&\n\t    (resp.error || resp.val))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, resp.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Allow exactly one reply. */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\tknotif->error = resp.error;\n\tknotif->val = resp.val;\n\tknotif->flags = resp.flags;\n\tcomplete(&knotif->ready);\nout:\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_notify_recv",
          "args": [
            "filter",
            "buf"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_recv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1417-1484",
          "snippet": "static long seccomp_notify_recv(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_knotif *knotif = NULL, *cur;\n\tstruct seccomp_notif unotif;\n\tssize_t ret;\n\n\t/* Verify that we're not given garbage to keep struct extensible. */\n\tret = check_zeroed_user(buf, sizeof(unotif));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tmemset(&unotif, 0, sizeof(unotif));\n\n\tret = down_interruptible(&filter->notif->request);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&filter->notify_lock);\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {\n\t\t\tknotif = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we didn't find a notification, it could be that the task was\n\t * interrupted by a fatal signal between the time we were woken and\n\t * when we were able to acquire the rw lock.\n\t */\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tunotif.id = knotif->id;\n\tunotif.pid = task_pid_vnr(knotif->task);\n\tunotif.data = *(knotif->data);\n\n\tknotif->state = SECCOMP_NOTIFY_SENT;\n\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);\n\tret = 0;\nout:\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {\n\t\tret = -EFAULT;\n\n\t\t/*\n\t\t * Userspace screwed up. To make sure that we keep this\n\t\t * notification alive, let's reset it back to INIT. It\n\t\t * may have died when we released the lock, so we need to make\n\t\t * sure it's still around.\n\t\t */\n\t\tmutex_lock(&filter->notify_lock);\n\t\tknotif = find_notification(filter, unotif.id);\n\t\tif (knotif) {\n\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;\n\t\t\tup(&filter->notif->request);\n\t\t}\n\t\tmutex_unlock(&filter->notify_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_recv(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_knotif *knotif = NULL, *cur;\n\tstruct seccomp_notif unotif;\n\tssize_t ret;\n\n\t/* Verify that we're not given garbage to keep struct extensible. */\n\tret = check_zeroed_user(buf, sizeof(unotif));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tmemset(&unotif, 0, sizeof(unotif));\n\n\tret = down_interruptible(&filter->notif->request);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&filter->notify_lock);\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {\n\t\t\tknotif = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we didn't find a notification, it could be that the task was\n\t * interrupted by a fatal signal between the time we were woken and\n\t * when we were able to acquire the rw lock.\n\t */\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tunotif.id = knotif->id;\n\tunotif.pid = task_pid_vnr(knotif->task);\n\tunotif.data = *(knotif->data);\n\n\tknotif->state = SECCOMP_NOTIFY_SENT;\n\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);\n\tret = 0;\nout:\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {\n\t\tret = -EFAULT;\n\n\t\t/*\n\t\t * Userspace screwed up. To make sure that we keep this\n\t\t * notification alive, let's reset it back to INIT. It\n\t\t * may have died when we released the lock, so we need to make\n\t\t * sure it's still around.\n\t\t */\n\t\tmutex_lock(&filter->notify_lock);\n\t\tknotif = find_notification(filter, unotif.id);\n\t\tif (knotif) {\n\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;\n\t\t\tup(&filter->notif->request);\n\t\t}\n\t\tmutex_unlock(&filter->notify_lock);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR\tSECCOMP_IOR(2, __u64)\n\nstatic long seccomp_notify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\tvoid __user *buf = (void __user *)arg;\n\n\t/* Fixed-size ioctls */\n\tswitch (cmd) {\n\tcase SECCOMP_IOCTL_NOTIF_RECV:\n\t\treturn seccomp_notify_recv(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_SEND:\n\t\treturn seccomp_notify_send(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:\n\t\treturn seccomp_notify_id_valid(filter, buf);\n\t}\n\n\t/* Extensible Argument ioctls */\n#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))\n\tswitch (EA_IOCTL(cmd)) {\n\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):\n\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "seccomp_notify_addfd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1554-1666",
    "snippet": "static long seccomp_notify_addfd(struct seccomp_filter *filter,\n\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,\n\t\t\t\t unsigned int size)\n{\n\tstruct seccomp_notif_addfd addfd;\n\tstruct seccomp_knotif *knotif;\n\tstruct seccomp_kaddfd kaddfd;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);\n\n\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addfd.newfd_flags & ~O_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))\n\t\treturn -EINVAL;\n\n\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))\n\t\treturn -EINVAL;\n\n\tkaddfd.file = fget(addfd.srcfd);\n\tif (!kaddfd.file)\n\t\treturn -EBADF;\n\n\tkaddfd.ioctl_flags = addfd.flags;\n\tkaddfd.flags = addfd.newfd_flags;\n\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;\n\tkaddfd.fd = addfd.newfd;\n\tinit_completion(&kaddfd.completion);\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tknotif = find_notification(filter, addfd.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We do not want to allow for FD injection to occur before the\n\t * notification has been picked up by a userspace handler, or after\n\t * the notification has been replied to.\n\t */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/*\n\t\t * Disallow queuing an atomic addfd + send reply while there are\n\t\t * some addfd requests still to process.\n\t\t *\n\t\t * There is no clear reason to support it and allows us to keep\n\t\t * the loop on the other side straight-forward.\n\t\t */\n\t\tif (!list_empty(&knotif->addfd)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Allow exactly only one reply */\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t}\n\n\tlist_add(&kaddfd.list, &knotif->addfd);\n\tcomplete(&knotif->ready);\n\tmutex_unlock(&filter->notify_lock);\n\n\t/* Now we wait for it to be processed or be interrupted */\n\tret = wait_for_completion_interruptible(&kaddfd.completion);\n\tif (ret == 0) {\n\t\t/*\n\t\t * We had a successful completion. The other side has already\n\t\t * removed us from the addfd queue, and\n\t\t * wait_for_completion_interruptible has a memory barrier upon\n\t\t * success that lets us read this value directly without\n\t\t * locking.\n\t\t */\n\t\tret = kaddfd.ret;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&filter->notify_lock);\n\t/*\n\t * Even though we were woken up by a signal and not a successful\n\t * completion, a completion may have happened in the mean time.\n\t *\n\t * We need to check again if the addfd request has been handled,\n\t * and if not, we will remove it from the queue.\n\t */\n\tif (list_empty(&kaddfd.list))\n\t\tret = kaddfd.ret;\n\telse\n\t\tlist_del(&kaddfd.list);\n\nout_unlock:\n\tmutex_unlock(&filter->notify_lock);\nout:\n\tfput(kaddfd.file);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "kaddfd.file"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&kaddfd.list"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kaddfd.list"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&kaddfd.completion"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "204-210",
          "snippet": "int __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_INTERRUPTIBLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_INTERRUPTIBLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&knotif->ready"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&kaddfd.list",
            "&knotif->addfd"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_notification",
          "args": [
            "filter",
            "addfd.id"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "find_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1401-1414",
          "snippet": "static inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "568-571",
          "snippet": "int __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&kaddfd.completion"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "addfd.srcfd"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_struct_from_user",
          "args": [
            "&addfd",
            "sizeof(addfd)",
            "uaddfd",
            "size"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_addfd(struct seccomp_filter *filter,\n\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,\n\t\t\t\t unsigned int size)\n{\n\tstruct seccomp_notif_addfd addfd;\n\tstruct seccomp_knotif *knotif;\n\tstruct seccomp_kaddfd kaddfd;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);\n\n\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addfd.newfd_flags & ~O_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))\n\t\treturn -EINVAL;\n\n\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))\n\t\treturn -EINVAL;\n\n\tkaddfd.file = fget(addfd.srcfd);\n\tif (!kaddfd.file)\n\t\treturn -EBADF;\n\n\tkaddfd.ioctl_flags = addfd.flags;\n\tkaddfd.flags = addfd.newfd_flags;\n\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;\n\tkaddfd.fd = addfd.newfd;\n\tinit_completion(&kaddfd.completion);\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tknotif = find_notification(filter, addfd.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * We do not want to allow for FD injection to occur before the\n\t * notification has been picked up by a userspace handler, or after\n\t * the notification has been replied to.\n\t */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/*\n\t\t * Disallow queuing an atomic addfd + send reply while there are\n\t\t * some addfd requests still to process.\n\t\t *\n\t\t * There is no clear reason to support it and allows us to keep\n\t\t * the loop on the other side straight-forward.\n\t\t */\n\t\tif (!list_empty(&knotif->addfd)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Allow exactly only one reply */\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t}\n\n\tlist_add(&kaddfd.list, &knotif->addfd);\n\tcomplete(&knotif->ready);\n\tmutex_unlock(&filter->notify_lock);\n\n\t/* Now we wait for it to be processed or be interrupted */\n\tret = wait_for_completion_interruptible(&kaddfd.completion);\n\tif (ret == 0) {\n\t\t/*\n\t\t * We had a successful completion. The other side has already\n\t\t * removed us from the addfd queue, and\n\t\t * wait_for_completion_interruptible has a memory barrier upon\n\t\t * success that lets us read this value directly without\n\t\t * locking.\n\t\t */\n\t\tret = kaddfd.ret;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&filter->notify_lock);\n\t/*\n\t * Even though we were woken up by a signal and not a successful\n\t * completion, a completion may have happened in the mean time.\n\t *\n\t * We need to check again if the addfd request has been handled,\n\t * and if not, we will remove it from the queue.\n\t */\n\tif (list_empty(&kaddfd.list))\n\t\tret = kaddfd.ret;\n\telse\n\t\tlist_del(&kaddfd.list);\n\nout_unlock:\n\tmutex_unlock(&filter->notify_lock);\nout:\n\tfput(kaddfd.file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_notify_id_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1530-1552",
    "snippet": "static long seccomp_notify_id_valid(struct seccomp_filter *filter,\n\t\t\t\t    void __user *buf)\n{\n\tstruct seccomp_knotif *knotif;\n\tu64 id;\n\tlong ret;\n\n\tif (copy_from_user(&id, buf, sizeof(id)))\n\t\treturn -EFAULT;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, id);\n\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)\n\t\tret = 0;\n\telse\n\t\tret = -ENOENT;\n\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_notification",
          "args": [
            "filter",
            "id"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "find_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1401-1414",
          "snippet": "static inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "568-571",
          "snippet": "int __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&id",
            "buf",
            "sizeof(id)"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_id_valid(struct seccomp_filter *filter,\n\t\t\t\t    void __user *buf)\n{\n\tstruct seccomp_knotif *knotif;\n\tu64 id;\n\tlong ret;\n\n\tif (copy_from_user(&id, buf, sizeof(id)))\n\t\treturn -EFAULT;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, id);\n\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)\n\t\tret = 0;\n\telse\n\t\tret = -ENOENT;\n\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_notify_send",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1486-1528",
    "snippet": "static long seccomp_notify_send(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_knotif *knotif;\n\tlong ret;\n\n\tif (copy_from_user(&resp, buf, sizeof(resp)))\n\t\treturn -EFAULT;\n\n\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn -EINVAL;\n\n\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&\n\t    (resp.error || resp.val))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, resp.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Allow exactly one reply. */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\tknotif->error = resp.error;\n\tknotif->val = resp.val;\n\tknotif->flags = resp.flags;\n\tcomplete(&knotif->ready);\nout:\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&knotif->ready"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_notification",
          "args": [
            "filter",
            "resp.id"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "find_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1401-1414",
          "snippet": "static inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "568-571",
          "snippet": "int __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&resp",
            "buf",
            "sizeof(resp)"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_send(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_knotif *knotif;\n\tlong ret;\n\n\tif (copy_from_user(&resp, buf, sizeof(resp)))\n\t\treturn -EFAULT;\n\n\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn -EINVAL;\n\n\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&\n\t    (resp.error || resp.val))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, resp.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Allow exactly one reply. */\n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\tknotif->error = resp.error;\n\tknotif->val = resp.val;\n\tknotif->flags = resp.flags;\n\tcomplete(&knotif->ready);\nout:\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_notify_recv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1417-1484",
    "snippet": "static long seccomp_notify_recv(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_knotif *knotif = NULL, *cur;\n\tstruct seccomp_notif unotif;\n\tssize_t ret;\n\n\t/* Verify that we're not given garbage to keep struct extensible. */\n\tret = check_zeroed_user(buf, sizeof(unotif));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tmemset(&unotif, 0, sizeof(unotif));\n\n\tret = down_interruptible(&filter->notif->request);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&filter->notify_lock);\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {\n\t\t\tknotif = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we didn't find a notification, it could be that the task was\n\t * interrupted by a fatal signal between the time we were woken and\n\t * when we were able to acquire the rw lock.\n\t */\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tunotif.id = knotif->id;\n\tunotif.pid = task_pid_vnr(knotif->task);\n\tunotif.data = *(knotif->data);\n\n\tknotif->state = SECCOMP_NOTIFY_SENT;\n\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);\n\tret = 0;\nout:\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {\n\t\tret = -EFAULT;\n\n\t\t/*\n\t\t * Userspace screwed up. To make sure that we keep this\n\t\t * notification alive, let's reset it back to INIT. It\n\t\t * may have died when we released the lock, so we need to make\n\t\t * sure it's still around.\n\t\t */\n\t\tmutex_lock(&filter->notify_lock);\n\t\tknotif = find_notification(filter, unotif.id);\n\t\tif (knotif) {\n\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;\n\t\t\tup(&filter->notif->request);\n\t\t}\n\t\tmutex_unlock(&filter->notify_lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&filter->notif->request"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "has_duplicate_listener",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1767-1782",
          "snippet": "static bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_notification",
          "args": [
            "filter",
            "unotif.id"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "find_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1401-1414",
          "snippet": "static inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&unotif",
            "sizeof(unotif)"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&filter->wqh",
            "EPOLLOUT | EPOLLWRNORM"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "knotif->task"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&filter->notif->notifications",
            "list"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_interruptible",
          "args": [
            "&filter->notif->request"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "__down_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/semaphore.c",
          "lines": "244-247",
          "snippet": "__sched __down_interruptible(struct semaphore *sem)\n{\n\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n}",
          "includes": [
            "#include <linux/ftrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void __down(struct semaphore *sem);",
            "static noinline int __down_interruptible(struct semaphore *sem);",
            "static noinline int __down_killable(struct semaphore *sem);",
            "static noinline void __up(struct semaphore *sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ftrace.h>\n#include <linux/spinlock.h>\n#include <linux/semaphore.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nstatic noinline void __down(struct semaphore *sem);\nstatic noinline int __down_interruptible(struct semaphore *sem);\nstatic noinline int __down_killable(struct semaphore *sem);\nstatic noinline void __up(struct semaphore *sem);\n\n__sched __down_interruptible(struct semaphore *sem)\n{\n\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&unotif",
            "0",
            "sizeof(unotif)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_zeroed_user",
          "args": [
            "buf",
            "sizeof(unotif)"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_notify_recv(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_knotif *knotif = NULL, *cur;\n\tstruct seccomp_notif unotif;\n\tssize_t ret;\n\n\t/* Verify that we're not given garbage to keep struct extensible. */\n\tret = check_zeroed_user(buf, sizeof(unotif));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tmemset(&unotif, 0, sizeof(unotif));\n\n\tret = down_interruptible(&filter->notif->request);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&filter->notify_lock);\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {\n\t\t\tknotif = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we didn't find a notification, it could be that the task was\n\t * interrupted by a fatal signal between the time we were woken and\n\t * when we were able to acquire the rw lock.\n\t */\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tunotif.id = knotif->id;\n\tunotif.pid = task_pid_vnr(knotif->task);\n\tunotif.data = *(knotif->data);\n\n\tknotif->state = SECCOMP_NOTIFY_SENT;\n\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);\n\tret = 0;\nout:\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {\n\t\tret = -EFAULT;\n\n\t\t/*\n\t\t * Userspace screwed up. To make sure that we keep this\n\t\t * notification alive, let's reset it back to INIT. It\n\t\t * may have died when we released the lock, so we need to make\n\t\t * sure it's still around.\n\t\t */\n\t\tmutex_lock(&filter->notify_lock);\n\t\tknotif = find_notification(filter, unotif.id);\n\t\tif (knotif) {\n\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;\n\t\t\tup(&filter->notif->request);\n\t\t}\n\t\tmutex_unlock(&filter->notify_lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1401-1414",
    "snippet": "static inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&filter->notif->notifications",
            "list"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "seccomp_notify_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1391-1398",
    "snippet": "static int seccomp_notify_release(struct inode *inode, struct file *file)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\n\tseccomp_notify_detach(filter);\n\t__put_seccomp_filter(filter);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "filter"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_notify_detach",
          "args": [
            "filter"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1358-1389",
          "snippet": "static void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int seccomp_notify_release(struct inode *inode, struct file *file)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\n\tseccomp_notify_detach(filter);\n\t__put_seccomp_filter(filter);\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_notify_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1358-1389",
    "snippet": "static void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_notify_free",
          "args": [
            "filter"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_notify_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1352-1356",
          "snippet": "static void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&knotif->ready"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "knotif",
            "&filter->notif->notifications",
            "list"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t/*\n\t * If this file is being closed because e.g. the task who owned it\n\t * died, let's wake everyone up who was waiting on us.\n\t */\n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t/*\n\t\t * We do not need to wake up any pending addfd messages, as\n\t\t * the notifier will do that for us, as this just looks\n\t\t * like a standard reply.\n\t\t */\n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}"
  },
  {
    "function_name": "seccomp_notify_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1352-1356",
    "snippet": "static void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter->notif"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}"
  },
  {
    "function_name": "seccomp_set_mode_strict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1329-1349",
    "snippet": "static long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "current",
            "seccomp_mode",
            "0"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "438-454",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_TSC",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_may_assign_mode",
          "args": [
            "seccomp_mode"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_may_assign_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "426-434",
          "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prctl_get_seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1317-1320",
    "snippet": "long prctl_get_seccomp(void)\n{\n\treturn current->seccomp.mode;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nlong prctl_get_seccomp(void)\n{\n\treturn current->seccomp.mode;\n}"
  },
  {
    "function_name": "__secure_computing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1293-1314",
    "snippet": "int __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, current_pt_regs());\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seccomp_filter",
          "args": [
            "this_syscall",
            "sd",
            "false"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1284-1290",
          "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__secure_computing_strict",
          "args": [
            "this_syscall"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "__secure_computing_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "997-1014",
          "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "current_pt_regs()"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace & PT_SUSPEND_SECCOMP"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nint __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, current_pt_regs());\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);  /* may call do_exit */\n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "__seccomp_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1284-1290",
    "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}"
  },
  {
    "function_name": "__seccomp_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1160-1282",
    "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tu32 filter_ret, action;\n\tstruct seccomp_filter *match = NULL;\n\tint data;\n\tstruct seccomp_data sd_local;\n\n\t/*\n\t * Make sure that any changes to mode from another thread have\n\t * been seen after SYSCALL_WORK_SECCOMP was seen.\n\t */\n\tsmp_rmb();\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\tfilter_ret = seccomp_run_filters(sd, &match);\n\tdata = filter_ret & SECCOMP_RET_DATA;\n\taction = filter_ret & SECCOMP_RET_ACTION_FULL;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ERRNO:\n\t\t/* Set low-order bits as an errno, capped at MAX_ERRNO. */\n\t\tif (data > MAX_ERRNO)\n\t\t\tdata = MAX_ERRNO;\n\t\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t\t -data, 0);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRAP:\n\t\t/* Show the handler the original registers. */\n\t\tsyscall_rollback(current, current_pt_regs());\n\t\t/* Let the filter pass back 16 bits of data. */\n\t\tforce_sig_seccomp(this_syscall, data, false);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRACE:\n\t\t/* We've been put in this state by the ptracer already. */\n\t\tif (recheck_after_trace)\n\t\t\treturn 0;\n\n\t\t/* ENOSYS these calls if there is no tracer attached. */\n\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\n\t\t\tsyscall_set_return_value(current,\n\t\t\t\t\t\t current_pt_regs(),\n\t\t\t\t\t\t -ENOSYS, 0);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Allow the BPF to provide the event message */\n\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);\n\t\t/*\n\t\t * The delivery of a fatal signal during event\n\t\t * notification may silently skip tracer notification,\n\t\t * which could leave us with a potentially unmodified\n\t\t * syscall that the tracer would have liked to have\n\t\t * changed. Since the process is about to die, we just\n\t\t * force the syscall to be skipped and let the signal\n\t\t * kill the process and correctly handle any tracer exit\n\t\t * notifications.\n\t\t */\n\t\tif (fatal_signal_pending(current))\n\t\t\tgoto skip;\n\t\t/* Check if the tracer forced the syscall to be skipped. */\n\t\tthis_syscall = syscall_get_nr(current, current_pt_regs());\n\t\tif (this_syscall < 0)\n\t\t\tgoto skip;\n\n\t\t/*\n\t\t * Recheck the syscall, since it may have changed. This\n\t\t * intentionally uses a NULL struct seccomp_data to force\n\t\t * a reload of all registers. This does not goto skip since\n\t\t * a skip would have already been reported.\n\t\t */\n\t\tif (__seccomp_filter(this_syscall, NULL, true))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tif (seccomp_do_user_notification(this_syscall, match, sd))\n\t\t\tgoto skip;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_LOG:\n\t\tseccomp_log(this_syscall, 0, action, true);\n\t\treturn 0;\n\n\tcase SECCOMP_RET_ALLOW:\n\t\t/*\n\t\t * Note that the \"match\" filter will always be NULL for\n\t\t * this action since SECCOMP_RET_ALLOW is the starting\n\t\t * state in seccomp_run_filters().\n\t\t */\n\t\treturn 0;\n\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tseccomp_log(this_syscall, SIGSYS, action, true);\n\t\t/* Dump core only if this is the last remaining thread. */\n\t\tif (action != SECCOMP_RET_KILL_THREAD ||\n\t\t    (atomic_read(&current->signal->live) == 1)) {\n\t\t\t/* Show the original registers in the dump. */\n\t\t\tsyscall_rollback(current, current_pt_regs());\n\t\t\t/* Trigger a coredump with SIGSYS */\n\t\t\tforce_sig_seccomp(this_syscall, data, true);\n\t\t} else {\n\t\t\tdo_exit(SIGSYS);\n\t\t}\n\t\treturn -1; /* skip the syscall go directly to signal handling */\n\t}\n\n\tunreachable();\n\nskip:\n\tseccomp_log(this_syscall, 0, action, match ? match->log : false);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_log",
          "args": [
            "this_syscall",
            "0",
            "action",
            "match ? match->log : false"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "944-985",
          "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)",
            "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
            "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
            "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
            "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
            "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
            "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreachable",
          "args": [],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGSYS"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sig_seccomp",
          "args": [
            "this_syscall",
            "data",
            "true"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_seccomp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1830-1843",
          "snippet": "int force_sig_seccomp(int syscall, int reason, bool force_coredump)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_SECCOMP;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = reason;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall;\n\treturn force_sig_info_to_task(&info, current,\n\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_seccomp(int syscall, int reason, bool force_coredump)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_SECCOMP;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = reason;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall;\n\treturn force_sig_info_to_task(&info, current,\n\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_rollback",
          "args": [
            "current",
            "current_pt_regs()"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->signal->live"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_do_user_notification",
          "args": [
            "this_syscall",
            "match",
            "sd"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_do_user_notification",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1079-1158",
          "snippet": "static int seccomp_do_user_notification(int this_syscall,\n\t\t\t\t\tstruct seccomp_filter *match,\n\t\t\t\t\tconst struct seccomp_data *sd)\n{\n\tint err;\n\tu32 flags = 0;\n\tlong ret = 0;\n\tstruct seccomp_knotif n = {};\n\tstruct seccomp_kaddfd *addfd, *tmp;\n\n\tmutex_lock(&match->notify_lock);\n\terr = -ENOSYS;\n\tif (!match->notif)\n\t\tgoto out;\n\n\tn.task = current;\n\tn.state = SECCOMP_NOTIFY_INIT;\n\tn.data = sd;\n\tn.id = seccomp_next_notify_id(match);\n\tinit_completion(&n.ready);\n\tlist_add(&n.list, &match->notif->notifications);\n\tINIT_LIST_HEAD(&n.addfd);\n\n\tup(&match->notif->request);\n\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\n\t/*\n\t * This is where we wait for a reply from userspace.\n\t */\n\tdo {\n\t\tmutex_unlock(&match->notify_lock);\n\t\terr = wait_for_completion_interruptible(&n.ready);\n\t\tmutex_lock(&match->notify_lock);\n\t\tif (err != 0)\n\t\t\tgoto interrupted;\n\n\t\taddfd = list_first_entry_or_null(&n.addfd,\n\t\t\t\t\t\t struct seccomp_kaddfd, list);\n\t\t/* Check if we were woken up by a addfd message */\n\t\tif (addfd)\n\t\t\tseccomp_handle_addfd(addfd, &n);\n\n\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);\n\n\tret = n.val;\n\terr = n.error;\n\tflags = n.flags;\n\ninterrupted:\n\t/* If there were any pending addfd calls, clear them out */\n\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {\n\t\t/* The process went away before we got a chance to handle it */\n\t\taddfd->ret = -ESRCH;\n\t\tlist_del_init(&addfd->list);\n\t\tcomplete(&addfd->completion);\n\t}\n\n\t/*\n\t * Note that it's possible the listener died in between the time when\n\t * we were notified of a response (or a signal) and when we were able to\n\t * re-acquire the lock, so only delete from the list if the\n\t * notification actually exists.\n\t *\n\t * Also note that this test is only valid because there's no way to\n\t * *reattach* to a notifier right now. If one is added, we'll need to\n\t * keep track of the notif itself and make sure they match here.\n\t */\n\tif (match->notif)\n\t\tlist_del(&n.list);\nout:\n\tmutex_unlock(&match->notify_lock);\n\n\t/* Userspace requests to continue the syscall. */\n\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn 0;\n\n\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t err, ret);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int seccomp_do_user_notification(int this_syscall,\n\t\t\t\t\tstruct seccomp_filter *match,\n\t\t\t\t\tconst struct seccomp_data *sd)\n{\n\tint err;\n\tu32 flags = 0;\n\tlong ret = 0;\n\tstruct seccomp_knotif n = {};\n\tstruct seccomp_kaddfd *addfd, *tmp;\n\n\tmutex_lock(&match->notify_lock);\n\terr = -ENOSYS;\n\tif (!match->notif)\n\t\tgoto out;\n\n\tn.task = current;\n\tn.state = SECCOMP_NOTIFY_INIT;\n\tn.data = sd;\n\tn.id = seccomp_next_notify_id(match);\n\tinit_completion(&n.ready);\n\tlist_add(&n.list, &match->notif->notifications);\n\tINIT_LIST_HEAD(&n.addfd);\n\n\tup(&match->notif->request);\n\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\n\t/*\n\t * This is where we wait for a reply from userspace.\n\t */\n\tdo {\n\t\tmutex_unlock(&match->notify_lock);\n\t\terr = wait_for_completion_interruptible(&n.ready);\n\t\tmutex_lock(&match->notify_lock);\n\t\tif (err != 0)\n\t\t\tgoto interrupted;\n\n\t\taddfd = list_first_entry_or_null(&n.addfd,\n\t\t\t\t\t\t struct seccomp_kaddfd, list);\n\t\t/* Check if we were woken up by a addfd message */\n\t\tif (addfd)\n\t\t\tseccomp_handle_addfd(addfd, &n);\n\n\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);\n\n\tret = n.val;\n\terr = n.error;\n\tflags = n.flags;\n\ninterrupted:\n\t/* If there were any pending addfd calls, clear them out */\n\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {\n\t\t/* The process went away before we got a chance to handle it */\n\t\taddfd->ret = -ESRCH;\n\t\tlist_del_init(&addfd->list);\n\t\tcomplete(&addfd->completion);\n\t}\n\n\t/*\n\t * Note that it's possible the listener died in between the time when\n\t * we were notified of a response (or a signal) and when we were able to\n\t * re-acquire the lock, so only delete from the list if the\n\t * notification actually exists.\n\t *\n\t * Also note that this test is only valid because there's no way to\n\t * *reattach* to a notifier right now. If one is added, we'll need to\n\t * keep track of the notif itself and make sure they match here.\n\t */\n\tif (match->notif)\n\t\tlist_del(&n.list);\nout:\n\tmutex_unlock(&match->notify_lock);\n\n\t/* Userspace requests to continue the syscall. */\n\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn 0;\n\n\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t err, ret);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seccomp_filter",
          "args": [
            "this_syscall",
            "NULL",
            "true"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1284-1290",
          "snippet": "static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "current",
            "current_pt_regs()"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_SECCOMP",
            "data"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_set_return_value",
          "args": [
            "current",
            "current_pt_regs()",
            "-ENOSYS",
            "0"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event_enabled",
          "args": [
            "current",
            "PTRACE_EVENT_SECCOMP"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_rollback",
          "args": [
            "current",
            "current_pt_regs()"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_set_return_value",
          "args": [
            "current",
            "current_pt_regs()",
            "-data",
            "0"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_run_filters",
          "args": [
            "sd",
            "&match"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_run_filters",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "395-423",
          "snippet": "static u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (seccomp_cache_check_allow(f, sd))\n\t\treturn SECCOMP_RET_ALLOW;\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = bpf_prog_run_pin_on_cpu(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (seccomp_cache_check_allow(f, sd))\n\t\treturn SECCOMP_RET_ALLOW;\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = bpf_prog_run_pin_on_cpu(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_seccomp_data",
          "args": [
            "&sd_local"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "populate_seccomp_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "235-255",
          "snippet": "static void populate_seccomp_data(struct seccomp_data *sd)\n{\n\t/*\n\t * Instead of using current_pt_reg(), we're already doing the work\n\t * to safely fetch \"current\", so just use \"task\" everywhere below.\n\t */\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch(task);\n\tsyscall_get_arguments(task, regs, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\t/*\n\t * Instead of using current_pt_reg(), we're already doing the work\n\t * to safely fetch \"current\", so just use \"task\" everywhere below.\n\t */\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch(task);\n\tsyscall_get_arguments(task, regs, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tu32 filter_ret, action;\n\tstruct seccomp_filter *match = NULL;\n\tint data;\n\tstruct seccomp_data sd_local;\n\n\t/*\n\t * Make sure that any changes to mode from another thread have\n\t * been seen after SYSCALL_WORK_SECCOMP was seen.\n\t */\n\tsmp_rmb();\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\tfilter_ret = seccomp_run_filters(sd, &match);\n\tdata = filter_ret & SECCOMP_RET_DATA;\n\taction = filter_ret & SECCOMP_RET_ACTION_FULL;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ERRNO:\n\t\t/* Set low-order bits as an errno, capped at MAX_ERRNO. */\n\t\tif (data > MAX_ERRNO)\n\t\t\tdata = MAX_ERRNO;\n\t\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t\t -data, 0);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRAP:\n\t\t/* Show the handler the original registers. */\n\t\tsyscall_rollback(current, current_pt_regs());\n\t\t/* Let the filter pass back 16 bits of data. */\n\t\tforce_sig_seccomp(this_syscall, data, false);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRACE:\n\t\t/* We've been put in this state by the ptracer already. */\n\t\tif (recheck_after_trace)\n\t\t\treturn 0;\n\n\t\t/* ENOSYS these calls if there is no tracer attached. */\n\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\n\t\t\tsyscall_set_return_value(current,\n\t\t\t\t\t\t current_pt_regs(),\n\t\t\t\t\t\t -ENOSYS, 0);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/* Allow the BPF to provide the event message */\n\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);\n\t\t/*\n\t\t * The delivery of a fatal signal during event\n\t\t * notification may silently skip tracer notification,\n\t\t * which could leave us with a potentially unmodified\n\t\t * syscall that the tracer would have liked to have\n\t\t * changed. Since the process is about to die, we just\n\t\t * force the syscall to be skipped and let the signal\n\t\t * kill the process and correctly handle any tracer exit\n\t\t * notifications.\n\t\t */\n\t\tif (fatal_signal_pending(current))\n\t\t\tgoto skip;\n\t\t/* Check if the tracer forced the syscall to be skipped. */\n\t\tthis_syscall = syscall_get_nr(current, current_pt_regs());\n\t\tif (this_syscall < 0)\n\t\t\tgoto skip;\n\n\t\t/*\n\t\t * Recheck the syscall, since it may have changed. This\n\t\t * intentionally uses a NULL struct seccomp_data to force\n\t\t * a reload of all registers. This does not goto skip since\n\t\t * a skip would have already been reported.\n\t\t */\n\t\tif (__seccomp_filter(this_syscall, NULL, true))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tif (seccomp_do_user_notification(this_syscall, match, sd))\n\t\t\tgoto skip;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_LOG:\n\t\tseccomp_log(this_syscall, 0, action, true);\n\t\treturn 0;\n\n\tcase SECCOMP_RET_ALLOW:\n\t\t/*\n\t\t * Note that the \"match\" filter will always be NULL for\n\t\t * this action since SECCOMP_RET_ALLOW is the starting\n\t\t * state in seccomp_run_filters().\n\t\t */\n\t\treturn 0;\n\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tseccomp_log(this_syscall, SIGSYS, action, true);\n\t\t/* Dump core only if this is the last remaining thread. */\n\t\tif (action != SECCOMP_RET_KILL_THREAD ||\n\t\t    (atomic_read(&current->signal->live) == 1)) {\n\t\t\t/* Show the original registers in the dump. */\n\t\t\tsyscall_rollback(current, current_pt_regs());\n\t\t\t/* Trigger a coredump with SIGSYS */\n\t\t\tforce_sig_seccomp(this_syscall, data, true);\n\t\t} else {\n\t\t\tdo_exit(SIGSYS);\n\t\t}\n\t\treturn -1; /* skip the syscall go directly to signal handling */\n\t}\n\n\tunreachable();\n\nskip:\n\tseccomp_log(this_syscall, 0, action, match ? match->log : false);\n\treturn -1;\n}"
  },
  {
    "function_name": "seccomp_do_user_notification",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1079-1158",
    "snippet": "static int seccomp_do_user_notification(int this_syscall,\n\t\t\t\t\tstruct seccomp_filter *match,\n\t\t\t\t\tconst struct seccomp_data *sd)\n{\n\tint err;\n\tu32 flags = 0;\n\tlong ret = 0;\n\tstruct seccomp_knotif n = {};\n\tstruct seccomp_kaddfd *addfd, *tmp;\n\n\tmutex_lock(&match->notify_lock);\n\terr = -ENOSYS;\n\tif (!match->notif)\n\t\tgoto out;\n\n\tn.task = current;\n\tn.state = SECCOMP_NOTIFY_INIT;\n\tn.data = sd;\n\tn.id = seccomp_next_notify_id(match);\n\tinit_completion(&n.ready);\n\tlist_add(&n.list, &match->notif->notifications);\n\tINIT_LIST_HEAD(&n.addfd);\n\n\tup(&match->notif->request);\n\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\n\t/*\n\t * This is where we wait for a reply from userspace.\n\t */\n\tdo {\n\t\tmutex_unlock(&match->notify_lock);\n\t\terr = wait_for_completion_interruptible(&n.ready);\n\t\tmutex_lock(&match->notify_lock);\n\t\tif (err != 0)\n\t\t\tgoto interrupted;\n\n\t\taddfd = list_first_entry_or_null(&n.addfd,\n\t\t\t\t\t\t struct seccomp_kaddfd, list);\n\t\t/* Check if we were woken up by a addfd message */\n\t\tif (addfd)\n\t\t\tseccomp_handle_addfd(addfd, &n);\n\n\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);\n\n\tret = n.val;\n\terr = n.error;\n\tflags = n.flags;\n\ninterrupted:\n\t/* If there were any pending addfd calls, clear them out */\n\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {\n\t\t/* The process went away before we got a chance to handle it */\n\t\taddfd->ret = -ESRCH;\n\t\tlist_del_init(&addfd->list);\n\t\tcomplete(&addfd->completion);\n\t}\n\n\t/*\n\t * Note that it's possible the listener died in between the time when\n\t * we were notified of a response (or a signal) and when we were able to\n\t * re-acquire the lock, so only delete from the list if the\n\t * notification actually exists.\n\t *\n\t * Also note that this test is only valid because there's no way to\n\t * *reattach* to a notifier right now. If one is added, we'll need to\n\t * keep track of the notif itself and make sure they match here.\n\t */\n\tif (match->notif)\n\t\tlist_del(&n.list);\nout:\n\tmutex_unlock(&match->notify_lock);\n\n\t/* Userspace requests to continue the syscall. */\n\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn 0;\n\n\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t err, ret);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall_set_return_value",
          "args": [
            "current",
            "current_pt_regs()",
            "err",
            "ret"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&match->notify_lock"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&n.list"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&addfd->completion"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&addfd->list"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "addfd",
            "tmp",
            "&n.addfd",
            "list"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_handle_addfd",
          "args": [
            "addfd",
            "&n"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_handle_addfd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1045-1077",
          "snippet": "static void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)\n{\n\tint fd;\n\n\t/*\n\t * Remove the notification, and reset the list pointers, indicating\n\t * that it has been handled.\n\t */\n\tlist_del_init(&addfd->list);\n\tif (!addfd->setfd)\n\t\tfd = receive_fd(addfd->file, addfd->flags);\n\telse\n\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);\n\taddfd->ret = fd;\n\n\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/* If we fail reset and return an error to the notifier */\n\t\tif (fd < 0) {\n\t\t\tn->state = SECCOMP_NOTIFY_SENT;\n\t\t} else {\n\t\t\t/* Return the FD we just added */\n\t\t\tn->flags = 0;\n\t\t\tn->error = 0;\n\t\t\tn->val = fd;\n\t\t}\n\t}\n\n\t/*\n\t * Mark the notification as completed. From this point, addfd mem\n\t * might be invalidated and we can't safely read it anymore.\n\t */\n\tcomplete(&addfd->completion);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)\n{\n\tint fd;\n\n\t/*\n\t * Remove the notification, and reset the list pointers, indicating\n\t * that it has been handled.\n\t */\n\tlist_del_init(&addfd->list);\n\tif (!addfd->setfd)\n\t\tfd = receive_fd(addfd->file, addfd->flags);\n\telse\n\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);\n\taddfd->ret = fd;\n\n\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/* If we fail reset and return an error to the notifier */\n\t\tif (fd < 0) {\n\t\t\tn->state = SECCOMP_NOTIFY_SENT;\n\t\t} else {\n\t\t\t/* Return the FD we just added */\n\t\t\tn->flags = 0;\n\t\t\tn->error = 0;\n\t\t\tn->val = fd;\n\t\t}\n\t}\n\n\t/*\n\t * Mark the notification as completed. From this point, addfd mem\n\t * might be invalidated and we can't safely read it anymore.\n\t */\n\tcomplete(&addfd->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&n.addfd",
            "structseccomp_kaddfd",
            "list"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&match->notify_lock"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&n.ready"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "204-210",
          "snippet": "int __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_INTERRUPTIBLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_INTERRUPTIBLE);\n\tif (t == -ERESTARTSYS)\n\t\treturn t;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&match->wqh",
            "EPOLLIN | EPOLLRDNORM"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&match->notif->request"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "has_duplicate_listener",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1767-1782",
          "snippet": "static bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&n.addfd"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&n.list",
            "&match->notif->notifications"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&n.ready"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_next_notify_id",
          "args": [
            "match"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_next_notify_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1035-1043",
          "snippet": "static u64 seccomp_next_notify_id(struct seccomp_filter *filter)\n{\n\t/*\n\t * Note: overflow is ok here, the id just needs to be unique per\n\t * filter.\n\t */\n\tlockdep_assert_held(&filter->notify_lock);\n\treturn filter->notif->next_id++;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u64 seccomp_next_notify_id(struct seccomp_filter *filter)\n{\n\t/*\n\t * Note: overflow is ok here, the id just needs to be unique per\n\t * filter.\n\t */\n\tlockdep_assert_held(&filter->notify_lock);\n\treturn filter->notif->next_id++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int seccomp_do_user_notification(int this_syscall,\n\t\t\t\t\tstruct seccomp_filter *match,\n\t\t\t\t\tconst struct seccomp_data *sd)\n{\n\tint err;\n\tu32 flags = 0;\n\tlong ret = 0;\n\tstruct seccomp_knotif n = {};\n\tstruct seccomp_kaddfd *addfd, *tmp;\n\n\tmutex_lock(&match->notify_lock);\n\terr = -ENOSYS;\n\tif (!match->notif)\n\t\tgoto out;\n\n\tn.task = current;\n\tn.state = SECCOMP_NOTIFY_INIT;\n\tn.data = sd;\n\tn.id = seccomp_next_notify_id(match);\n\tinit_completion(&n.ready);\n\tlist_add(&n.list, &match->notif->notifications);\n\tINIT_LIST_HEAD(&n.addfd);\n\n\tup(&match->notif->request);\n\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\n\t/*\n\t * This is where we wait for a reply from userspace.\n\t */\n\tdo {\n\t\tmutex_unlock(&match->notify_lock);\n\t\terr = wait_for_completion_interruptible(&n.ready);\n\t\tmutex_lock(&match->notify_lock);\n\t\tif (err != 0)\n\t\t\tgoto interrupted;\n\n\t\taddfd = list_first_entry_or_null(&n.addfd,\n\t\t\t\t\t\t struct seccomp_kaddfd, list);\n\t\t/* Check if we were woken up by a addfd message */\n\t\tif (addfd)\n\t\t\tseccomp_handle_addfd(addfd, &n);\n\n\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);\n\n\tret = n.val;\n\terr = n.error;\n\tflags = n.flags;\n\ninterrupted:\n\t/* If there were any pending addfd calls, clear them out */\n\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {\n\t\t/* The process went away before we got a chance to handle it */\n\t\taddfd->ret = -ESRCH;\n\t\tlist_del_init(&addfd->list);\n\t\tcomplete(&addfd->completion);\n\t}\n\n\t/*\n\t * Note that it's possible the listener died in between the time when\n\t * we were notified of a response (or a signal) and when we were able to\n\t * re-acquire the lock, so only delete from the list if the\n\t * notification actually exists.\n\t *\n\t * Also note that this test is only valid because there's no way to\n\t * *reattach* to a notifier right now. If one is added, we'll need to\n\t * keep track of the notif itself and make sure they match here.\n\t */\n\tif (match->notif)\n\t\tlist_del(&n.list);\nout:\n\tmutex_unlock(&match->notify_lock);\n\n\t/* Userspace requests to continue the syscall. */\n\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn 0;\n\n\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t err, ret);\n\treturn -1;\n}"
  },
  {
    "function_name": "seccomp_handle_addfd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1045-1077",
    "snippet": "static void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)\n{\n\tint fd;\n\n\t/*\n\t * Remove the notification, and reset the list pointers, indicating\n\t * that it has been handled.\n\t */\n\tlist_del_init(&addfd->list);\n\tif (!addfd->setfd)\n\t\tfd = receive_fd(addfd->file, addfd->flags);\n\telse\n\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);\n\taddfd->ret = fd;\n\n\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/* If we fail reset and return an error to the notifier */\n\t\tif (fd < 0) {\n\t\t\tn->state = SECCOMP_NOTIFY_SENT;\n\t\t} else {\n\t\t\t/* Return the FD we just added */\n\t\t\tn->flags = 0;\n\t\t\tn->error = 0;\n\t\t\tn->val = fd;\n\t\t}\n\t}\n\n\t/*\n\t * Mark the notification as completed. From this point, addfd mem\n\t * might be invalidated and we can't safely read it anymore.\n\t */\n\tcomplete(&addfd->completion);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&addfd->completion"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_fd_replace",
          "args": [
            "addfd->fd",
            "addfd->file",
            "addfd->flags"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receive_fd",
          "args": [
            "addfd->file",
            "addfd->flags"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&addfd->list"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)\n{\n\tint fd;\n\n\t/*\n\t * Remove the notification, and reset the list pointers, indicating\n\t * that it has been handled.\n\t */\n\tlist_del_init(&addfd->list);\n\tif (!addfd->setfd)\n\t\tfd = receive_fd(addfd->file, addfd->flags);\n\telse\n\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);\n\taddfd->ret = fd;\n\n\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t/* If we fail reset and return an error to the notifier */\n\t\tif (fd < 0) {\n\t\t\tn->state = SECCOMP_NOTIFY_SENT;\n\t\t} else {\n\t\t\t/* Return the FD we just added */\n\t\t\tn->flags = 0;\n\t\t\tn->error = 0;\n\t\t\tn->val = fd;\n\t\t}\n\t}\n\n\t/*\n\t * Mark the notification as completed. From this point, addfd mem\n\t * might be invalidated and we can't safely read it anymore.\n\t */\n\tcomplete(&addfd->completion);\n}"
  },
  {
    "function_name": "seccomp_next_notify_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1035-1043",
    "snippet": "static u64 seccomp_next_notify_id(struct seccomp_filter *filter)\n{\n\t/*\n\t * Note: overflow is ok here, the id just needs to be unique per\n\t * filter.\n\t */\n\tlockdep_assert_held(&filter->notify_lock);\n\treturn filter->notif->next_id++;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&filter->notify_lock"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u64 seccomp_next_notify_id(struct seccomp_filter *filter)\n{\n\t/*\n\t * Note: overflow is ok here, the id just needs to be unique per\n\t * filter.\n\t */\n\tlockdep_assert_held(&filter->notify_lock);\n\treturn filter->notif->next_id++;\n}"
  },
  {
    "function_name": "secure_computing_strict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1017-1031",
    "snippet": "void secure_computing_strict(int this_syscall)\n{\n\tint mode = current->seccomp.mode;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn;\n\n\tif (mode == SECCOMP_MODE_DISABLED)\n\t\treturn;\n\telse if (mode == SECCOMP_MODE_STRICT)\n\t\t__secure_computing_strict(this_syscall);\n\telse\n\t\tBUG();\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__secure_computing_strict",
          "args": [
            "this_syscall"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "__secure_computing_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "997-1014",
          "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace & PT_SUSPEND_SECCOMP"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CHECKPOINT_RESTORE"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid secure_computing_strict(int this_syscall)\n{\n\tint mode = current->seccomp.mode;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn;\n\n\tif (mode == SECCOMP_MODE_DISABLED)\n\t\treturn;\n\telse if (mode == SECCOMP_MODE_STRICT)\n\t\t__secure_computing_strict(this_syscall);\n\telse\n\t\tBUG();\n}"
  },
  {
    "function_name": "__secure_computing_strict",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "997-1014",
    "snippet": "static void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGKILL"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_log",
          "args": [
            "this_syscall",
            "SIGKILL",
            "SECCOMP_RET_KILL_THREAD",
            "true"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "944-985",
          "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [
            "#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)",
            "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
            "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
            "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
            "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
            "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
            "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
          ],
          "globals_used": [
            "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compat_mode1_syscalls",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1, /* negative terminated */\n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}"
  },
  {
    "function_name": "seccomp_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "944-985",
    "snippet": "static inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)",
      "#define SECCOMP_LOG_LOG\t\t\t(1 << 5)",
      "#define SECCOMP_LOG_TRACE\t\t(1 << 4)",
      "#define SECCOMP_LOG_ERRNO\t\t(1 << 3)",
      "#define SECCOMP_LOG_TRAP\t\t(1 << 2)",
      "#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)",
      "#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)"
    ],
    "globals_used": [
      "static u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_seccomp",
          "args": [
            "syscall",
            "signr",
            "action"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "audit_seccomp_actions_logged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2972-2989",
          "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t/*\n\t * Emit an audit message when the action is RET_KILL_*, RET_LOG, or the\n\t * FILTER_FLAG_LOG bit was set. The admin has the ability to silence\n\t * any action from being logged by removing the action name from the\n\t * seccomp_actions_logged sysctl.\n\t */\n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}"
  },
  {
    "function_name": "get_seccomp_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "915-922",
    "snippet": "void get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n\trefcount_inc(&orig->users);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&orig->users"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_seccomp_filter",
          "args": [
            "orig"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "__get_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "909-912",
          "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n\trefcount_inc(&orig->users);\n}"
  },
  {
    "function_name": "__get_seccomp_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "909-912",
    "snippet": "static void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&filter->refs"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}"
  },
  {
    "function_name": "seccomp_attach_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "861-907",
    "snippet": "static long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret) {\n\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)\n\t\t\t\treturn -ESRCH;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tseccomp_cache_prepare(filter);\n\tcurrent->seccomp.filter = filter;\n\tatomic_inc(&current->seccomp.filter_count);\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [
      "#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_sync_threads",
          "args": [
            "flags"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_sync_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "576-625",
          "snippet": "static inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\t__seccomp_filter_release(thread->seccomp.filter);\n\n\t\t/* Make our new filter tree visible. */\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\t\tatomic_set(&thread->seccomp.filter_count,\n\t\t\t   atomic_read(&caller->seccomp.filter_count));\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\t__seccomp_filter_release(thread->seccomp.filter);\n\n\t\t/* Make our new filter tree visible. */\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\t\tatomic_set(&thread->seccomp.filter_count,\n\t\t\t   atomic_read(&caller->seccomp.filter_count));\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&current->seccomp.filter_count"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_cache_prepare",
          "args": [
            "filter"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_cache_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "829-846",
          "snippet": "static void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n\tstruct action_cache *cache = &sfilter->cache;\n\tconst struct action_cache *cache_prev =\n\t\tsfilter->prev ? &sfilter->prev->cache : NULL;\n\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,\n\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,\n\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t     SECCOMP_ARCH_NATIVE);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,\n\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,\n\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t     SECCOMP_ARCH_COMPAT);\n#endif /* SECCOMP_ARCH_COMPAT */\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n\tstruct action_cache *cache = &sfilter->cache;\n\tconst struct action_cache *cache_prev =\n\t\tsfilter->prev ? &sfilter->prev->cache : NULL;\n\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,\n\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,\n\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t     SECCOMP_ARCH_NATIVE);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,\n\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,\n\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t     SECCOMP_ARCH_COMPAT);\n#endif /* SECCOMP_ARCH_COMPAT */\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_can_sync_threads",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_can_sync_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "479-510",
          "snippet": "static inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\n#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))\n\nstatic long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate resulting filter length. */\n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;  /* 4 instr penalty */\n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t/* If thread sync has been requested, check that it is possible. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret) {\n\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)\n\t\t\t\treturn -ESRCH;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set log flag, if present. */\n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t/*\n\t * If there is an existing filter, make it the prev and don't drop its\n\t * task reference.\n\t */\n\tfilter->prev = current->seccomp.filter;\n\tseccomp_cache_prepare(filter);\n\tcurrent->seccomp.filter = filter;\n\tatomic_inc(&current->seccomp.filter_count);\n\n\t/* Now that the new filter is in place, synchronize to all threads. */\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_cache_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "829-846",
    "snippet": "static void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n\tstruct action_cache *cache = &sfilter->cache;\n\tconst struct action_cache *cache_prev =\n\t\tsfilter->prev ? &sfilter->prev->cache : NULL;\n\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,\n\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,\n\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t     SECCOMP_ARCH_NATIVE);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,\n\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,\n\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t     SECCOMP_ARCH_COMPAT);\n#endif /* SECCOMP_ARCH_COMPAT */\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_cache_prepare_bitmap",
          "args": [
            "sfilter",
            "cache->allow_compat",
            "cache_prev ? cache_prev->allow_compat : NULL",
            "SECCOMP_ARCH_COMPAT_NR",
            "SECCOMP_ARCH_COMPAT"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_cache_prepare_bitmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "787-821",
          "snippet": "static void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,\n\t\t\t\t\t void *bitmap, const void *bitmap_prev,\n\t\t\t\t\t size_t bitmap_size, int arch)\n{\n\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;\n\tstruct seccomp_data sd;\n\tint nr;\n\n\tif (bitmap_prev) {\n\t\t/* The new filter must be as restrictive as the last. */\n\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);\n\t} else {\n\t\t/* Before any filters, all syscalls are always allowed. */\n\t\tbitmap_fill(bitmap, bitmap_size);\n\t}\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\t/* No bitmap change: not a cacheable action. */\n\t\tif (!test_bit(nr, bitmap))\n\t\t\tcontinue;\n\n\t\tsd.nr = nr;\n\t\tsd.arch = arch;\n\n\t\t/* No bitmap change: continue to always allow. */\n\t\tif (seccomp_is_const_allow(fprog, &sd))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not a cacheable action: always run filters.\n\t\t * atomic clear_bit() not needed, filter not visible yet.\n\t\t */\n\t\t__clear_bit(nr, bitmap);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,\n\t\t\t\t\t void *bitmap, const void *bitmap_prev,\n\t\t\t\t\t size_t bitmap_size, int arch)\n{\n\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;\n\tstruct seccomp_data sd;\n\tint nr;\n\n\tif (bitmap_prev) {\n\t\t/* The new filter must be as restrictive as the last. */\n\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);\n\t} else {\n\t\t/* Before any filters, all syscalls are always allowed. */\n\t\tbitmap_fill(bitmap, bitmap_size);\n\t}\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\t/* No bitmap change: not a cacheable action. */\n\t\tif (!test_bit(nr, bitmap))\n\t\t\tcontinue;\n\n\t\tsd.nr = nr;\n\t\tsd.arch = arch;\n\n\t\t/* No bitmap change: continue to always allow. */\n\t\tif (seccomp_is_const_allow(fprog, &sd))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not a cacheable action: always run filters.\n\t\t * atomic clear_bit() not needed, filter not visible yet.\n\t\t */\n\t\t__clear_bit(nr, bitmap);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n\tstruct action_cache *cache = &sfilter->cache;\n\tconst struct action_cache *cache_prev =\n\t\tsfilter->prev ? &sfilter->prev->cache : NULL;\n\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,\n\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,\n\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t     SECCOMP_ARCH_NATIVE);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,\n\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,\n\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t     SECCOMP_ARCH_COMPAT);\n#endif /* SECCOMP_ARCH_COMPAT */\n}"
  },
  {
    "function_name": "seccomp_cache_prepare_bitmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "787-821",
    "snippet": "static void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,\n\t\t\t\t\t void *bitmap, const void *bitmap_prev,\n\t\t\t\t\t size_t bitmap_size, int arch)\n{\n\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;\n\tstruct seccomp_data sd;\n\tint nr;\n\n\tif (bitmap_prev) {\n\t\t/* The new filter must be as restrictive as the last. */\n\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);\n\t} else {\n\t\t/* Before any filters, all syscalls are always allowed. */\n\t\tbitmap_fill(bitmap, bitmap_size);\n\t}\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\t/* No bitmap change: not a cacheable action. */\n\t\tif (!test_bit(nr, bitmap))\n\t\t\tcontinue;\n\n\t\tsd.nr = nr;\n\t\tsd.arch = arch;\n\n\t\t/* No bitmap change: continue to always allow. */\n\t\tif (seccomp_is_const_allow(fprog, &sd))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not a cacheable action: always run filters.\n\t\t * atomic clear_bit() not needed, filter not visible yet.\n\t\t */\n\t\t__clear_bit(nr, bitmap);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "nr",
            "bitmap"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_is_const_allow",
          "args": [
            "fprog",
            "&sd"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_is_const_allow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "714-785",
          "snippet": "static bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,\n\t\t\t\t   struct seccomp_data *sd)\n{\n\tunsigned int reg_value = 0;\n\tunsigned int pc;\n\tbool op_res;\n\n\tif (WARN_ON_ONCE(!fprog))\n\t\treturn false;\n\n\tfor (pc = 0; pc < fprog->len; pc++) {\n\t\tstruct sock_filter *insn = &fprog->filter[pc];\n\t\tu16 code = insn->code;\n\t\tu32 k = insn->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tswitch (k) {\n\t\t\tcase offsetof(struct seccomp_data, nr):\n\t\t\t\treg_value = sd->nr;\n\t\t\t\tbreak;\n\t\t\tcase offsetof(struct seccomp_data, arch):\n\t\t\t\treg_value = sd->arch;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (non-constant value load) */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET | BPF_K:\n\t\t\t/* reached return with constant values only, check allow */\n\t\t\treturn k == SECCOMP_RET_ALLOW;\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\tpc += insn->k;\n\t\t\tbreak;\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t\tswitch (BPF_OP(code)) {\n\t\t\tcase BPF_JEQ:\n\t\t\t\top_res = reg_value == k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGE:\n\t\t\t\top_res = reg_value >= k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGT:\n\t\t\t\top_res = reg_value > k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JSET:\n\t\t\t\top_res = !!(reg_value & k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (unknown jump) */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpc += op_res ? insn->jt : insn->jf;\n\t\t\tbreak;\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\t\treg_value &= k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* can't optimize (unknown insn) */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* ran off the end of the filter?! */\n\tWARN_ON(1);\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,\n\t\t\t\t   struct seccomp_data *sd)\n{\n\tunsigned int reg_value = 0;\n\tunsigned int pc;\n\tbool op_res;\n\n\tif (WARN_ON_ONCE(!fprog))\n\t\treturn false;\n\n\tfor (pc = 0; pc < fprog->len; pc++) {\n\t\tstruct sock_filter *insn = &fprog->filter[pc];\n\t\tu16 code = insn->code;\n\t\tu32 k = insn->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tswitch (k) {\n\t\t\tcase offsetof(struct seccomp_data, nr):\n\t\t\t\treg_value = sd->nr;\n\t\t\t\tbreak;\n\t\t\tcase offsetof(struct seccomp_data, arch):\n\t\t\t\treg_value = sd->arch;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (non-constant value load) */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET | BPF_K:\n\t\t\t/* reached return with constant values only, check allow */\n\t\t\treturn k == SECCOMP_RET_ALLOW;\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\tpc += insn->k;\n\t\t\tbreak;\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t\tswitch (BPF_OP(code)) {\n\t\t\tcase BPF_JEQ:\n\t\t\t\top_res = reg_value == k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGE:\n\t\t\t\top_res = reg_value >= k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGT:\n\t\t\t\top_res = reg_value > k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JSET:\n\t\t\t\top_res = !!(reg_value & k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (unknown jump) */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpc += op_res ? insn->jt : insn->jf;\n\t\t\tbreak;\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\t\treg_value &= k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* can't optimize (unknown insn) */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* ran off the end of the filter?! */\n\tWARN_ON(1);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "nr",
            "bitmap"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_fill",
          "args": [
            "bitmap",
            "bitmap_size"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_copy",
          "args": [
            "bitmap",
            "bitmap_prev",
            "bitmap_size"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,\n\t\t\t\t\t void *bitmap, const void *bitmap_prev,\n\t\t\t\t\t size_t bitmap_size, int arch)\n{\n\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;\n\tstruct seccomp_data sd;\n\tint nr;\n\n\tif (bitmap_prev) {\n\t\t/* The new filter must be as restrictive as the last. */\n\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);\n\t} else {\n\t\t/* Before any filters, all syscalls are always allowed. */\n\t\tbitmap_fill(bitmap, bitmap_size);\n\t}\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\t/* No bitmap change: not a cacheable action. */\n\t\tif (!test_bit(nr, bitmap))\n\t\t\tcontinue;\n\n\t\tsd.nr = nr;\n\t\tsd.arch = arch;\n\n\t\t/* No bitmap change: continue to always allow. */\n\t\tif (seccomp_is_const_allow(fprog, &sd))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not a cacheable action: always run filters.\n\t\t * atomic clear_bit() not needed, filter not visible yet.\n\t\t */\n\t\t__clear_bit(nr, bitmap);\n\t}\n}"
  },
  {
    "function_name": "seccomp_is_const_allow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "714-785",
    "snippet": "static bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,\n\t\t\t\t   struct seccomp_data *sd)\n{\n\tunsigned int reg_value = 0;\n\tunsigned int pc;\n\tbool op_res;\n\n\tif (WARN_ON_ONCE(!fprog))\n\t\treturn false;\n\n\tfor (pc = 0; pc < fprog->len; pc++) {\n\t\tstruct sock_filter *insn = &fprog->filter[pc];\n\t\tu16 code = insn->code;\n\t\tu32 k = insn->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tswitch (k) {\n\t\t\tcase offsetof(struct seccomp_data, nr):\n\t\t\t\treg_value = sd->nr;\n\t\t\t\tbreak;\n\t\t\tcase offsetof(struct seccomp_data, arch):\n\t\t\t\treg_value = sd->arch;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (non-constant value load) */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET | BPF_K:\n\t\t\t/* reached return with constant values only, check allow */\n\t\t\treturn k == SECCOMP_RET_ALLOW;\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\tpc += insn->k;\n\t\t\tbreak;\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t\tswitch (BPF_OP(code)) {\n\t\t\tcase BPF_JEQ:\n\t\t\t\top_res = reg_value == k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGE:\n\t\t\t\top_res = reg_value >= k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGT:\n\t\t\t\top_res = reg_value > k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JSET:\n\t\t\t\top_res = !!(reg_value & k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (unknown jump) */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpc += op_res ? insn->jt : insn->jf;\n\t\t\tbreak;\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\t\treg_value &= k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* can't optimize (unknown insn) */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* ran off the end of the filter?! */\n\tWARN_ON(1);\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "code"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!fprog"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,\n\t\t\t\t   struct seccomp_data *sd)\n{\n\tunsigned int reg_value = 0;\n\tunsigned int pc;\n\tbool op_res;\n\n\tif (WARN_ON_ONCE(!fprog))\n\t\treturn false;\n\n\tfor (pc = 0; pc < fprog->len; pc++) {\n\t\tstruct sock_filter *insn = &fprog->filter[pc];\n\t\tu16 code = insn->code;\n\t\tu32 k = insn->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tswitch (k) {\n\t\t\tcase offsetof(struct seccomp_data, nr):\n\t\t\t\treg_value = sd->nr;\n\t\t\t\tbreak;\n\t\t\tcase offsetof(struct seccomp_data, arch):\n\t\t\t\treg_value = sd->arch;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (non-constant value load) */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET | BPF_K:\n\t\t\t/* reached return with constant values only, check allow */\n\t\t\treturn k == SECCOMP_RET_ALLOW;\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\tpc += insn->k;\n\t\t\tbreak;\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t\tswitch (BPF_OP(code)) {\n\t\t\tcase BPF_JEQ:\n\t\t\t\top_res = reg_value == k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGE:\n\t\t\t\top_res = reg_value >= k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGT:\n\t\t\t\top_res = reg_value > k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JSET:\n\t\t\t\top_res = !!(reg_value & k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* can't optimize (unknown jump) */\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpc += op_res ? insn->jt : insn->jf;\n\t\t\tbreak;\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\t\treg_value &= k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* can't optimize (unknown insn) */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* ran off the end of the filter?! */\n\tWARN_ON(1);\n\treturn false;\n}"
  },
  {
    "function_name": "seccomp_prepare_user_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "685-705",
    "snippet": "static struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_prepare_filter",
          "args": [
            "&fprog"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_prepare_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "633-677",
          "snippet": "static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig =\n#if defined(CONFIG_CHECKPOINT_RESTORE) || defined(SECCOMP_ARCH_NATIVE)\n\t\ttrue;\n#else\n\t\tfalse;\n#endif\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t\t\t!ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sfilter->notify_lock);\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->refs, 1);\n\trefcount_set(&sfilter->users, 1);\n\tinit_waitqueue_head(&sfilter->wqh);\n\n\treturn sfilter;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig =\n#if defined(CONFIG_CHECKPOINT_RESTORE) || defined(SECCOMP_ARCH_NATIVE)\n\t\ttrue;\n#else\n\t\tfalse;\n#endif\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t\t\t!ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sfilter->notify_lock);\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->refs, 1);\n\trefcount_set(&sfilter->users, 1);\n\tinit_waitqueue_head(&sfilter->wqh);\n\n\treturn sfilter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fprog",
            "user_filter",
            "sizeof(fprog)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "fprog32.filter"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fprog32",
            "user_filter",
            "sizeof(fprog32)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else /* falls through to the if below. */\n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}"
  },
  {
    "function_name": "seccomp_prepare_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "633-677",
    "snippet": "static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig =\n#if defined(CONFIG_CHECKPOINT_RESTORE) || defined(SECCOMP_ARCH_NATIVE)\n\t\ttrue;\n#else\n\t\tfalse;\n#endif\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t\t\t!ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sfilter->notify_lock);\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->refs, 1);\n\trefcount_set(&sfilter->users, 1);\n\tinit_waitqueue_head(&sfilter->wqh);\n\n\treturn sfilter;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sfilter->wqh"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&sfilter->users",
            "1"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&sfilter->refs",
            "1"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sfilter"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_create_from_user",
          "args": [
            "&sfilter->prog",
            "fprog",
            "seccomp_check_filter",
            "save_orig"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sfilter->notify_lock"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sfilter)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable_noaudit",
          "args": [
            "current_user_ns()",
            "CAP_SYS_ADMIN"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "412-415",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "INT_MAX / fprog->len < sizeof(struct sock_filter)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig =\n#if defined(CONFIG_CHECKPOINT_RESTORE) || defined(SECCOMP_ARCH_NATIVE)\n\t\ttrue;\n#else\n\t\tfalse;\n#endif\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t/*\n\t * Installing a seccomp filter requires that the task has\n\t * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.\n\t * This avoids scenarios where unprivileged tasks can affect the\n\t * behavior of privileged children.\n\t */\n\tif (!task_no_new_privs(current) &&\n\t\t\t!ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EACCES);\n\n\t/* Allocate a new seccomp_filter */\n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sfilter->notify_lock);\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->refs, 1);\n\trefcount_set(&sfilter->users, 1);\n\tinit_waitqueue_head(&sfilter->wqh);\n\n\treturn sfilter;\n}"
  },
  {
    "function_name": "seccomp_sync_threads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "576-625",
    "snippet": "static inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\t__seccomp_filter_release(thread->seccomp.filter);\n\n\t\t/* Make our new filter tree visible. */\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\t\tatomic_set(&thread->seccomp.filter_count,\n\t\t\t   atomic_read(&caller->seccomp.filter_count));\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_assign_mode",
          "args": [
            "thread",
            "SECCOMP_MODE_FILTER",
            "flags"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_assign_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "438-454",
          "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_set_no_new_privs",
          "args": [
            "thread"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "caller"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&thread->seccomp.filter_count",
            "atomic_read(&caller->seccomp.filter_count)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&caller->seccomp.filter_count"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&thread->seccomp.filter",
            "caller->seccomp.filter"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__seccomp_filter_release",
          "args": [
            "thread->seccomp.filter"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "539-545",
          "snippet": "static void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seccomp_filter",
          "args": [
            "caller"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "get_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "915-922",
          "snippet": "void get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n\trefcount_inc(&orig->users);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n\trefcount_inc(&orig->users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "caller",
            "thread"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&current->signal->cred_guard_mutex)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Synchronize all threads. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t/* Skip current, since it needs no changes. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t/* Get a task reference for the new leaf node. */\n\t\tget_seccomp_filter(caller);\n\n\t\t/*\n\t\t * Drop the task reference to the shared ancestor since\n\t\t * current's path will hold a reference.  (This also\n\t\t * allows a put before the assignment.)\n\t\t */\n\t\t__seccomp_filter_release(thread->seccomp.filter);\n\n\t\t/* Make our new filter tree visible. */\n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\t\tatomic_set(&thread->seccomp.filter_count,\n\t\t\t   atomic_read(&caller->seccomp.filter_count));\n\n\t\t/*\n\t\t * Don't let an unprivileged task work around\n\t\t * the no_new_privs restriction by creating\n\t\t * a thread that sets it up, enters seccomp,\n\t\t * then dies.\n\t\t */\n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t/*\n\t\t * Opt the other thread into seccomp if needed.\n\t\t * As threads are considered to be trust-realm\n\t\t * equivalent (see ptrace_may_access), it is safe to\n\t\t * allow one thread to transition the other.\n\t\t */\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}"
  },
  {
    "function_name": "seccomp_filter_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "556-566",
    "snippet": "void seccomp_filter_release(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\n\t/* We are effectively holding the siglock by not having any sighand. */\n\tWARN_ON(tsk->sighand != NULL);\n\n\t/* Detach task from its filter tree. */\n\ttsk->seccomp.filter = NULL;\n\t__seccomp_filter_release(orig);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seccomp_filter_release",
          "args": [
            "orig"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "539-545",
          "snippet": "static void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tsk->sighand != NULL"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid seccomp_filter_release(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\n\t/* We are effectively holding the siglock by not having any sighand. */\n\tWARN_ON(tsk->sighand != NULL);\n\n\t/* Detach task from its filter tree. */\n\ttsk->seccomp.filter = NULL;\n\t__seccomp_filter_release(orig);\n}"
  },
  {
    "function_name": "__seccomp_filter_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "539-545",
    "snippet": "static void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_seccomp_filter",
          "args": [
            "orig"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__put_seccomp_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "529-537",
          "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seccomp_filter_orphan",
          "args": [
            "orig"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__seccomp_filter_orphan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "520-527",
          "snippet": "static void __seccomp_filter_orphan(struct seccomp_filter *orig)\n{\n\twhile (orig && refcount_dec_and_test(&orig->users)) {\n\t\tif (waitqueue_active(&orig->wqh))\n\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);\n\t\torig = orig->prev;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __seccomp_filter_orphan(struct seccomp_filter *orig)\n{\n\twhile (orig && refcount_dec_and_test(&orig->users)) {\n\t\tif (waitqueue_active(&orig->wqh))\n\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);\n\t\torig = orig->prev;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t/* Notify about any unused filters in the task's former filter tree. */\n\t__seccomp_filter_orphan(orig);\n\t/* Finally drop all references to the task's former tree. */\n\t__put_seccomp_filter(orig);\n}"
  },
  {
    "function_name": "__put_seccomp_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "529-537",
    "snippet": "static void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_filter_free",
          "args": [
            "freeme"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "512-518",
          "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&orig->refs"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t/* Clean up single-reference branches iteratively. */\n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}"
  },
  {
    "function_name": "__seccomp_filter_orphan",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "520-527",
    "snippet": "static void __seccomp_filter_orphan(struct seccomp_filter *orig)\n{\n\twhile (orig && refcount_dec_and_test(&orig->users)) {\n\t\tif (waitqueue_active(&orig->wqh))\n\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);\n\t\torig = orig->prev;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&orig->wqh",
            "EPOLLHUP"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&orig->wqh"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&orig->users"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void __seccomp_filter_orphan(struct seccomp_filter *orig)\n{\n\twhile (orig && refcount_dec_and_test(&orig->users)) {\n\t\tif (waitqueue_active(&orig->wqh))\n\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);\n\t\torig = orig->prev;\n\t}\n}"
  },
  {
    "function_name": "seccomp_filter_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "512-518",
    "snippet": "static inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filter"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_destroy",
          "args": [
            "filter->prog"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}"
  },
  {
    "function_name": "seccomp_can_sync_threads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "479-510",
    "snippet": "static inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "failed == 0"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "thread"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ancestor",
          "args": [
            "thread->seccomp.filter",
            "caller->seccomp.filter"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "is_ancestor",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "458-468",
          "snippet": "static int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "caller",
            "thread"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&current->signal->cred_guard_mutex)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t/* Validate all threads being eligible for synchronization. */\n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t/* Skip current, since it is initiating the sync. */\n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t/* Return the first thread that cannot be synchronized. */\n\t\tfailed = task_pid_vnr(thread);\n\t\t/* If the pid cannot be resolved, then return -ESRCH */\n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_ancestor",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "458-468",
    "snippet": "static int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t/* NULL is the root ancestor. */\n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "seccomp_assign_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "438-454",
    "snippet": "static inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_task_syscall_work",
          "args": [
            "task",
            "SECCOMP"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_seccomp_spec_mitigate",
          "args": [
            "task"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "arch_seccomp_spec_mitigate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "436-436",
          "snippet": "void __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t/*\n\t * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and\n\t * filter) is set.\n\t */\n\tsmp_mb__before_atomic();\n\t/* Assume default seccomp processes want spec flaw mitigation. */\n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}"
  },
  {
    "function_name": "arch_seccomp_spec_mitigate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "436-436",
    "snippet": "void __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }"
  },
  {
    "function_name": "seccomp_may_assign_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "426-434",
    "snippet": "static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "seccomp_run_filters",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "395-423",
    "snippet": "static u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (seccomp_cache_check_allow(f, sd))\n\t\treturn SECCOMP_RET_ALLOW;\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = bpf_prog_run_pin_on_cpu(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACTION_ONLY",
          "args": [
            "ret"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACTION_ONLY",
          "args": [
            "cur_ret"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_run_pin_on_cpu",
          "args": [
            "f->prog",
            "sd"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_cache_check_allow",
          "args": [
            "f",
            "sd"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_cache_check_allow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "358-382",
          "snippet": "static inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\tint syscall_nr = sd->nr;\n\tconst struct action_cache *cache = &sfilter->cache;\n\n#ifndef SECCOMP_ARCH_COMPAT\n\t/* A native-only architecture doesn't need to check sd->arch. */\n\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\tsyscall_nr);\n#else\n\tif (likely(sd->arch == SECCOMP_ARCH_NATIVE))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n\tif (likely(sd->arch == SECCOMP_ARCH_COMPAT))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_compat,\n\t\t\t\t\t\t\tSECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\tWARN_ON_ONCE(true);\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\tint syscall_nr = sd->nr;\n\tconst struct action_cache *cache = &sfilter->cache;\n\n#ifndef SECCOMP_ARCH_COMPAT\n\t/* A native-only architecture doesn't need to check sd->arch. */\n\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\tsyscall_nr);\n#else\n\tif (likely(sd->arch == SECCOMP_ARCH_NATIVE))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n\tif (likely(sd->arch == SECCOMP_ARCH_COMPAT))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_compat,\n\t\t\t\t\t\t\tSECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\tWARN_ON_ONCE(true);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "f == NULL"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current->seccomp.filter"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t/* Make sure cross-thread synced filter points somewhere sane. */\n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t/* Ensure unexpected behavior doesn't result in failing open. */\n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (seccomp_cache_check_allow(f, sd))\n\t\treturn SECCOMP_RET_ALLOW;\n\n\t/*\n\t * All filters in the list are evaluated and the lowest BPF return\n\t * value always takes priority (ignoring the DATA).\n\t */\n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = bpf_prog_run_pin_on_cpu(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "seccomp_cache_check_allow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "358-382",
    "snippet": "static inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\tint syscall_nr = sd->nr;\n\tconst struct action_cache *cache = &sfilter->cache;\n\n#ifndef SECCOMP_ARCH_COMPAT\n\t/* A native-only architecture doesn't need to check sd->arch. */\n\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\tsyscall_nr);\n#else\n\tif (likely(sd->arch == SECCOMP_ARCH_NATIVE))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n\tif (likely(sd->arch == SECCOMP_ARCH_COMPAT))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_compat,\n\t\t\t\t\t\t\tSECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\tWARN_ON_ONCE(true);\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "true"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_cache_check_allow_bitmap",
          "args": [
            "cache->allow_compat",
            "SECCOMP_ARCH_COMPAT_NR",
            "syscall_nr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_cache_check_allow_bitmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "340-349",
          "snippet": "static inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,\n\t\t\t\t\t\t    size_t bitmap_size,\n\t\t\t\t\t\t    int syscall_nr)\n{\n\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))\n\t\treturn false;\n\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);\n\n\treturn test_bit(syscall_nr, bitmap);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,\n\t\t\t\t\t\t    size_t bitmap_size,\n\t\t\t\t\t\t    int syscall_nr)\n{\n\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))\n\t\treturn false;\n\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);\n\n\treturn test_bit(syscall_nr, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sd->arch == SECCOMP_ARCH_COMPAT"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sd->arch == SECCOMP_ARCH_NATIVE"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\tint syscall_nr = sd->nr;\n\tconst struct action_cache *cache = &sfilter->cache;\n\n#ifndef SECCOMP_ARCH_COMPAT\n\t/* A native-only architecture doesn't need to check sd->arch. */\n\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\tsyscall_nr);\n#else\n\tif (likely(sd->arch == SECCOMP_ARCH_NATIVE))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n\tif (likely(sd->arch == SECCOMP_ARCH_COMPAT))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_compat,\n\t\t\t\t\t\t\tSECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n#endif /* SECCOMP_ARCH_COMPAT */\n\n\tWARN_ON_ONCE(true);\n\treturn false;\n}"
  },
  {
    "function_name": "seccomp_cache_check_allow_bitmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "340-349",
    "snippet": "static inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,\n\t\t\t\t\t\t    size_t bitmap_size,\n\t\t\t\t\t\t    int syscall_nr)\n{\n\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))\n\t\treturn false;\n\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);\n\n\treturn test_bit(syscall_nr, bitmap);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "syscall_nr",
            "bitmap"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "syscall_nr",
            "bitmap_size"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "syscall_nr < 0 || syscall_nr >= bitmap_size"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,\n\t\t\t\t\t\t    size_t bitmap_size,\n\t\t\t\t\t\t    int syscall_nr)\n{\n\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))\n\t\treturn false;\n\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);\n\n\treturn test_bit(syscall_nr, bitmap);\n}"
  },
  {
    "function_name": "seccomp_check_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "269-337",
    "snippet": "static int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\n{\n\tint pc;\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\t\tu32 k = ftest->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;\n\t\t\t/* 32-bit aligned and not out of bounds. */\n\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LD | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LDX | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\t/* Explicitly include allowed calls. */\n\t\tcase BPF_RET | BPF_K:\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\tcase BPF_MISC | BPF_TAX:\n\t\tcase BPF_MISC | BPF_TXA:\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\tcase BPF_JMP | BPF_JA:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\n{\n\tint pc;\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\t\tu32 k = ftest->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;\n\t\t\t/* 32-bit aligned and not out of bounds. */\n\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LD | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LDX | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\t/* Explicitly include allowed calls. */\n\t\tcase BPF_RET | BPF_K:\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\tcase BPF_MISC | BPF_TAX:\n\t\tcase BPF_MISC | BPF_TXA:\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\tcase BPF_JMP | BPF_JA:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "populate_seccomp_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "235-255",
    "snippet": "static void populate_seccomp_data(struct seccomp_data *sd)\n{\n\t/*\n\t * Instead of using current_pt_reg(), we're already doing the work\n\t * to safely fetch \"current\", so just use \"task\" everywhere below.\n\t */\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch(task);\n\tsyscall_get_arguments(task, regs, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "task"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arguments",
          "args": [
            "task",
            "regs",
            "args"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [
            "task"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_nr",
          "args": [
            "task",
            "regs"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pt_regs",
          "args": [
            "task"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\t/*\n\t * Instead of using current_pt_reg(), we're already doing the work\n\t * to safely fetch \"current\", so just use \"task\" everywhere below.\n\t */\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch(task);\n\tsyscall_get_arguments(task, regs, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}"
  },
  {
    "function_name": "seccomp_cache_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "177-179",
    "snippet": "static inline void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n}"
  },
  {
    "function_name": "seccomp_cache_check_allow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "171-175",
    "snippet": "static inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
    "lines": "1959-1963",
    "snippet": "SYSCALL_DEFINE3(seccomp, unsigned int, op, unsigned int, flags,\n\t\t\t void __user *, uargs)\n{\n\treturn do_seccomp(op, flags, uargs);\n}",
    "includes": [
      "#include <linux/lockdep.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/capability.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid.h>",
      "#include <linux/filter.h>",
      "#include <linux/file.h>",
      "#include <asm/syscall.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/coredump.h>",
      "#include <linux/compat.h>",
      "#include <linux/audit.h>",
      "#include <linux/refcount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nSYSCALL_DEFINE3(seccomp, unsigned int, op, unsigned int, flags,\n\t\t\t void __user *, uargs)\n{\n\treturn do_seccomp(op, flags, uargs);\n}"
  }
]