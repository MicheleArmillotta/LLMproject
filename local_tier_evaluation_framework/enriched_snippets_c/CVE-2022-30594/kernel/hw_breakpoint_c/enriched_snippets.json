[
  {
    "function_name": "init_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "679-713",
    "snippet": "int __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < TYPE_MAX; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"breakpoint\", PERF_TYPE_BREAKPOINT);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);",
      "static int nr_slots[TYPE_MAX];",
      "static int constraints_initialized;",
      "static struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t/* we need to be notified first */\n\t.priority = 0x7fffffff\n};",
      "static struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, /* could eventually get its own */\n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "get_bp_info(err_cpu, i)->tsk_pinned"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "err_cpu",
            "i"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "52-55",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&hw_breakpoint_exceptions_nb"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "540-543",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_pmu_register",
          "args": [
            "&perf_breakpoint",
            "\"breakpoint\"",
            "PERF_TYPE_BREAKPOINT"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "perf_pmu_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "11080-11213",
          "snippet": "int perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret, max = PERF_TYPE_MAX;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type != PERF_TYPE_SOFTWARE) {\n\t\tif (type >= 0)\n\t\t\tmax = type;\n\n\t\tret = idr_alloc(&pmu_idr, pmu, max, 0, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto free_pdc;\n\n\t\tWARN_ON(type >= 0 && ret != type);\n\n\t\ttype = ret;\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\t\tcpuctx->online = cpumask_test_cpu(cpu, perf_online_mask);\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->heap_size = ARRAY_SIZE(cpuctx->heap_default);\n\t\tcpuctx->heap = cpuctx->heap_default;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->check_period)\n\t\tpmu->check_period = perf_event_nop_int;\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\t/*\n\t * Ensure the TYPE_SOFTWARE PMUs are at the head of the list,\n\t * since these cannot be in the IDR. This way the linear search\n\t * is fast, provided a valid software event is provided.\n\t */\n\tif (type == PERF_TYPE_SOFTWARE || !name)\n\t\tlist_add_rcu(&pmu->entry, &pmus);\n\telse\n\t\tlist_add_tail_rcu(&pmu->entry, &pmus);\n\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type != PERF_TYPE_SOFTWARE)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(pmus);",
            "static DEFINE_MUTEX(pmus_lock);",
            "static cpumask_var_t perf_online_mask;",
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static struct idr pmu_idr;",
            "static DEVICE_ATTR_RO(type);",
            "static int pmu_bus_running;",
            "static struct lock_class_key cpuctx_mutex;",
            "static struct lock_class_key cpuctx_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(pmus);\nstatic DEFINE_MUTEX(pmus_lock);\nstatic cpumask_var_t perf_online_mask;\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic struct idr pmu_idr;\nstatic DEVICE_ATTR_RO(type);\nstatic int pmu_bus_running;\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret, max = PERF_TYPE_MAX;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type != PERF_TYPE_SOFTWARE) {\n\t\tif (type >= 0)\n\t\t\tmax = type;\n\n\t\tret = idr_alloc(&pmu_idr, pmu, max, 0, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto free_pdc;\n\n\t\tWARN_ON(type >= 0 && ret != type);\n\n\t\ttype = ret;\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\t\tcpuctx->online = cpumask_test_cpu(cpu, perf_online_mask);\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->heap_size = ARRAY_SIZE(cpuctx->heap_default);\n\t\tcpuctx->heap = cpuctx->heap_default;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->check_period)\n\t\tpmu->check_period = perf_event_nop_int;\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\t/*\n\t * Ensure the TYPE_SOFTWARE PMUs are at the head of the list,\n\t * since these cannot be in the IDR. This way the linear search\n\t * is fast, provided a valid software event is provided.\n\t */\n\tif (type == PERF_TYPE_SOFTWARE || !name)\n\t\tlist_add_rcu(&pmu->entry, &pmus);\n\telse\n\t\tlist_add_tail_rcu(&pmu->entry, &pmus);\n\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type != PERF_TYPE_SOFTWARE)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_slots[i]",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_slots",
          "args": [
            "i"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\nstatic struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t/* we need to be notified first */\n\t.priority = 0x7fffffff\n};\nstatic struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, /* could eventually get its own */\n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};\n\nint __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < TYPE_MAX; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"breakpoint\", PERF_TYPE_BREAKPOINT);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "hw_breakpoint_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "663-666",
    "snippet": "static void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = PERF_HES_STOPPED;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = PERF_HES_STOPPED;\n}"
  },
  {
    "function_name": "hw_breakpoint_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "658-661",
    "snippet": "static void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "653-656",
    "snippet": "static void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_uninstall_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}"
  },
  {
    "function_name": "hw_breakpoint_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "640-651",
    "snippet": "static int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & PERF_EF_START))\n\t\tbp->hw.state = PERF_HES_STOPPED;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_install_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_set_period",
          "args": [
            "bp"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_set_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "9267-9288",
          "snippet": "u64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sampling_event",
          "args": [
            "bp"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & PERF_EF_START))\n\t\tbp->hw.state = PERF_HES_STOPPED;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}"
  },
  {
    "function_name": "hw_breakpoint_event_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "618-638",
    "snippet": "static int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != PERF_TYPE_BREAKPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for breakpoint events\n\t */\n\tif (has_branch_stack(bp))\n\t\treturn -EOPNOTSUPP;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_perf_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "register_perf_hw_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "430-448",
          "snippet": "int register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_branch_stack",
          "args": [
            "bp"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != PERF_TYPE_BREAKPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for breakpoint events\n\t */\n\tif (has_branch_stack(bp))\n\t\treturn -EOPNOTSUPP;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bp_perf_event_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "613-616",
    "snippet": "static void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_bp_slot",
          "args": [
            "event"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "396-404",
          "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}"
  },
  {
    "function_name": "unregister_wide_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "596-604",
    "snippet": "void unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cpu_events"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}"
  },
  {
    "function_name": "register_wide_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "558-589",
    "snippet": "struct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)ERR_PTR(-ENOMEM);\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, NULL,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (IS_ERR(bp)) {\n\t\t\terr = PTR_ERR(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tcpus_read_unlock();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_wide_hw_breakpoint",
          "args": [
            "cpu_events"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wide_hw_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "596-604",
          "snippet": "void unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "*cpu_events",
            "cpu"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_create_kernel_counter",
          "args": [
            "attr",
            "cpu",
            "NULL",
            "triggered",
            "context"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_create_kernel_counter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12497-12574",
          "snippet": "struct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Grouping is not supported for kernel events, neither is 'AUX',\n\t * make sure the caller's intentions are adjusted.\n\t */\n\tif (attr->aux_output)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TASK_TOMBSTONE ((void *)-1L)"
          ],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Grouping is not supported for kernel events, neither is 'AUX',\n\t * make sure the caller's intentions are adjusted.\n\t */\n\tif (attr->aux_output)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "typeof(*cpu_events)"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*cpu_events"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstruct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)ERR_PTR(-ENOMEM);\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, NULL,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (IS_ERR(bp)) {\n\t\t\terr = PTR_ERR(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tcpus_read_unlock();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)ERR_PTR(err);\n}"
  },
  {
    "function_name": "unregister_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "542-547",
    "snippet": "void unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_release_kernel",
          "args": [
            "bp"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_release_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "5088-5197",
          "snippet": "int perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\tLIST_HEAD(free_list);\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this event as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = READ_ONCE(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_move(&child->child_list, &free_list);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\tlist_for_each_entry_safe(child, tmp, &free_list, child_list) {\n\t\tvoid *var = &child->ctx->refcount;\n\n\t\tlist_del(&child->child_list);\n\t\tfree_event(child);\n\n\t\t/*\n\t\t * Wake any perf_event_free_task() waiting for this event to be\n\t\t * freed.\n\t\t */\n\t\tsmp_mb(); /* pairs with wait_var_event() */\n\t\twake_up_var(var);\n\t}\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DETACH_GROUP\t0x01UL"
          ],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define DETACH_GROUP\t0x01UL\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nint perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\tLIST_HEAD(free_list);\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this event as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = READ_ONCE(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_move(&child->child_list, &free_list);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\tlist_for_each_entry_safe(child, tmp, &free_list, child_list) {\n\t\tvoid *var = &child->ctx->refcount;\n\n\t\tlist_del(&child->child_list);\n\t\tfree_event(child);\n\n\t\t/*\n\t\t * Wake any perf_event_free_task() waiting for this event to be\n\t\t * freed.\n\t\t */\n\t\tsmp_mb(); /* pairs with wait_var_event() */\n\t\twake_up_var(var);\n\t}\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}"
  },
  {
    "function_name": "modify_user_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "514-535",
    "snippet": "int modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tint err;\n\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\terr = modify_user_hw_breakpoint_check(bp, attr, false);\n\n\tif (!bp->attr.disabled)\n\t\tperf_event_enable(bp);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_enable",
          "args": [
            "bp"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_enable_on_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "4242-4280",
          "snippet": "static void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tenum event_type_t event_type = 0;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry) {\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\t\tevent_type |= get_event_type(event);\n\t}\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx, event_type);\n\t} else {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __always_inline enum",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __always_inline enum;\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tenum event_type_t event_type = 0;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry) {\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\t\tevent_type |= get_event_type(event);\n\t}\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx, event_type);\n\t} else {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint_check",
          "args": [
            "bp",
            "attr",
            "false"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "modify_user_hw_breakpoint_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "477-507",
          "snippet": "int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_disable",
          "args": [
            "bp"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_disable_inatomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "2478-2483",
          "snippet": "void perf_event_disable_inatomic(struct perf_event *event)\n{\n\tWRITE_ONCE(event->pending_disable, smp_processor_id());\n\t/* can fail, see perf_pending_event_disable() */\n\tirq_work_queue(&event->pending);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_disable_inatomic(struct perf_event *event)\n{\n\tWRITE_ONCE(event->pending_disable, smp_processor_id());\n\t/* can fail, see perf_pending_event_disable() */\n\tirq_work_queue(&event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_disable_local",
          "args": [
            "bp"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_disable_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "2459-2462",
          "snippet": "void perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tint err;\n\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\terr = modify_user_hw_breakpoint_check(bp, attr, false);\n\n\tif (!bp->attr.disabled)\n\t\tperf_event_enable(bp);\n\n\treturn err;\n}"
  },
  {
    "function_name": "modify_user_hw_breakpoint_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "477-507",
    "snippet": "int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_copy_attr",
          "args": [
            "&bp->attr",
            "attr"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_copy_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "468-475",
          "snippet": "static void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type",
            "attr->bp_type"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "modify_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "373-381",
          "snippet": "static int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nstatic int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&old_attr",
            "attr",
            "sizeof(*attr)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_parse",
          "args": [
            "bp",
            "attr",
            "&hw"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "406-428",
          "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_copy_attr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "468-475",
    "snippet": "static void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}"
  },
  {
    "function_name": "register_user_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "457-465",
    "snippet": "struct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_create_kernel_counter",
          "args": [
            "attr",
            "-1",
            "tsk",
            "triggered",
            "context"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_create_kernel_counter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12497-12574",
          "snippet": "struct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Grouping is not supported for kernel events, neither is 'AUX',\n\t * make sure the caller's intentions are adjusted.\n\t */\n\tif (attr->aux_output)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TASK_TOMBSTONE ((void *)-1L)"
          ],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Grouping is not supported for kernel events, neither is 'AUX',\n\t * make sure the caller's intentions are adjusted.\n\t */\n\tif (attr->aux_output)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstruct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}"
  },
  {
    "function_name": "register_perf_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "430-448",
    "snippet": "int register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_bp_slot",
          "args": [
            "bp"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "396-404",
          "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_parse",
          "args": [
            "bp",
            "&bp->attr",
            "&hw"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "406-428",
          "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_bp_slot",
          "args": [
            "bp"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_reserve_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "388-394",
          "snippet": "int dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw = { };\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "406-428",
    "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_bp_in_kernelspace",
          "args": [
            "hw"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_arch_parse",
          "args": [
            "bp",
            "attr",
            "hw"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_release_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "396-404",
    "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "329-339",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_reserve_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "388-394",
    "snippet": "int dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "277-314",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}"
  },
  {
    "function_name": "modify_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "373-381",
    "snippet": "static int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__modify_bp_slot",
          "args": [
            "bp",
            "old_type",
            "new_type"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__modify_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "351-371",
          "snippet": "static int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nstatic int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__modify_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "351-371",
    "snippet": "static int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "__reserve_bp_slot(bp, old_type)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "old_type"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "277-314",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "old_type"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "329-339",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "release_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "341-349",
    "snippet": "void release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "329-339",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "228-234",
          "snippet": "__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nvoid release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n}"
  },
  {
    "function_name": "__release_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "329-339",
    "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_bp_slot",
          "args": [
            "bp",
            "false",
            "type",
            "weight"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "190-214",
          "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "bp"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "71-74",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "bp_type"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "76-82",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_release_bp_slot",
          "args": [
            "bp"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "arch_release_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "221-223",
          "snippet": "__weak void arch_release_bp_slot(struct perf_event *bp)\n{\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_release_bp_slot(struct perf_event *bp)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\tarch_release_bp_slot(bp);\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
  },
  {
    "function_name": "reserve_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "316-327",
    "snippet": "int reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "277-314",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__reserve_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "277-314",
    "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nr_slots[TYPE_MAX];",
      "static int constraints_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_bp_slot",
          "args": [
            "bp",
            "true",
            "type",
            "weight"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "190-214",
          "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_reserve_bp_slot",
          "args": [
            "bp"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "arch_reserve_bp_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "216-219",
          "snippet": "__weak int arch_reserve_bp_slot(struct perf_event *bp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int arch_reserve_bp_slot(struct perf_event *bp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_this_slot",
          "args": [
            "&slots",
            "weight"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_this_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "163-167",
          "snippet": "static void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_bp_busy_slots",
          "args": [
            "&slots",
            "bp",
            "type"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_bp_busy_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "132-156",
          "snippet": "static void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "bp"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "71-74",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "bp_type"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "76-82",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\tint ret;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\tret = arch_reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_unregister_hw_breakpoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "228-234",
    "snippet": "__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}"
  },
  {
    "function_name": "arch_release_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "221-223",
    "snippet": "__weak void arch_release_bp_slot(struct perf_event *bp)\n{\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_release_bp_slot(struct perf_event *bp)\n{\n}"
  },
  {
    "function_name": "arch_reserve_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "216-219",
    "snippet": "__weak int arch_reserve_bp_slot(struct perf_event *bp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int arch_reserve_bp_slot(struct perf_event *bp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "toggle_bp_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "190-214",
    "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(bp_task_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&bp->hw.bp_list"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bp->hw.bp_list",
            "&bp_task_head"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toggle_bp_task_slot",
          "args": [
            "bp",
            "cpu",
            "type",
            "weight"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_task_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "172-185",
          "snippet": "static void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "bp->cpu",
            "type"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "52-55",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of_bp",
          "args": [
            "bp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
  },
  {
    "function_name": "toggle_bp_task_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "172-185",
    "snippet": "static void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_bp_pinned",
          "args": [
            "cpu",
            "bp",
            "type"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "task_bp_pinned",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "105-119",
          "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "52-55",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}"
  },
  {
    "function_name": "fetch_this_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "163-167",
    "snippet": "static void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}"
  },
  {
    "function_name": "fetch_bp_busy_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "132-156",
    "snippet": "static void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_bp_pinned",
          "args": [
            "cpu",
            "bp",
            "type"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "task_bp_pinned",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "105-119",
          "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_task_bp_pinned",
          "args": [
            "cpu",
            "type"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "max_task_bp_pinned",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "88-99",
          "snippet": "static unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "52-55",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_bp",
          "args": [
            "bp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}"
  },
  {
    "function_name": "cpumask_of_bp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "121-126",
    "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "bp->cpu"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
  },
  {
    "function_name": "task_bp_pinned",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "105-119",
    "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(bp_task_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "iter"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "71-74",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "iter->attr.bp_type"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "76-82",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "iter",
            "&bp_task_head",
            "hw.bp_list"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "max_task_bp_pinned",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "88-99",
    "snippet": "static unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nr_slots[TYPE_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "52-55",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_slot_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "76-82",
    "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
  },
  {
    "function_name": "hw_breakpoint_weight",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "71-74",
    "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "get_bp_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
    "lines": "52-55",
    "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "bp_cpuinfo + type",
            "cpu"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
  }
]