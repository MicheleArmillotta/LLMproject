[
  {
    "function_name": "syscall_prog_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4828-4843",
    "snippet": "static const struct bpf_func_proto *\nsyscall_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_sys_bpf:\n\t\treturn &bpf_sys_bpf_proto;\n\tcase BPF_FUNC_btf_find_by_name_kind:\n\t\treturn &bpf_btf_find_by_name_kind_proto;\n\tcase BPF_FUNC_sys_close:\n\t\treturn &bpf_sys_close_proto;\n\tcase BPF_FUNC_kallsyms_lookup_name:\n\t\treturn &bpf_kallsyms_lookup_name_proto;\n\tdefault:\n\t\treturn tracing_prog_func_proto(func_id, prog);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_func_proto bpf_sys_bpf_proto = {\n\t.func\t\t= bpf_sys_bpf,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM | MEM_RDONLY,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};",
      "static const struct bpf_func_proto bpf_sys_close_proto = {\n\t.func\t\t= bpf_sys_close,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n};",
      "const struct bpf_func_proto bpf_kallsyms_lookup_name_proto = {\n\t.func\t\t= bpf_kallsyms_lookup_name,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_LONG,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_prog_func_proto",
          "args": [
            "func_id",
            "prog"
          ],
          "line": 4841
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_prog_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4780-4784",
          "snippet": "const struct bpf_func_proto * __weak\ntracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn bpf_base_func_proto(func_id);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct bpf_func_proto * __weak\ntracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn bpf_base_func_proto(func_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_func_proto bpf_sys_bpf_proto = {\n\t.func\t\t= bpf_sys_bpf,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_MEM | MEM_RDONLY,\n\t.arg3_type\t= ARG_CONST_SIZE,\n};\nstatic const struct bpf_func_proto bpf_sys_close_proto = {\n\t.func\t\t= bpf_sys_close,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_kallsyms_lookup_name_proto = {\n\t.func\t\t= bpf_kallsyms_lookup_name,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_LONG,\n};\n\nstatic const struct bpf_func_proto *\nsyscall_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_sys_bpf:\n\t\treturn &bpf_sys_bpf_proto;\n\tcase BPF_FUNC_btf_find_by_name_kind:\n\t\treturn &bpf_btf_find_by_name_kind_proto;\n\tcase BPF_FUNC_sys_close:\n\t\treturn &bpf_sys_close_proto;\n\tcase BPF_FUNC_kallsyms_lookup_name:\n\t\treturn &bpf_kallsyms_lookup_name_proto;\n\tdefault:\n\t\treturn tracing_prog_func_proto(func_id, prog);\n\t}\n}"
  },
  {
    "function_name": "tracing_prog_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4780-4784",
    "snippet": "const struct bpf_func_proto * __weak\ntracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn bpf_base_func_proto(func_id);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_base_func_proto",
          "args": [
            "func_id"
          ],
          "line": 4783
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_base_func_proto",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "1354-1459",
          "snippet": "const struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
            "const struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};",
            "const struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
            "const struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
            "const struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};",
            "const struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};",
            "static const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};",
            "const struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};",
            "const struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};",
            "const struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};",
            "static const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};",
            "static const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};",
            "static const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto = {\n\t.func\t\t= bpf_map_lookup_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_update_elem_proto = {\n\t.func\t\t= bpf_map_update_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg4_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_delete_elem_proto = {\n\t.func\t\t= bpf_map_delete_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_KEY,\n};\nconst struct bpf_func_proto bpf_map_push_elem_proto = {\n\t.func\t\t= bpf_map_push_elem,\n\t.gpl_only\t= false,\n\t.pkt_access\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MAP_VALUE,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_map_pop_elem_proto = {\n\t.func\t\t= bpf_map_pop_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_map_peek_elem_proto = {\n\t.func\t\t= bpf_map_peek_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MAP_VALUE,\n};\nconst struct bpf_func_proto bpf_get_prandom_u32_proto = {\n\t.func\t\t= bpf_user_rnd_u32,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_get_numa_node_id_proto = {\n\t.func\t\t= bpf_get_numa_node_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_ns_proto = {\n\t.func\t\t= bpf_ktime_get_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto = {\n\t.func\t\t= bpf_ktime_get_boot_ns,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_spin_lock_proto = {\n\t.func\t\t= bpf_spin_lock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_spin_unlock_proto = {\n\t.func\t\t= bpf_spin_unlock,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_SPIN_LOCK,\n};\nconst struct bpf_func_proto bpf_jiffies64_proto = {\n\t.func\t\t= bpf_jiffies64,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_strncmp_proto = {\n\t.func\t\t= bpf_strncmp,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM,\n\t.arg2_type\t= ARG_CONST_SIZE,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n};\nstatic const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {\n\t.func\t\t= bpf_get_raw_cpu_id,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n};\nconst struct bpf_func_proto bpf_per_cpu_ptr_proto = {\n\t.func\t\t= bpf_per_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n\t.arg2_type\t= ARG_ANYTHING,\n};\nconst struct bpf_func_proto bpf_this_cpu_ptr_proto = {\n\t.func\t\t= bpf_this_cpu_ptr,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MEM_OR_BTF_ID | MEM_RDONLY,\n\t.arg1_type\t= ARG_PTR_TO_PERCPU_BTF_ID,\n};\nconst struct bpf_func_proto bpf_snprintf_proto = {\n\t.func\t\t= bpf_snprintf,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_MEM_OR_NULL,\n\t.arg2_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_PTR_TO_CONST_STR,\n\t.arg4_type\t= ARG_PTR_TO_MEM | PTR_MAYBE_NULL | MEM_RDONLY,\n\t.arg5_type\t= ARG_CONST_SIZE_OR_ZERO,\n};\nstatic const struct bpf_func_proto bpf_timer_init_proto = {\n\t.func\t\t= bpf_timer_init,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_CONST_MAP_PTR,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_set_callback_proto = {\n\t.func\t\t= bpf_timer_set_callback,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n};\nstatic const struct bpf_func_proto bpf_timer_start_proto = {\n\t.func\t\t= bpf_timer_start,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n};\nstatic const struct bpf_func_proto bpf_timer_cancel_proto = {\n\t.func\t\t= bpf_timer_cancel,\n\t.gpl_only\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_TIMER,\n};\n\nconst struct bpf_func_proto *\nbpf_base_func_proto(enum bpf_func_id func_id)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_map_lookup_elem:\n\t\treturn &bpf_map_lookup_elem_proto;\n\tcase BPF_FUNC_map_update_elem:\n\t\treturn &bpf_map_update_elem_proto;\n\tcase BPF_FUNC_map_delete_elem:\n\t\treturn &bpf_map_delete_elem_proto;\n\tcase BPF_FUNC_map_push_elem:\n\t\treturn &bpf_map_push_elem_proto;\n\tcase BPF_FUNC_map_pop_elem:\n\t\treturn &bpf_map_pop_elem_proto;\n\tcase BPF_FUNC_map_peek_elem:\n\t\treturn &bpf_map_peek_elem_proto;\n\tcase BPF_FUNC_get_prandom_u32:\n\t\treturn &bpf_get_prandom_u32_proto;\n\tcase BPF_FUNC_get_smp_processor_id:\n\t\treturn &bpf_get_raw_smp_processor_id_proto;\n\tcase BPF_FUNC_get_numa_node_id:\n\t\treturn &bpf_get_numa_node_id_proto;\n\tcase BPF_FUNC_tail_call:\n\t\treturn &bpf_tail_call_proto;\n\tcase BPF_FUNC_ktime_get_ns:\n\t\treturn &bpf_ktime_get_ns_proto;\n\tcase BPF_FUNC_ktime_get_boot_ns:\n\t\treturn &bpf_ktime_get_boot_ns_proto;\n\tcase BPF_FUNC_ringbuf_output:\n\t\treturn &bpf_ringbuf_output_proto;\n\tcase BPF_FUNC_ringbuf_reserve:\n\t\treturn &bpf_ringbuf_reserve_proto;\n\tcase BPF_FUNC_ringbuf_submit:\n\t\treturn &bpf_ringbuf_submit_proto;\n\tcase BPF_FUNC_ringbuf_discard:\n\t\treturn &bpf_ringbuf_discard_proto;\n\tcase BPF_FUNC_ringbuf_query:\n\t\treturn &bpf_ringbuf_query_proto;\n\tcase BPF_FUNC_for_each_map_elem:\n\t\treturn &bpf_for_each_map_elem_proto;\n\tcase BPF_FUNC_loop:\n\t\treturn &bpf_loop_proto;\n\tcase BPF_FUNC_strncmp:\n\t\treturn &bpf_strncmp_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!bpf_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_jiffies64:\n\t\treturn &bpf_jiffies64_proto;\n\tcase BPF_FUNC_per_cpu_ptr:\n\t\treturn &bpf_per_cpu_ptr_proto;\n\tcase BPF_FUNC_this_cpu_ptr:\n\t\treturn &bpf_this_cpu_ptr_proto;\n\tcase BPF_FUNC_timer_init:\n\t\treturn &bpf_timer_init_proto;\n\tcase BPF_FUNC_timer_set_callback:\n\t\treturn &bpf_timer_set_callback_proto;\n\tcase BPF_FUNC_timer_start:\n\t\treturn &bpf_timer_start_proto;\n\tcase BPF_FUNC_timer_cancel:\n\t\treturn &bpf_timer_cancel_proto;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!perfmon_capable())\n\t\treturn NULL;\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_trace_printk:\n\t\treturn bpf_get_trace_printk_proto();\n\tcase BPF_FUNC_get_current_task:\n\t\treturn &bpf_get_current_task_proto;\n\tcase BPF_FUNC_get_current_task_btf:\n\t\treturn &bpf_get_current_task_btf_proto;\n\tcase BPF_FUNC_probe_read_user:\n\t\treturn &bpf_probe_read_user_proto;\n\tcase BPF_FUNC_probe_read_kernel:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_proto;\n\tcase BPF_FUNC_probe_read_user_str:\n\t\treturn &bpf_probe_read_user_str_proto;\n\tcase BPF_FUNC_probe_read_kernel_str:\n\t\treturn security_locked_down(LOCKDOWN_BPF_READ_KERNEL) < 0 ?\n\t\t       NULL : &bpf_probe_read_kernel_str_proto;\n\tcase BPF_FUNC_snprintf_btf:\n\t\treturn &bpf_snprintf_btf_proto;\n\tcase BPF_FUNC_snprintf:\n\t\treturn &bpf_snprintf_proto;\n\tcase BPF_FUNC_task_pt_regs:\n\t\treturn &bpf_task_pt_regs_proto;\n\tcase BPF_FUNC_trace_vprintk:\n\t\treturn bpf_get_trace_vprintk_proto();\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct bpf_func_proto * __weak\ntracing_prog_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\treturn bpf_base_func_proto(func_id);\n}"
  },
  {
    "function_name": "syscall_prog_is_valid_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4741-4751",
    "snippet": "static bool syscall_prog_is_valid_access(int off, int size,\n\t\t\t\t\t enum bpf_access_type type,\n\t\t\t\t\t const struct bpf_prog *prog,\n\t\t\t\t\t struct bpf_insn_access_aux *info)\n{\n\tif (off < 0 || off >= U16_MAX)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic bool syscall_prog_is_valid_access(int off, int size,\n\t\t\t\t\t enum bpf_access_type type,\n\t\t\t\t\t const struct bpf_prog *prog,\n\t\t\t\t\t struct bpf_insn_access_aux *info)\n{\n\tif (off < 0 || off >= U16_MAX)\n\t\treturn false;\n\tif (off % size != 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "__sys_bpf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4592-4734",
    "snippet": "static int __sys_bpf(int cmd, bpfptr_t uattr, unsigned int size)\n{\n\tunion bpf_attr attr;\n\tint err;\n\n\tif (sysctl_unprivileged_bpf_disabled && !bpf_capable())\n\t\treturn -EPERM;\n\n\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);\n\tif (err)\n\t\treturn err;\n\tsize = min_t(u32, size, sizeof(attr));\n\n\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */\n\tmemset(&attr, 0, sizeof(attr));\n\tif (copy_from_bpfptr(&attr, uattr, size) != 0)\n\t\treturn -EFAULT;\n\n\terr = security_bpf(cmd, &attr, size);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_ELEM:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_ELEM:\n\t\terr = map_update_elem(&attr, uattr);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_ELEM:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_KEY:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase BPF_MAP_FREEZE:\n\t\terr = map_freeze(&attr);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\terr = bpf_prog_load(&attr, uattr);\n\t\tbreak;\n\tcase BPF_OBJ_PIN:\n\t\terr = bpf_obj_pin(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET:\n\t\terr = bpf_obj_get(&attr);\n\t\tbreak;\n\tcase BPF_PROG_ATTACH:\n\t\terr = bpf_prog_attach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_DETACH:\n\t\terr = bpf_prog_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_QUERY:\n\t\terr = bpf_prog_query(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_PROG_TEST_RUN:\n\t\terr = bpf_prog_test_run(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_PROG_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &prog_idr, &prog_idr_lock);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &map_idr, &map_idr_lock);\n\t\tbreak;\n\tcase BPF_BTF_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &btf_idr, &btf_idr_lock);\n\t\tbreak;\n\tcase BPF_PROG_GET_FD_BY_ID:\n\t\terr = bpf_prog_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_FD_BY_ID:\n\t\terr = bpf_map_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET_INFO_BY_FD:\n\t\terr = bpf_obj_get_info_by_fd(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_RAW_TRACEPOINT_OPEN:\n\t\terr = bpf_raw_tracepoint_open(&attr);\n\t\tbreak;\n\tcase BPF_BTF_LOAD:\n\t\terr = bpf_btf_load(&attr, uattr);\n\t\tbreak;\n\tcase BPF_BTF_GET_FD_BY_ID:\n\t\terr = bpf_btf_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_TASK_FD_QUERY:\n\t\terr = bpf_task_fd_query(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:\n\t\terr = map_lookup_and_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_LOOKUP_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user,\n\t\t\t\t       BPF_MAP_LOOKUP_AND_DELETE_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_UPDATE_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_DELETE_BATCH);\n\t\tbreak;\n\tcase BPF_LINK_CREATE:\n\t\terr = link_create(&attr, uattr);\n\t\tbreak;\n\tcase BPF_LINK_UPDATE:\n\t\terr = link_update(&attr);\n\t\tbreak;\n\tcase BPF_LINK_GET_FD_BY_ID:\n\t\terr = bpf_link_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_LINK_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &link_idr, &link_idr_lock);\n\t\tbreak;\n\tcase BPF_ENABLE_STATS:\n\t\terr = bpf_enable_stats(&attr);\n\t\tbreak;\n\tcase BPF_ITER_CREATE:\n\t\terr = bpf_iter_create(&attr);\n\t\tbreak;\n\tcase BPF_LINK_DETACH:\n\t\terr = link_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_BIND_MAP:\n\t\terr = bpf_prog_bind_map(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);",
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);",
      "static DEFINE_IDR(link_idr);",
      "static DEFINE_SPINLOCK(link_idr_lock);",
      "int sysctl_unprivileged_bpf_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_bind_map",
          "args": [
            "&attr"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_bind_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4532-4590",
          "snippet": "static int bpf_prog_bind_map(union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tstruct bpf_map **used_maps_old, **used_maps_new;\n\tint i, ret = 0;\n\n\tif (CHECK_ATTR(BPF_PROG_BIND_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_bind_map.flags)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->prog_bind_map.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmap = bpf_map_get(attr->prog_bind_map.map_fd);\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tgoto out_prog_put;\n\t}\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\n\tused_maps_old = prog->aux->used_maps;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (used_maps_old[i] == map) {\n\t\t\tbpf_map_put(map);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\tused_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,\n\t\t\t\t      sizeof(used_maps_new[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!used_maps_new) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(used_maps_new, used_maps_old,\n\t       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);\n\tused_maps_new[prog->aux->used_map_cnt] = map;\n\n\tprog->aux->used_map_cnt++;\n\tprog->aux->used_maps = used_maps_new;\n\n\tkfree(used_maps_old);\n\nout_unlock:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\tif (ret)\n\t\tbpf_map_put(map);\nout_prog_put:\n\tbpf_prog_put(prog);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_bind_map(union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tstruct bpf_map **used_maps_old, **used_maps_new;\n\tint i, ret = 0;\n\n\tif (CHECK_ATTR(BPF_PROG_BIND_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_bind_map.flags)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->prog_bind_map.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmap = bpf_map_get(attr->prog_bind_map.map_fd);\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tgoto out_prog_put;\n\t}\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\n\tused_maps_old = prog->aux->used_maps;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (used_maps_old[i] == map) {\n\t\t\tbpf_map_put(map);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\tused_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,\n\t\t\t\t      sizeof(used_maps_new[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!used_maps_new) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(used_maps_new, used_maps_old,\n\t       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);\n\tused_maps_new[prog->aux->used_map_cnt] = map;\n\n\tprog->aux->used_map_cnt++;\n\tprog->aux->used_maps = used_maps_new;\n\n\tkfree(used_maps_old);\n\nout_unlock:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\tif (ret)\n\t\tbpf_map_put(map);\nout_prog_put:\n\tbpf_prog_put(prog);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_detach",
          "args": [
            "&attr"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "link_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4380-4399",
          "snippet": "static int link_detach(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_DETACH))\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_detach.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (link->ops->detach)\n\t\tret = link->ops->detach(link);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\tbpf_link_put(link);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_detach(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_DETACH))\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_detach.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (link->ops->detach)\n\t\tret = link->ops->detach(link);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\tbpf_link_put(link);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_create",
          "args": [
            "&attr"
          ],
          "line": 4720
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4509-4528",
          "snippet": "static int bpf_iter_create(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_ITER_CREATE))\n\t\treturn -EINVAL;\n\n\tif (attr->iter_create.flags)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->iter_create.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\terr = bpf_iter_new_fd(link);\n\tbpf_link_put(link);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_iter_create(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_ITER_CREATE))\n\t\treturn -EINVAL;\n\n\tif (attr->iter_create.flags)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->iter_create.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\terr = bpf_iter_new_fd(link);\n\tbpf_link_put(link);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_stats",
          "args": [
            "&attr"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_enable_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4489-4505",
          "snippet": "static int bpf_enable_stats(union bpf_attr *attr)\n{\n\n\tif (CHECK_ATTR(BPF_ENABLE_STATS))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (attr->enable_stats.type) {\n\tcase BPF_STATS_RUN_TIME:\n\t\treturn bpf_enable_runtime_stats();\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_enable_stats(union bpf_attr *attr)\n{\n\n\tif (CHECK_ATTR(BPF_ENABLE_STATS))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (attr->enable_stats.type) {\n\tcase BPF_STATS_RUN_TIME:\n\t\treturn bpf_enable_runtime_stats();\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_get_next_id",
          "args": [
            "&attr",
            "uattr.user",
            "&link_idr",
            "&link_idr_lock"
          ],
          "line": 4713
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_next_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3358-3382",
          "snippet": "static int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_get_fd_by_id",
          "args": [
            "&attr"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4430-4451",
          "snippet": "static int bpf_link_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tu32 id = attr->link_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_LINK_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tlink = bpf_link_by_id(id);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tfd = bpf_link_new_fd(link);\n\tif (fd < 0)\n\t\tbpf_link_put(link);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_link_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tu32 id = attr->link_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_LINK_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tlink = bpf_link_by_id(id);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tfd = bpf_link_new_fd(link);\n\tif (fd < 0)\n\t\tbpf_link_put(link);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_update",
          "args": [
            "&attr"
          ],
          "line": 4707
        },
        "resolved": true,
        "details": {
          "function_name": "link_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4327-4376",
          "snippet": "static int link_update(union bpf_attr *attr)\n{\n\tstruct bpf_prog *old_prog = NULL, *new_prog;\n\tstruct bpf_link *link;\n\tu32 flags;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_UPDATE))\n\t\treturn -EINVAL;\n\n\tflags = attr->link_update.flags;\n\tif (flags & ~BPF_F_REPLACE)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_update.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tnew_prog = bpf_prog_get(attr->link_update.new_prog_fd);\n\tif (IS_ERR(new_prog)) {\n\t\tret = PTR_ERR(new_prog);\n\t\tgoto out_put_link;\n\t}\n\n\tif (flags & BPF_F_REPLACE) {\n\t\told_prog = bpf_prog_get(attr->link_update.old_prog_fd);\n\t\tif (IS_ERR(old_prog)) {\n\t\t\tret = PTR_ERR(old_prog);\n\t\t\told_prog = NULL;\n\t\t\tgoto out_put_progs;\n\t\t}\n\t} else if (attr->link_update.old_prog_fd) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_progs;\n\t}\n\n\tif (link->ops->update_prog)\n\t\tret = link->ops->update_prog(link, new_prog, old_prog);\n\telse\n\t\tret = -EINVAL;\n\nout_put_progs:\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tif (ret)\n\t\tbpf_prog_put(new_prog);\nout_put_link:\n\tbpf_link_put(link);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_update(union bpf_attr *attr)\n{\n\tstruct bpf_prog *old_prog = NULL, *new_prog;\n\tstruct bpf_link *link;\n\tu32 flags;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_UPDATE))\n\t\treturn -EINVAL;\n\n\tflags = attr->link_update.flags;\n\tif (flags & ~BPF_F_REPLACE)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_update.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tnew_prog = bpf_prog_get(attr->link_update.new_prog_fd);\n\tif (IS_ERR(new_prog)) {\n\t\tret = PTR_ERR(new_prog);\n\t\tgoto out_put_link;\n\t}\n\n\tif (flags & BPF_F_REPLACE) {\n\t\told_prog = bpf_prog_get(attr->link_update.old_prog_fd);\n\t\tif (IS_ERR(old_prog)) {\n\t\t\tret = PTR_ERR(old_prog);\n\t\t\told_prog = NULL;\n\t\t\tgoto out_put_progs;\n\t\t}\n\t} else if (attr->link_update.old_prog_fd) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_progs;\n\t}\n\n\tif (link->ops->update_prog)\n\t\tret = link->ops->update_prog(link, new_prog, old_prog);\n\telse\n\t\tret = -EINVAL;\n\nout_put_progs:\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tif (ret)\n\t\tbpf_prog_put(new_prog);\nout_put_link:\n\tbpf_link_put(link);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_create",
          "args": [
            "&attr",
            "uattr"
          ],
          "line": 4704
        },
        "resolved": true,
        "details": {
          "function_name": "link_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4246-4323",
          "snippet": "static int link_create(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_CREATE))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->link_create.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tret = bpf_prog_attach_check_attach_type(prog,\n\t\t\t\t\t\tattr->link_create.attach_type);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_EXT:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tgoto out;\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\t\tif (attr->link_create.attach_type != BPF_PERF_EVENT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tptype = prog->type;\n\t\tbreak;\n\tdefault:\n\t\tptype = attach_type_to_prog_type(attr->link_create.attach_type);\n\t\tif (ptype == BPF_PROG_TYPE_UNSPEC || ptype != prog->type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tret = cgroup_bpf_link_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tret = netns_bpf_link_create(attr, prog);\n\t\tbreak;\n#ifdef CONFIG_NET\n\tcase BPF_PROG_TYPE_XDP:\n\t\tret = bpf_xdp_link_attach(attr, prog);\n\t\tbreak;\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\t\tret = bpf_perf_link_attach(attr, prog);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_create(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_CREATE))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->link_create.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tret = bpf_prog_attach_check_attach_type(prog,\n\t\t\t\t\t\tattr->link_create.attach_type);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_EXT:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tgoto out;\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\t\tif (attr->link_create.attach_type != BPF_PERF_EVENT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tptype = prog->type;\n\t\tbreak;\n\tdefault:\n\t\tptype = attach_type_to_prog_type(attr->link_create.attach_type);\n\t\tif (ptype == BPF_PROG_TYPE_UNSPEC || ptype != prog->type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tret = cgroup_bpf_link_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tret = netns_bpf_link_create(attr, prog);\n\t\tbreak;\n#ifdef CONFIG_NET\n\tcase BPF_PROG_TYPE_XDP:\n\t\tret = bpf_xdp_link_attach(attr, prog);\n\t\tbreak;\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\t\tret = bpf_perf_link_attach(attr, prog);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_do_batch",
          "args": [
            "&attr",
            "uattr.user",
            "BPF_MAP_DELETE_BATCH"
          ],
          "line": 4701
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_do_batch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4185-4228",
          "snippet": "static int bpf_map_do_batch(const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr,\n\t\t\t    int cmd)\n{\n\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||\n\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;\n\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;\n\tstruct bpf_map *map;\n\tint err, ufd;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_BATCH))\n\t\treturn -EINVAL;\n\n\tufd = attr->batch.map_fd;\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (has_write)\n\t\tbpf_map_write_active_inc(map);\n\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (cmd == BPF_MAP_LOOKUP_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_batch);\n\telse if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);\n\telse if (cmd == BPF_MAP_UPDATE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_update_batch);\n\telse\n\t\tBPF_DO_BATCH(map->ops->map_delete_batch);\nerr_put:\n\tif (has_write)\n\t\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_do_batch(const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr,\n\t\t\t    int cmd)\n{\n\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||\n\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;\n\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;\n\tstruct bpf_map *map;\n\tint err, ufd;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_BATCH))\n\t\treturn -EINVAL;\n\n\tufd = attr->batch.map_fd;\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (has_write)\n\t\tbpf_map_write_active_inc(map);\n\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (cmd == BPF_MAP_LOOKUP_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_batch);\n\telse if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);\n\telse if (cmd == BPF_MAP_UPDATE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_update_batch);\n\telse\n\t\tBPF_DO_BATCH(map->ops->map_delete_batch);\nerr_put:\n\tif (has_write)\n\t\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_lookup_and_delete_elem",
          "args": [
            "&attr"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "map_lookup_and_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1529-1618",
          "snippet": "static int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||\n\t    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (attr->flags &&\n\t    (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t     map->map_type == BPF_MAP_TYPE_STACK)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -ENOTSUPP;\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\tif (!bpf_map_is_dev_bound(map)) {\n\t\t\tbpf_disable_instrumentation();\n\t\t\trcu_read_lock();\n\t\t\terr = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);\n\t\t\trcu_read_unlock();\n\t\t\tbpf_enable_instrumentation();\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0) {\n\t\terr = -EFAULT;\n\t\tgoto free_value;\n\t}\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||\n\t    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (attr->flags &&\n\t    (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t     map->map_type == BPF_MAP_TYPE_STACK)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -ENOTSUPP;\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\tif (!bpf_map_is_dev_bound(map)) {\n\t\t\tbpf_disable_instrumentation();\n\t\t\trcu_read_lock();\n\t\t\terr = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);\n\t\t\trcu_read_unlock();\n\t\t\tbpf_enable_instrumentation();\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0) {\n\t\terr = -EFAULT;\n\t\tgoto free_value;\n\t}\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_task_fd_query",
          "args": [
            "&attr",
            "uattr.user"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_fd_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4104-4172",
          "snippet": "static int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tfile = fget_task(task, fd);\n\tput_task_struct(task);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (file->f_op == &bpf_link_fops) {\n\t\tstruct bpf_link *link = file->private_data;\n\n\t\tif (link->ops == &bpf_raw_tp_link_lops) {\n\t\t\tstruct bpf_raw_tp_link *raw_tp =\n\t\t\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\t\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t\t     raw_tp->link.prog->aux->id,\n\t\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\t\tgoto put_file;\n\t\t}\n\t\tgoto out_not_supp;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\nout_not_supp:\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};",
            "static const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\nstatic const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};\n\nstatic int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tfile = fget_task(task, fd);\n\tput_task_struct(task);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (file->f_op == &bpf_link_fops) {\n\t\tstruct bpf_link *link = file->private_data;\n\n\t\tif (link->ops == &bpf_raw_tp_link_lops) {\n\t\t\tstruct bpf_raw_tp_link *raw_tp =\n\t\t\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\t\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t\t     raw_tp->link.prog->aux->id,\n\t\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\t\tgoto put_file;\n\t\t}\n\t\tgoto out_not_supp;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\nout_not_supp:\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_btf_get_fd_by_id",
          "args": [
            "&attr"
          ],
          "line": 4682
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4044-4053",
          "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_btf_load",
          "args": [
            "&attr",
            "uattr"
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4031-4040",
          "snippet": "static int bpf_btf_load(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr, uattr);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_load(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr, uattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_raw_tracepoint_open",
          "args": [
            "&attr"
          ],
          "line": 4676
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_raw_tracepoint_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3021-3108",
          "snippet": "static int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_raw_tp_link *link;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tconst char *tp_name;\n\tchar buf[128];\n\tint err;\n\n\tif (CHECK_ATTR(BPF_RAW_TRACEPOINT_OPEN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->raw_tracepoint.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_EXT:\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (attr->raw_tracepoint.name) {\n\t\t\t/* The attach point for this category of programs\n\t\t\t * should be specified via btf_id during program load.\n\t\t\t */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tif (prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog->expected_attach_type == BPF_TRACE_RAW_TP) {\n\t\t\ttp_name = prog->aux->attach_func_name;\n\t\t\tbreak;\n\t\t}\n\t\terr = bpf_tracing_prog_attach(prog, 0, 0);\n\t\tif (err >= 0)\n\t\t\treturn err;\n\t\tgoto out_put_prog;\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\t\tif (strncpy_from_user(buf,\n\t\t\t\t      u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t\t      sizeof(buf) - 1) < 0) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\ttp_name = buf;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tbtp = bpf_get_raw_tracepoint(tp_name);\n\tif (!btp) {\n\t\terr = -ENOENT;\n\t\tgoto out_put_prog;\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_btp;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_RAW_TRACEPOINT,\n\t\t      &bpf_raw_tp_link_lops, prog);\n\tlink->btp = btp;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_btp;\n\t}\n\n\terr = bpf_probe_register(link->btp, prog);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_btp;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_btp:\n\tbpf_put_raw_tracepoint(btp);\nout_put_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};\n\nstatic int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_raw_tp_link *link;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tconst char *tp_name;\n\tchar buf[128];\n\tint err;\n\n\tif (CHECK_ATTR(BPF_RAW_TRACEPOINT_OPEN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->raw_tracepoint.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_EXT:\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (attr->raw_tracepoint.name) {\n\t\t\t/* The attach point for this category of programs\n\t\t\t * should be specified via btf_id during program load.\n\t\t\t */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tif (prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog->expected_attach_type == BPF_TRACE_RAW_TP) {\n\t\t\ttp_name = prog->aux->attach_func_name;\n\t\t\tbreak;\n\t\t}\n\t\terr = bpf_tracing_prog_attach(prog, 0, 0);\n\t\tif (err >= 0)\n\t\t\treturn err;\n\t\tgoto out_put_prog;\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\t\tif (strncpy_from_user(buf,\n\t\t\t\t      u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t\t      sizeof(buf) - 1) < 0) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\ttp_name = buf;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tbtp = bpf_get_raw_tracepoint(tp_name);\n\tif (!btp) {\n\t\terr = -ENOENT;\n\t\tgoto out_put_prog;\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_btp;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_RAW_TRACEPOINT,\n\t\t      &bpf_raw_tp_link_lops, prog);\n\tlink->btp = btp;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_btp;\n\t}\n\n\terr = bpf_probe_register(link->btp, prog);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_btp;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_btp:\n\tbpf_put_raw_tracepoint(btp);\nout_put_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_get_info_by_fd",
          "args": [
            "&attr",
            "uattr.user"
          ],
          "line": 4673
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3997-4027",
          "snippet": "static int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file, f.file->private_data, attr, uattr);\n\telse if (f.file->f_op == &bpf_link_fops)\n\t\terr = bpf_link_get_info_by_fd(f.file, f.file->private_data,\n\t\t\t\t\t      attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};",
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};",
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file, f.file->private_data, attr, uattr);\n\telse if (f.file->f_op == &bpf_link_fops)\n\t\terr = bpf_link_get_info_by_fd(f.file, f.file->private_data,\n\t\t\t\t\t      attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_get_fd_by_id",
          "args": [
            "&attr"
          ],
          "line": 4670
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3466-3500",
          "snippet": "static int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
          ],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_fd_by_id",
          "args": [
            "&attr"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_test_run",
          "args": [
            "&attr",
            "uattr.user"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_test_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3328-3354",
          "snippet": "static int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_in && !attr->test.ctx_in) ||\n\t    (!attr->test.ctx_size_in && attr->test.ctx_in))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_out && !attr->test.ctx_out) ||\n\t    (!attr->test.ctx_size_out && attr->test.ctx_out))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_in && !attr->test.ctx_in) ||\n\t    (!attr->test.ctx_size_in && attr->test.ctx_in))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_out && !attr->test.ctx_out) ||\n\t    (!attr->test.ctx_size_out && attr->test.ctx_out))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_query",
          "args": [
            "&attr",
            "uattr.user"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3281-3324",
          "snippet": "static int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\tcase BPF_CGROUP_SYSCTL:\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn cgroup_bpf_prog_query(attr, uattr);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tcase BPF_FLOW_DISSECTOR:\n\tcase BPF_SK_LOOKUP:\n\t\treturn netns_bpf_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\tcase BPF_CGROUP_SYSCTL:\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn cgroup_bpf_prog_query(attr, uattr);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tcase BPF_FLOW_DISSECTOR:\n\tcase BPF_SK_LOOKUP:\n\t\treturn netns_bpf_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_detach",
          "args": [
            "&attr"
          ],
          "line": 4646
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3249-3277",
          "snippet": "static int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\t\treturn sock_map_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\treturn netns_bpf_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\treturn cgroup_bpf_prog_detach(attr, ptype);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\t\treturn sock_map_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\treturn netns_bpf_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\treturn cgroup_bpf_prog_detach(attr, ptype);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_attach",
          "args": [
            "&attr"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3193-3245",
          "snippet": "static int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\tif (ptype == BPF_PROG_TYPE_UNSPEC)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = netns_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI | BPF_F_REPLACE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI | BPF_F_REPLACE)\n\nstatic int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\tif (ptype == BPF_PROG_TYPE_UNSPEC)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = netns_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_get",
          "args": [
            "&attr"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2406-2414",
          "snippet": "static int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_pin",
          "args": [
            "&attr"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_pin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2398-2404",
          "snippet": "static int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_load",
          "args": [
            "&attr",
            "uattr"
          ],
          "line": 4634
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2204-2394",
          "snippet": "static int bpf_prog_load(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog, *dst_prog = NULL;\n\tstruct btf *attach_btf = NULL;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT |\n\t\t\t\t BPF_F_ANY_ALIGNMENT |\n\t\t\t\t BPF_F_TEST_STATE_FREQ |\n\t\t\t\t BPF_F_SLEEPABLE |\n\t\t\t\t BPF_F_TEST_RND_HI32))\n\t\treturn -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&\n\t    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_bpfptr(license,\n\t\t\t\tmake_bpfptr(attr->license, uattr.is_kernel),\n\t\t\t\tsizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 ||\n\t    attr->insn_cnt > (bpf_capable() ? BPF_COMPLEXITY_LIMIT_INSNS : BPF_MAXINSNS))\n\t\treturn -E2BIG;\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\tif (is_net_admin_prog_type(type) && !capable(CAP_NET_ADMIN) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (is_perfmon_prog_type(type) && !perfmon_capable())\n\t\treturn -EPERM;\n\n\t/* attach_prog_fd/attach_btf_obj_fd can specify fd of either bpf_prog\n\t * or btf, we need to check which one it is\n\t */\n\tif (attr->attach_prog_fd) {\n\t\tdst_prog = bpf_prog_get(attr->attach_prog_fd);\n\t\tif (IS_ERR(dst_prog)) {\n\t\t\tdst_prog = NULL;\n\t\t\tattach_btf = btf_get_by_fd(attr->attach_btf_obj_fd);\n\t\t\tif (IS_ERR(attach_btf))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!btf_is_kernel(attach_btf)) {\n\t\t\t\t/* attaching through specifying bpf_prog's BTF\n\t\t\t\t * objects directly might be supported eventually\n\t\t\t\t */\n\t\t\t\tbtf_put(attach_btf);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t}\n\t} else if (attr->attach_btf_id) {\n\t\t/* fall back to vmlinux BTF, if BTF type ID is specified */\n\t\tattach_btf = bpf_get_btf_vmlinux();\n\t\tif (IS_ERR(attach_btf))\n\t\t\treturn PTR_ERR(attach_btf);\n\t\tif (!attach_btf)\n\t\t\treturn -EINVAL;\n\t\tbtf_get(attach_btf);\n\t}\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach(type, attr->expected_attach_type,\n\t\t\t\t       attach_btf, attr->attach_btf_id,\n\t\t\t\t       dst_prog)) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -EINVAL;\n\t}\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -ENOMEM;\n\t}\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\tprog->aux->attach_btf = attach_btf;\n\tprog->aux->attach_btf_id = attr->attach_btf_id;\n\tprog->aux->dst_prog = dst_prog;\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\tprog->aux->sleepable = attr->prog_flags & BPF_F_SLEEPABLE;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog;\n\n\tprog->aux->user = get_current_user();\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(prog->insns,\n\t\t\t     make_bpfptr(attr->insns, uattr.is_kernel),\n\t\t\t     bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog_sec;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic64_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog_sec;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\tprog->aux->load_time = ktime_get_boottime_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,\n\t\t\t       sizeof(attr->prog_name));\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr, uattr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\t/* Upon success of bpf_prog_alloc_id(), the BPF prog is\n\t * effectively publicly exposed. However, retrieving via\n\t * bpf_prog_get_fd_by_id() will take another reference,\n\t * therefore it cannot be gone underneath us.\n\t *\n\t * Only for the time /after/ successful bpf_prog_new_fd()\n\t * and before returning to userspace, we might just hold\n\t * one reference and any parallel close on that fd could\n\t * rip everything out. Hence, below notifications must\n\t * happen before bpf_prog_new_fd().\n\t *\n\t * Also, any failure handling from this point onwards must\n\t * be using bpf_prog_put() given the program is exposed.\n\t */\n\tbpf_prog_kallsyms_add(prog);\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_LOAD);\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0)\n\t\tbpf_prog_put(prog);\n\treturn err;\n\nfree_used_maps:\n\t/* In case we have subprogs, we need to wait for a grace\n\t * period before we can tear down JIT memory since symbols\n\t * are already exposed under kallsyms.\n\t */\n\t__bpf_prog_put_noref(prog, prog->aux->func_cnt);\n\treturn err;\nfree_prog_sec:\n\tfree_uid(prog->aux->user);\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog:\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\tbpf_prog_free(prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_load(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog, *dst_prog = NULL;\n\tstruct btf *attach_btf = NULL;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT |\n\t\t\t\t BPF_F_ANY_ALIGNMENT |\n\t\t\t\t BPF_F_TEST_STATE_FREQ |\n\t\t\t\t BPF_F_SLEEPABLE |\n\t\t\t\t BPF_F_TEST_RND_HI32))\n\t\treturn -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&\n\t    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_bpfptr(license,\n\t\t\t\tmake_bpfptr(attr->license, uattr.is_kernel),\n\t\t\t\tsizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 ||\n\t    attr->insn_cnt > (bpf_capable() ? BPF_COMPLEXITY_LIMIT_INSNS : BPF_MAXINSNS))\n\t\treturn -E2BIG;\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\tif (is_net_admin_prog_type(type) && !capable(CAP_NET_ADMIN) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (is_perfmon_prog_type(type) && !perfmon_capable())\n\t\treturn -EPERM;\n\n\t/* attach_prog_fd/attach_btf_obj_fd can specify fd of either bpf_prog\n\t * or btf, we need to check which one it is\n\t */\n\tif (attr->attach_prog_fd) {\n\t\tdst_prog = bpf_prog_get(attr->attach_prog_fd);\n\t\tif (IS_ERR(dst_prog)) {\n\t\t\tdst_prog = NULL;\n\t\t\tattach_btf = btf_get_by_fd(attr->attach_btf_obj_fd);\n\t\t\tif (IS_ERR(attach_btf))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!btf_is_kernel(attach_btf)) {\n\t\t\t\t/* attaching through specifying bpf_prog's BTF\n\t\t\t\t * objects directly might be supported eventually\n\t\t\t\t */\n\t\t\t\tbtf_put(attach_btf);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t}\n\t} else if (attr->attach_btf_id) {\n\t\t/* fall back to vmlinux BTF, if BTF type ID is specified */\n\t\tattach_btf = bpf_get_btf_vmlinux();\n\t\tif (IS_ERR(attach_btf))\n\t\t\treturn PTR_ERR(attach_btf);\n\t\tif (!attach_btf)\n\t\t\treturn -EINVAL;\n\t\tbtf_get(attach_btf);\n\t}\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach(type, attr->expected_attach_type,\n\t\t\t\t       attach_btf, attr->attach_btf_id,\n\t\t\t\t       dst_prog)) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -EINVAL;\n\t}\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -ENOMEM;\n\t}\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\tprog->aux->attach_btf = attach_btf;\n\tprog->aux->attach_btf_id = attr->attach_btf_id;\n\tprog->aux->dst_prog = dst_prog;\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\tprog->aux->sleepable = attr->prog_flags & BPF_F_SLEEPABLE;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog;\n\n\tprog->aux->user = get_current_user();\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(prog->insns,\n\t\t\t     make_bpfptr(attr->insns, uattr.is_kernel),\n\t\t\t     bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog_sec;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic64_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog_sec;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\tprog->aux->load_time = ktime_get_boottime_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,\n\t\t\t       sizeof(attr->prog_name));\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr, uattr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\t/* Upon success of bpf_prog_alloc_id(), the BPF prog is\n\t * effectively publicly exposed. However, retrieving via\n\t * bpf_prog_get_fd_by_id() will take another reference,\n\t * therefore it cannot be gone underneath us.\n\t *\n\t * Only for the time /after/ successful bpf_prog_new_fd()\n\t * and before returning to userspace, we might just hold\n\t * one reference and any parallel close on that fd could\n\t * rip everything out. Hence, below notifications must\n\t * happen before bpf_prog_new_fd().\n\t *\n\t * Also, any failure handling from this point onwards must\n\t * be using bpf_prog_put() given the program is exposed.\n\t */\n\tbpf_prog_kallsyms_add(prog);\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_LOAD);\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0)\n\t\tbpf_prog_put(prog);\n\treturn err;\n\nfree_used_maps:\n\t/* In case we have subprogs, we need to wait for a grace\n\t * period before we can tear down JIT memory since symbols\n\t * are already exposed under kallsyms.\n\t */\n\t__bpf_prog_put_noref(prog, prog->aux->func_cnt);\n\treturn err;\nfree_prog_sec:\n\tfree_uid(prog->aux->user);\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog:\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\tbpf_prog_free(prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_freeze",
          "args": [
            "&attr"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "map_freeze",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1622-1661",
          "snippet": "static int map_freeze(const union bpf_attr *attr)\n{\n\tint err = 0, ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_FREEZE))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||\n\t    map_value_has_timer(map)) {\n\t\tfdput(f);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&map->freeze_mutex);\n\tif (bpf_map_write_active(map)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (READ_ONCE(map->frozen)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (!bpf_capable()) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tWRITE_ONCE(map->frozen, true);\nerr_put:\n\tmutex_unlock(&map->freeze_mutex);\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_freeze(const union bpf_attr *attr)\n{\n\tint err = 0, ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_FREEZE))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||\n\t    map_value_has_timer(map)) {\n\t\tfdput(f);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&map->freeze_mutex);\n\tif (bpf_map_write_active(map)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (READ_ONCE(map->frozen)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (!bpf_capable()) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tWRITE_ONCE(map->frozen, true);\nerr_put:\n\tmutex_unlock(&map->freeze_mutex);\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_get_next_key",
          "args": [
            "&attr"
          ],
          "line": 4628
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_next_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1250-1312",
          "snippet": "static int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kvmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkvfree(next_key);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kvmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkvfree(next_key);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_delete_elem",
          "args": [
            "&attr"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "map_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1195-1245",
          "snippet": "static int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t} else if (IS_FD_PROG_ARRAY(map) ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* These maps require sleepable context */\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tbpf_disable_instrumentation();\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t} else if (IS_FD_PROG_ARRAY(map) ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* These maps require sleepable context */\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tbpf_disable_instrumentation();\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_update_elem",
          "args": [
            "&attr",
            "uattr"
          ],
          "line": 4622
        },
        "resolved": true,
        "details": {
          "function_name": "map_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1134-1191",
          "snippet": "static int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tbpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);\n\tbpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = ___bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = bpf_map_update_value(map, f, key, value, attr->flags);\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tbpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);\n\tbpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = ___bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = bpf_map_update_value(map, f, key, value, attr->flags);\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_lookup_elem",
          "args": [
            "&attr"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1059-1129",
          "snippet": "static int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\tif (copy_from_user(value, uvalue, value_size))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\t\tgoto free_value;\n\t}\n\n\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\tif (copy_from_user(value, uvalue, value_size))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\t\tgoto free_value;\n\t}\n\n\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_create",
          "args": [
            "&attr"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "map_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "832-945",
          "snippet": "static int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type != BPF_MAP_TYPE_BLOOM_FILTER &&\n\t    attr->map_extra != 0)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tmap->timer_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tif (btf_is_kernel(btf)) {\n\t\t\tbtf_put(btf);\n\t\t\terr = -EACCES;\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type != BPF_MAP_TYPE_BLOOM_FILTER &&\n\t    attr->map_extra != 0)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tmap->timer_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tif (btf_is_kernel(btf)) {\n\t\t\tbtf_put(btf);\n\t\t\terr = -EACCES;\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf",
          "args": [
            "cmd",
            "&attr",
            "size"
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_bpfptr",
          "args": [
            "&attr",
            "uattr",
            "size"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&attr",
            "0",
            "sizeof(attr)"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "size",
            "sizeof(attr)"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "uattr",
            "sizeof(attr)",
            "size"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\nint sysctl_unprivileged_bpf_disabled;\n\nstatic int __sys_bpf(int cmd, bpfptr_t uattr, unsigned int size)\n{\n\tunion bpf_attr attr;\n\tint err;\n\n\tif (sysctl_unprivileged_bpf_disabled && !bpf_capable())\n\t\treturn -EPERM;\n\n\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);\n\tif (err)\n\t\treturn err;\n\tsize = min_t(u32, size, sizeof(attr));\n\n\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */\n\tmemset(&attr, 0, sizeof(attr));\n\tif (copy_from_bpfptr(&attr, uattr, size) != 0)\n\t\treturn -EFAULT;\n\n\terr = security_bpf(cmd, &attr, size);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_ELEM:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_ELEM:\n\t\terr = map_update_elem(&attr, uattr);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_ELEM:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_KEY:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase BPF_MAP_FREEZE:\n\t\terr = map_freeze(&attr);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\terr = bpf_prog_load(&attr, uattr);\n\t\tbreak;\n\tcase BPF_OBJ_PIN:\n\t\terr = bpf_obj_pin(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET:\n\t\terr = bpf_obj_get(&attr);\n\t\tbreak;\n\tcase BPF_PROG_ATTACH:\n\t\terr = bpf_prog_attach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_DETACH:\n\t\terr = bpf_prog_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_QUERY:\n\t\terr = bpf_prog_query(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_PROG_TEST_RUN:\n\t\terr = bpf_prog_test_run(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_PROG_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &prog_idr, &prog_idr_lock);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &map_idr, &map_idr_lock);\n\t\tbreak;\n\tcase BPF_BTF_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &btf_idr, &btf_idr_lock);\n\t\tbreak;\n\tcase BPF_PROG_GET_FD_BY_ID:\n\t\terr = bpf_prog_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_FD_BY_ID:\n\t\terr = bpf_map_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET_INFO_BY_FD:\n\t\terr = bpf_obj_get_info_by_fd(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_RAW_TRACEPOINT_OPEN:\n\t\terr = bpf_raw_tracepoint_open(&attr);\n\t\tbreak;\n\tcase BPF_BTF_LOAD:\n\t\terr = bpf_btf_load(&attr, uattr);\n\t\tbreak;\n\tcase BPF_BTF_GET_FD_BY_ID:\n\t\terr = bpf_btf_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_TASK_FD_QUERY:\n\t\terr = bpf_task_fd_query(&attr, uattr.user);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:\n\t\terr = map_lookup_and_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_LOOKUP_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user,\n\t\t\t\t       BPF_MAP_LOOKUP_AND_DELETE_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_UPDATE_BATCH);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_BATCH:\n\t\terr = bpf_map_do_batch(&attr, uattr.user, BPF_MAP_DELETE_BATCH);\n\t\tbreak;\n\tcase BPF_LINK_CREATE:\n\t\terr = link_create(&attr, uattr);\n\t\tbreak;\n\tcase BPF_LINK_UPDATE:\n\t\terr = link_update(&attr);\n\t\tbreak;\n\tcase BPF_LINK_GET_FD_BY_ID:\n\t\terr = bpf_link_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_LINK_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr.user,\n\t\t\t\t\t  &link_idr, &link_idr_lock);\n\t\tbreak;\n\tcase BPF_ENABLE_STATS:\n\t\terr = bpf_enable_stats(&attr);\n\t\tbreak;\n\tcase BPF_ITER_CREATE:\n\t\terr = bpf_iter_create(&attr);\n\t\tbreak;\n\tcase BPF_LINK_DETACH:\n\t\terr = link_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_BIND_MAP:\n\t\terr = bpf_prog_bind_map(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_prog_bind_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4532-4590",
    "snippet": "static int bpf_prog_bind_map(union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tstruct bpf_map **used_maps_old, **used_maps_new;\n\tint i, ret = 0;\n\n\tif (CHECK_ATTR(BPF_PROG_BIND_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_bind_map.flags)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->prog_bind_map.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmap = bpf_map_get(attr->prog_bind_map.map_fd);\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tgoto out_prog_put;\n\t}\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\n\tused_maps_old = prog->aux->used_maps;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (used_maps_old[i] == map) {\n\t\t\tbpf_map_put(map);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\tused_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,\n\t\t\t\t      sizeof(used_maps_new[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!used_maps_new) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(used_maps_new, used_maps_old,\n\t       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);\n\tused_maps_new[prog->aux->used_map_cnt] = map;\n\n\tprog->aux->used_map_cnt++;\n\tprog->aux->used_maps = used_maps_new;\n\n\tkfree(used_maps_old);\n\nout_unlock:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\tif (ret)\n\t\tbpf_map_put(map);\nout_prog_put:\n\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 4588
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "used_maps_old"
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "used_maps_new",
            "used_maps_old",
            "sizeof(used_maps_old[0]) * prog->aux->used_map_cnt"
          ],
          "line": 4573
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "prog->aux->used_map_cnt + 1",
            "sizeof(used_maps_new[0])",
            "GFP_KERNEL"
          ],
          "line": 4565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 4555
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_get",
          "args": [
            "attr->prog_bind_map.map_fd"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3466-3500",
          "snippet": "static int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
          ],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->prog_bind_map.prog_fd"
          ],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_BIND_MAP"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_bind_map(union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tstruct bpf_map **used_maps_old, **used_maps_new;\n\tint i, ret = 0;\n\n\tif (CHECK_ATTR(BPF_PROG_BIND_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_bind_map.flags)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->prog_bind_map.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmap = bpf_map_get(attr->prog_bind_map.map_fd);\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tgoto out_prog_put;\n\t}\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\n\tused_maps_old = prog->aux->used_maps;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (used_maps_old[i] == map) {\n\t\t\tbpf_map_put(map);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\tused_maps_new = kmalloc_array(prog->aux->used_map_cnt + 1,\n\t\t\t\t      sizeof(used_maps_new[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!used_maps_new) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(used_maps_new, used_maps_old,\n\t       sizeof(used_maps_old[0]) * prog->aux->used_map_cnt);\n\tused_maps_new[prog->aux->used_map_cnt] = map;\n\n\tprog->aux->used_map_cnt++;\n\tprog->aux->used_maps = used_maps_new;\n\n\tkfree(used_maps_old);\n\nout_unlock:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\tif (ret)\n\t\tbpf_map_put(map);\nout_prog_put:\n\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_iter_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4509-4528",
    "snippet": "static int bpf_iter_create(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_ITER_CREATE))\n\t\treturn -EINVAL;\n\n\tif (attr->iter_create.flags)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->iter_create.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\terr = bpf_iter_new_fd(link);\n\tbpf_link_put(link);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "link"
          ],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_new_fd",
          "args": [
            "link"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "624-658",
          "snippet": "int bpf_iter_new_fd(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link;\n\tstruct file *file;\n\tunsigned int flags;\n\tint err, fd;\n\n\tif (link->ops != &bpf_iter_link_lops)\n\t\treturn -EINVAL;\n\n\tflags = O_RDONLY | O_CLOEXEC;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto free_fd;\n\t}\n\n\titer_link = container_of(link, struct bpf_iter_link, link);\n\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));\n\tif (err)\n\t\tgoto free_file;\n\n\tfd_install(fd, file);\n\treturn fd;\n\nfree_file:\n\tfput(file);\nfree_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};",
            "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nint bpf_iter_new_fd(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link;\n\tstruct file *file;\n\tunsigned int flags;\n\tint err, fd;\n\n\tif (link->ops != &bpf_iter_link_lops)\n\t\treturn -EINVAL;\n\n\tflags = O_RDONLY | O_CLOEXEC;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto free_fd;\n\t}\n\n\titer_link = container_of(link, struct bpf_iter_link, link);\n\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));\n\tif (err)\n\t\tgoto free_file;\n\n\tfd_install(fd, file);\n\treturn fd;\n\nfree_file:\n\tfput(file);\nfree_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "link"
          ],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_get_from_fd",
          "args": [
            "attr->iter_create.link_fd"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2615-2632",
          "snippet": "struct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_ITER_CREATE"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_iter_create(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_ITER_CREATE))\n\t\treturn -EINVAL;\n\n\tif (attr->iter_create.flags)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->iter_create.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\terr = bpf_iter_new_fd(link);\n\tbpf_link_put(link);\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_enable_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4489-4505",
    "snippet": "static int bpf_enable_stats(union bpf_attr *attr)\n{\n\n\tif (CHECK_ATTR(BPF_ENABLE_STATS))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (attr->enable_stats.type) {\n\tcase BPF_STATS_RUN_TIME:\n\t\treturn bpf_enable_runtime_stats();\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_enable_runtime_stats",
          "args": [],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_enable_runtime_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4467-4485",
          "snippet": "static int bpf_enable_runtime_stats(void)\n{\n\tint fd;\n\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\n\t/* Set a very high limit to avoid overflow */\n\tif (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {\n\t\tmutex_unlock(&bpf_stats_enabled_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfd = anon_inode_getfd(\"bpf-stats\", &bpf_stats_fops, NULL, O_CLOEXEC);\n\tif (fd >= 0)\n\t\tstatic_key_slow_inc(&bpf_stats_enabled_key.key);\n\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_stats_fops = {\n\t.release = bpf_stats_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_stats_fops = {\n\t.release = bpf_stats_release,\n};\n\nstatic int bpf_enable_runtime_stats(void)\n{\n\tint fd;\n\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\n\t/* Set a very high limit to avoid overflow */\n\tif (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {\n\t\tmutex_unlock(&bpf_stats_enabled_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfd = anon_inode_getfd(\"bpf-stats\", &bpf_stats_fops, NULL, O_CLOEXEC);\n\tif (fd >= 0)\n\t\tstatic_key_slow_inc(&bpf_stats_enabled_key.key);\n\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_ENABLE_STATS"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_enable_stats(union bpf_attr *attr)\n{\n\n\tif (CHECK_ATTR(BPF_ENABLE_STATS))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (attr->enable_stats.type) {\n\tcase BPF_STATS_RUN_TIME:\n\t\treturn bpf_enable_runtime_stats();\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_enable_runtime_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4467-4485",
    "snippet": "static int bpf_enable_runtime_stats(void)\n{\n\tint fd;\n\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\n\t/* Set a very high limit to avoid overflow */\n\tif (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {\n\t\tmutex_unlock(&bpf_stats_enabled_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfd = anon_inode_getfd(\"bpf-stats\", &bpf_stats_fops, NULL, O_CLOEXEC);\n\tif (fd >= 0)\n\t\tstatic_key_slow_inc(&bpf_stats_enabled_key.key);\n\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn fd;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_stats_fops = {\n\t.release = bpf_stats_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_stats_enabled_mutex"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&bpf_stats_enabled_key.key"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_slow_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "156-161",
          "snippet": "void static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nvoid static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-stats\"",
            "&bpf_stats_fops",
            "NULL",
            "O_CLOEXEC"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_count",
          "args": [
            "&bpf_stats_enabled_key.key"
          ],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "104-113",
          "snippet": "int static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nint static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_stats_enabled_mutex"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_stats_fops = {\n\t.release = bpf_stats_release,\n};\n\nstatic int bpf_enable_runtime_stats(void)\n{\n\tint fd;\n\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\n\t/* Set a very high limit to avoid overflow */\n\tif (static_key_count(&bpf_stats_enabled_key.key) > INT_MAX / 2) {\n\t\tmutex_unlock(&bpf_stats_enabled_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfd = anon_inode_getfd(\"bpf-stats\", &bpf_stats_fops, NULL, O_CLOEXEC);\n\tif (fd >= 0)\n\t\tstatic_key_slow_inc(&bpf_stats_enabled_key.key);\n\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_stats_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4455-4461",
    "snippet": "static int bpf_stats_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\tstatic_key_slow_dec(&bpf_stats_enabled_key.key);\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_stats_enabled_mutex"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec",
          "args": [
            "&bpf_stats_enabled_key.key"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_slow_dec_cpuslocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "274-278",
          "snippet": "void static_key_slow_dec_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec_cpuslocked(key);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nvoid static_key_slow_dec_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec_cpuslocked(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_stats_enabled_mutex"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_stats_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&bpf_stats_enabled_mutex);\n\tstatic_key_slow_dec(&bpf_stats_enabled_key.key);\n\tmutex_unlock(&bpf_stats_enabled_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_link_get_fd_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4430-4451",
    "snippet": "static int bpf_link_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tu32 id = attr->link_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_LINK_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tlink = bpf_link_by_id(id);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tfd = bpf_link_new_fd(link);\n\tif (fd < 0)\n\t\tbpf_link_put(link);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "link"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_new_fd",
          "args": [
            "link"
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2610-2613",
          "snippet": "int bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "link"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_by_id",
          "args": [
            "id"
          ],
          "line": 4442
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4406-4426",
          "snippet": "struct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstruct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_LINK_GET_FD_BY_ID"
          ],
          "line": 4436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_link_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tu32 id = attr->link_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_LINK_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tlink = bpf_link_by_id(id);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tfd = bpf_link_new_fd(link);\n\tif (fd < 0)\n\t\tbpf_link_put(link);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_link_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4406-4426",
    "snippet": "struct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(link_idr);",
      "static DEFINE_SPINLOCK(link_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_inc_not_zero",
          "args": [
            "link"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4401-4404",
          "snippet": "static struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&link_idr",
            "id"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 4413
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstruct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}"
  },
  {
    "function_name": "bpf_link_inc_not_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4401-4404",
    "snippet": "static struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_fetch_add_unless",
          "args": [
            "&link->refcnt",
            "1",
            "0"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}"
  },
  {
    "function_name": "link_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4380-4399",
    "snippet": "static int link_detach(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_DETACH))\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_detach.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (link->ops->detach)\n\t\tret = link->ops->detach(link);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\tbpf_link_put(link);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "link"
          ],
          "line": 4397
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "link->ops->detach",
          "args": [
            "link"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "link"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_get_from_fd",
          "args": [
            "attr->link_detach.link_fd"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2615-2632",
          "snippet": "struct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_LINK_DETACH"
          ],
          "line": 4385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_detach(union bpf_attr *attr)\n{\n\tstruct bpf_link *link;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_DETACH))\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_detach.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (link->ops->detach)\n\t\tret = link->ops->detach(link);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\tbpf_link_put(link);\n\treturn ret;\n}"
  },
  {
    "function_name": "link_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4327-4376",
    "snippet": "static int link_update(union bpf_attr *attr)\n{\n\tstruct bpf_prog *old_prog = NULL, *new_prog;\n\tstruct bpf_link *link;\n\tu32 flags;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_UPDATE))\n\t\treturn -EINVAL;\n\n\tflags = attr->link_update.flags;\n\tif (flags & ~BPF_F_REPLACE)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_update.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tnew_prog = bpf_prog_get(attr->link_update.new_prog_fd);\n\tif (IS_ERR(new_prog)) {\n\t\tret = PTR_ERR(new_prog);\n\t\tgoto out_put_link;\n\t}\n\n\tif (flags & BPF_F_REPLACE) {\n\t\told_prog = bpf_prog_get(attr->link_update.old_prog_fd);\n\t\tif (IS_ERR(old_prog)) {\n\t\t\tret = PTR_ERR(old_prog);\n\t\t\told_prog = NULL;\n\t\t\tgoto out_put_progs;\n\t\t}\n\t} else if (attr->link_update.old_prog_fd) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_progs;\n\t}\n\n\tif (link->ops->update_prog)\n\t\tret = link->ops->update_prog(link, new_prog, old_prog);\n\telse\n\t\tret = -EINVAL;\n\nout_put_progs:\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tif (ret)\n\t\tbpf_prog_put(new_prog);\nout_put_link:\n\tbpf_link_put(link);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "link"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "new_prog"
          ],
          "line": 4372
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link->ops->update_prog",
          "args": [
            "link",
            "new_prog",
            "old_prog"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old_prog"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old_prog"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->link_update.old_prog_fd"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_prog"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_prog"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "link"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_get_from_fd",
          "args": [
            "attr->link_update.link_fd"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2615-2632",
          "snippet": "struct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_LINK_UPDATE"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_update(union bpf_attr *attr)\n{\n\tstruct bpf_prog *old_prog = NULL, *new_prog;\n\tstruct bpf_link *link;\n\tu32 flags;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_UPDATE))\n\t\treturn -EINVAL;\n\n\tflags = attr->link_update.flags;\n\tif (flags & ~BPF_F_REPLACE)\n\t\treturn -EINVAL;\n\n\tlink = bpf_link_get_from_fd(attr->link_update.link_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tnew_prog = bpf_prog_get(attr->link_update.new_prog_fd);\n\tif (IS_ERR(new_prog)) {\n\t\tret = PTR_ERR(new_prog);\n\t\tgoto out_put_link;\n\t}\n\n\tif (flags & BPF_F_REPLACE) {\n\t\told_prog = bpf_prog_get(attr->link_update.old_prog_fd);\n\t\tif (IS_ERR(old_prog)) {\n\t\t\tret = PTR_ERR(old_prog);\n\t\t\told_prog = NULL;\n\t\t\tgoto out_put_progs;\n\t\t}\n\t} else if (attr->link_update.old_prog_fd) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_progs;\n\t}\n\n\tif (link->ops->update_prog)\n\t\tret = link->ops->update_prog(link, new_prog, old_prog);\n\telse\n\t\tret = -EINVAL;\n\nout_put_progs:\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\tif (ret)\n\t\tbpf_prog_put(new_prog);\nout_put_link:\n\tbpf_link_put(link);\n\treturn ret;\n}"
  },
  {
    "function_name": "link_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4246-4323",
    "snippet": "static int link_create(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_CREATE))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->link_create.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tret = bpf_prog_attach_check_attach_type(prog,\n\t\t\t\t\t\tattr->link_create.attach_type);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_EXT:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tgoto out;\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\t\tif (attr->link_create.attach_type != BPF_PERF_EVENT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tptype = prog->type;\n\t\tbreak;\n\tdefault:\n\t\tptype = attach_type_to_prog_type(attr->link_create.attach_type);\n\t\tif (ptype == BPF_PROG_TYPE_UNSPEC || ptype != prog->type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tret = cgroup_bpf_link_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tret = netns_bpf_link_create(attr, prog);\n\t\tbreak;\n#ifdef CONFIG_NET\n\tcase BPF_PROG_TYPE_XDP:\n\t\tret = bpf_xdp_link_attach(attr, prog);\n\t\tbreak;\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\t\tret = bpf_perf_link_attach(attr, prog);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_perf_link_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_perf_link_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2973-3016",
          "snippet": "static int bpf_perf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_perf_link *link;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tperf_file = perf_event_get(attr->link_create.target_fd);\n\tif (IS_ERR(perf_file))\n\t\treturn PTR_ERR(perf_file);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_file;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_PERF_EVENT, &bpf_perf_link_lops, prog);\n\tlink->perf_file = perf_file;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_file;\n\t}\n\n\tevent = perf_file->private_data;\n\terr = perf_event_set_bpf_prog(event, prog, attr->link_create.perf_event.bpf_cookie);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_file;\n\t}\n\t/* perf_event_set_bpf_prog() doesn't take its own refcnt on prog */\n\tbpf_prog_inc(prog);\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_file:\n\tfput(perf_file);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_perf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_perf_link *link;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tperf_file = perf_event_get(attr->link_create.target_fd);\n\tif (IS_ERR(perf_file))\n\t\treturn PTR_ERR(perf_file);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_file;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_PERF_EVENT, &bpf_perf_link_lops, prog);\n\tlink->perf_file = perf_file;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_file;\n\t}\n\n\tevent = perf_file->private_data;\n\terr = perf_event_set_bpf_prog(event, prog, attr->link_create.perf_event.bpf_cookie);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_file;\n\t}\n\t/* perf_event_set_bpf_prog() doesn't take its own refcnt on prog */\n\tbpf_prog_inc(prog);\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_file:\n\tfput(perf_file);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_xdp_link_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns_bpf_link_create",
          "args": [
            "attr",
            "prog"
          ],
          "line": 4301
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_link_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "477-527",
          "snippet": "int netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type netns_type;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_netns_link *net_link;\n\tenum bpf_attach_type type;\n\tstruct net *net;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\ttype = attr->link_create.attach_type;\n\tnetns_type = to_netns_bpf_attach_type(type);\n\tif (netns_type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->link_create.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);\n\tif (!net_link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_net;\n\t}\n\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,\n\t\t      &bpf_netns_link_ops, prog);\n\tnet_link->net = net;\n\tnet_link->type = type;\n\tnet_link->netns_type = netns_type;\n\n\terr = bpf_link_prime(&net_link->link, &link_primer);\n\tif (err) {\n\t\tkfree(net_link);\n\t\tgoto out_put_net;\n\t}\n\n\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_net;\n\t}\n\n\tput_net(net);\n\treturn bpf_link_settle(&link_primer);\n\nout_put_net:\n\tput_net(net);\n\treturn err;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_netns_link_ops = {\n\t.release = bpf_netns_link_release,\n\t.dealloc = bpf_netns_link_dealloc,\n\t.detach = bpf_netns_link_detach,\n\t.update_prog = bpf_netns_link_update_prog,\n\t.fill_link_info = bpf_netns_link_fill_info,\n\t.show_fdinfo = bpf_netns_link_show_fdinfo,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_netns_link_ops = {\n\t.release = bpf_netns_link_release,\n\t.dealloc = bpf_netns_link_dealloc,\n\t.detach = bpf_netns_link_detach,\n\t.update_prog = bpf_netns_link_update_prog,\n\t.fill_link_info = bpf_netns_link_fill_info,\n\t.show_fdinfo = bpf_netns_link_show_fdinfo,\n};\n\nint netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type netns_type;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_netns_link *net_link;\n\tenum bpf_attach_type type;\n\tstruct net *net;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\ttype = attr->link_create.attach_type;\n\tnetns_type = to_netns_bpf_attach_type(type);\n\tif (netns_type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->link_create.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);\n\tif (!net_link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_net;\n\t}\n\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,\n\t\t      &bpf_netns_link_ops, prog);\n\tnet_link->net = net;\n\tnet_link->type = type;\n\tnet_link->netns_type = netns_type;\n\n\terr = bpf_link_prime(&net_link->link, &link_primer);\n\tif (err) {\n\t\tkfree(net_link);\n\t\tgoto out_put_net;\n\t}\n\n\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_net;\n\t}\n\n\tput_net(net);\n\treturn bpf_link_settle(&link_primer);\n\nout_put_net:\n\tput_net(net);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_bpf_link_attach",
          "args": [
            "attr",
            "uattr",
            "prog"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_bpf_link_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4230-4243",
          "snippet": "static int tracing_bpf_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t\t   struct bpf_prog *prog)\n{\n\tif (attr->link_create.attach_type != prog->expected_attach_type)\n\t\treturn -EINVAL;\n\n\tif (prog->expected_attach_type == BPF_TRACE_ITER)\n\t\treturn bpf_iter_link_attach(attr, uattr, prog);\n\telse if (prog->type == BPF_PROG_TYPE_EXT)\n\t\treturn bpf_tracing_prog_attach(prog,\n\t\t\t\t\t       attr->link_create.target_fd,\n\t\t\t\t\t       attr->link_create.target_btf_id);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int tracing_bpf_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t\t   struct bpf_prog *prog)\n{\n\tif (attr->link_create.attach_type != prog->expected_attach_type)\n\t\treturn -EINVAL;\n\n\tif (prog->expected_attach_type == BPF_TRACE_ITER)\n\t\treturn bpf_iter_link_attach(attr, uattr, prog);\n\telse if (prog->type == BPF_PROG_TYPE_EXT)\n\t\treturn bpf_tracing_prog_attach(prog,\n\t\t\t\t\t       attr->link_create.target_fd,\n\t\t\t\t\t       attr->link_create.target_btf_id);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_link_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_link_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "970-1012",
          "snippet": "int cgroup_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_cgroup_link *link;\n\tstruct cgroup *cgrp;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_get_from_fd(attr->link_create.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_cgroup;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_CGROUP, &bpf_cgroup_link_lops,\n\t\t      prog);\n\tlink->cgroup = cgrp;\n\tlink->type = attr->link_create.attach_type;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_cgroup;\n\t}\n\n\terr = cgroup_bpf_attach(cgrp, NULL, NULL, link,\n\t\t\t\tlink->type, BPF_F_ALLOW_MULTI);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_cgroup;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_cgroup:\n\tcgroup_put(cgrp);\n\treturn err;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_cgroup_link_lops = {\n\t.release = bpf_cgroup_link_release,\n\t.dealloc = bpf_cgroup_link_dealloc,\n\t.detach = bpf_cgroup_link_detach,\n\t.update_prog = cgroup_bpf_replace,\n\t.show_fdinfo = bpf_cgroup_link_show_fdinfo,\n\t.fill_link_info = bpf_cgroup_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_link_ops bpf_cgroup_link_lops = {\n\t.release = bpf_cgroup_link_release,\n\t.dealloc = bpf_cgroup_link_dealloc,\n\t.detach = bpf_cgroup_link_detach,\n\t.update_prog = cgroup_bpf_replace,\n\t.show_fdinfo = bpf_cgroup_link_show_fdinfo,\n\t.fill_link_info = bpf_cgroup_link_fill_link_info,\n};\n\nint cgroup_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_cgroup_link *link;\n\tstruct cgroup *cgrp;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tcgrp = cgroup_get_from_fd(attr->link_create.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_cgroup;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_CGROUP, &bpf_cgroup_link_lops,\n\t\t      prog);\n\tlink->cgroup = cgrp;\n\tlink->type = attr->link_create.attach_type;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_cgroup;\n\t}\n\n\terr = cgroup_bpf_attach(cgrp, NULL, NULL, link,\n\t\t\t\tlink->type, BPF_F_ALLOW_MULTI);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_cgroup;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_cgroup:\n\tcgroup_put(cgrp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_type_to_prog_type",
          "args": [
            "attr->link_create.attach_type"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_to_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3133-3186",
          "snippet": "static enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_attach_check_attach_type",
          "args": [
            "prog",
            "attr->link_create.attach_type"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_attach_check_attach_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3110-3131",
          "snippet": "static int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 4256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->link_create.prog_fd"
          ],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_LINK_CREATE"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int link_create(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_LINK_CREATE))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->link_create.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tret = bpf_prog_attach_check_attach_type(prog,\n\t\t\t\t\t\tattr->link_create.attach_type);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_EXT:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tgoto out;\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\t\tif (attr->link_create.attach_type != BPF_PERF_EVENT) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tptype = prog->type;\n\t\tbreak;\n\tdefault:\n\t\tptype = attach_type_to_prog_type(attr->link_create.attach_type);\n\t\tif (ptype == BPF_PROG_TYPE_UNSPEC || ptype != prog->type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tret = cgroup_bpf_link_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tret = tracing_bpf_link_attach(attr, uattr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tret = netns_bpf_link_create(attr, prog);\n\t\tbreak;\n#ifdef CONFIG_NET\n\tcase BPF_PROG_TYPE_XDP:\n\t\tret = bpf_xdp_link_attach(attr, prog);\n\t\tbreak;\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_KPROBE:\n\t\tret = bpf_perf_link_attach(attr, prog);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracing_bpf_link_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4230-4243",
    "snippet": "static int tracing_bpf_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t\t   struct bpf_prog *prog)\n{\n\tif (attr->link_create.attach_type != prog->expected_attach_type)\n\t\treturn -EINVAL;\n\n\tif (prog->expected_attach_type == BPF_TRACE_ITER)\n\t\treturn bpf_iter_link_attach(attr, uattr, prog);\n\telse if (prog->type == BPF_PROG_TYPE_EXT)\n\t\treturn bpf_tracing_prog_attach(prog,\n\t\t\t\t\t       attr->link_create.target_fd,\n\t\t\t\t\t       attr->link_create.target_btf_id);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_tracing_prog_attach",
          "args": [
            "prog",
            "attr->link_create.target_fd",
            "attr->link_create.target_btf_id"
          ],
          "line": 4239
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_tracing_prog_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2696-2870",
          "snippet": "static int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};\n\nstatic int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_link_attach",
          "args": [
            "attr",
            "uattr",
            "prog"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_link_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "498-564",
          "snippet": "int bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_iter_target_info *tinfo;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_iter_link *link;\n\tu32 prog_btf_id, linfo_len;\n\tbool existed = false;\n\tbpfptr_t ulinfo;\n\tint err;\n\n\tif (attr->link_create.target_fd || attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));\n\n\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);\n\tlinfo_len = attr->link_create.iter_info_len;\n\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)\n\t\treturn -EINVAL;\n\n\tif (!bpfptr_is_null(ulinfo)) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),\n\t\t\t\t\t       linfo_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));\n\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tprog_btf_id = prog->aux->attach_btf_id;\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog_btf_id) {\n\t\t\texisted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\tif (!existed)\n\t\treturn -ENOENT;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);\n\tlink->tinfo = tinfo;\n\n\terr  = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (tinfo->reg_info->attach_target) {\n\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head targets = LIST_HEAD_INIT(targets);",
            "static DEFINE_MUTEX(targets_mutex);",
            "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nint bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_iter_target_info *tinfo;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_iter_link *link;\n\tu32 prog_btf_id, linfo_len;\n\tbool existed = false;\n\tbpfptr_t ulinfo;\n\tint err;\n\n\tif (attr->link_create.target_fd || attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));\n\n\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);\n\tlinfo_len = attr->link_create.iter_info_len;\n\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)\n\t\treturn -EINVAL;\n\n\tif (!bpfptr_is_null(ulinfo)) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),\n\t\t\t\t\t       linfo_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));\n\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tprog_btf_id = prog->aux->attach_btf_id;\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog_btf_id) {\n\t\t\texisted = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\tif (!existed)\n\t\treturn -ENOENT;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);\n\tlink->tinfo = tinfo;\n\n\terr  = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (tinfo->reg_info->attach_target) {\n\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int tracing_bpf_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t\t   struct bpf_prog *prog)\n{\n\tif (attr->link_create.attach_type != prog->expected_attach_type)\n\t\treturn -EINVAL;\n\n\tif (prog->expected_attach_type == BPF_TRACE_ITER)\n\t\treturn bpf_iter_link_attach(attr, uattr, prog);\n\telse if (prog->type == BPF_PROG_TYPE_EXT)\n\t\treturn bpf_tracing_prog_attach(prog,\n\t\t\t\t\t       attr->link_create.target_fd,\n\t\t\t\t\t       attr->link_create.target_btf_id);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_map_do_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4185-4228",
    "snippet": "static int bpf_map_do_batch(const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr,\n\t\t\t    int cmd)\n{\n\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||\n\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;\n\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;\n\tstruct bpf_map *map;\n\tint err, ufd;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_BATCH))\n\t\treturn -EINVAL;\n\n\tufd = attr->batch.map_fd;\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (has_write)\n\t\tbpf_map_write_active_inc(map);\n\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (cmd == BPF_MAP_LOOKUP_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_batch);\n\telse if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);\n\telse if (cmd == BPF_MAP_UPDATE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_update_batch);\n\telse\n\t\tBPF_DO_BATCH(map->ops->map_delete_batch);\nerr_put:\n\tif (has_write)\n\t\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_dec",
          "args": [
            "map"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "141-144",
          "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_DO_BATCH",
          "args": [
            "map->ops->map_delete_batch"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_DO_BATCH",
          "args": [
            "map->ops->map_update_batch"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_DO_BATCH",
          "args": [
            "map->ops->map_lookup_and_delete_batch"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_DO_BATCH",
          "args": [
            "map->ops->map_lookup_batch"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_BATCH"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_do_batch(const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr,\n\t\t\t    int cmd)\n{\n\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||\n\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;\n\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;\n\tstruct bpf_map *map;\n\tint err, ufd;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_BATCH))\n\t\treturn -EINVAL;\n\n\tufd = attr->batch.map_fd;\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (has_write)\n\t\tbpf_map_write_active_inc(map);\n\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (cmd == BPF_MAP_LOOKUP_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_batch);\n\telse if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);\n\telse if (cmd == BPF_MAP_UPDATE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_update_batch);\n\telse\n\t\tBPF_DO_BATCH(map->ops->map_delete_batch);\nerr_put:\n\tif (has_write)\n\t\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_task_fd_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4104-4172",
    "snippet": "static int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tfile = fget_task(task, fd);\n\tput_task_struct(task);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (file->f_op == &bpf_link_fops) {\n\t\tstruct bpf_link *link = file->private_data;\n\n\t\tif (link->ops == &bpf_raw_tp_link_lops) {\n\t\t\tstruct bpf_raw_tp_link *raw_tp =\n\t\t\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\t\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t\t     raw_tp->link.prog->aux->id,\n\t\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\t\tgoto put_file;\n\t\t}\n\t\tgoto out_not_supp;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\nout_not_supp:\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};",
      "static const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_task_fd_query_copy",
          "args": [
            "attr",
            "uattr",
            "prog_id",
            "fd_type",
            "buf",
            "probe_offset",
            "probe_addr"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_fd_query_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4055-4100",
          "snippet": "static int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_perf_event_info",
          "args": [
            "event",
            "&prog_id",
            "&fd_type",
            "&buf",
            "&probe_offset",
            "&probe_addr"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_perf_event_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "2065-2110",
          "snippet": "int bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_get_event",
          "args": [
            "file"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "perf_get_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12912-12918",
          "snippet": "const struct perf_event *perf_get_event(struct file *file)\n{\n\tif (file->f_op != &perf_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file->private_data;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static const struct file_operations perf_fops;",
            "static const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic const struct file_operations perf_fops;\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\nconst struct perf_event *perf_get_event(struct file *file)\n{\n\tif (file->f_op != &perf_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_raw_tp_link",
            "link"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget_task",
          "args": [
            "task",
            "fd"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "find_vpid(pid)",
            "PIDTYPE_PID"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "pid"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_TASK_FD_QUERY"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\nstatic const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};\n\nstatic int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tfile = fget_task(task, fd);\n\tput_task_struct(task);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (file->f_op == &bpf_link_fops) {\n\t\tstruct bpf_link *link = file->private_data;\n\n\t\tif (link->ops == &bpf_raw_tp_link_lops) {\n\t\t\tstruct bpf_raw_tp_link *raw_tp =\n\t\t\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\t\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t\t     raw_tp->link.prog->aux->id,\n\t\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\t\tgoto put_file;\n\t\t}\n\t\tgoto out_not_supp;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\nout_not_supp:\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_task_fd_query_copy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4055-4100",
    "snippet": "static int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "probe_addr",
            "&uattr->task_fd_query.probe_addr"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "probe_offset",
            "&uattr->task_fd_query.probe_offset"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "fd_type",
            "&uattr->task_fd_query.fd_type"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "prog_id",
            "&uattr->task_fd_query.prog_id"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf + input_len - 1"
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "buf",
            "input_len - 1"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "len",
            "&uattr->task_fd_query.buf_len"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->task_fd_query.buf"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_btf_get_fd_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4044-4053",
    "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_get_fd_by_id",
          "args": [
            "attr->btf_id"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4044-4053",
          "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_BTF_GET_FD_BY_ID"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}"
  },
  {
    "function_name": "bpf_btf_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4031-4040",
    "snippet": "static int bpf_btf_load(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr, uattr);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_new_fd",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "btf_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6042-6071",
          "snippet": "int btf_new_fd(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(make_bpfptr(attr->btf, uattr.is_kernel),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_new_fd(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(make_bpfptr(attr->btf, uattr.is_kernel),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_BTF_LOAD"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_load(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr, uattr);\n}"
  },
  {
    "function_name": "bpf_obj_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3997-4027",
    "snippet": "static int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file, f.file->private_data, attr, uattr);\n\telse if (f.file->f_op == &bpf_link_fops)\n\t\terr = bpf_link_get_info_by_fd(f.file, f.file->private_data,\n\t\t\t\t\t      attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};",
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};",
      "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_get_info_by_fd",
          "args": [
            "f.file",
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3958-3992",
          "snippet": "static int bpf_link_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_link *link,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_link_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_link_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = link->type;\n\tinfo.id = link->id;\n\tinfo.prog_id = link->prog->aux->id;\n\n\tif (link->ops->fill_link_info) {\n\t\terr = link->ops->fill_link_info(link, &info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_link_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_link *link,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_link_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_link_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = link->type;\n\tinfo.id = link->id;\n\tinfo.prog_id = link->prog->aux->id;\n\n\tif (link->ops->fill_link_info) {\n\t\terr = link->ops->fill_link_info(link, &info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_btf_get_info_by_fd",
          "args": [
            "f.file",
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3942-3956",
          "snippet": "static int bpf_btf_get_info_by_fd(struct file *file,\n\t\t\t\t  struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_info_by_fd(struct file *file,\n\t\t\t\t  struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_get_info_by_fd",
          "args": [
            "f.file",
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 4015
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3897-3940",
          "snippet": "static int bpf_map_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tinfo.map_extra = map->map_extra;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_obj_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\tinfo.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tinfo.map_extra = map->map_extra;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_obj_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\tinfo.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_info_by_fd",
          "args": [
            "f.file",
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3613-3895",
          "snippet": "static int bpf_prog_get_info_by_fd(struct file *file,\n\t\t\t\t   struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info;\n\tu32 info_len = attr->info.info_len;\n\tstruct bpf_prog_kstats stats;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i])) {\n\t\t\t\tmutex_unlock(&prog->aux->used_maps_mutex);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t}\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\terr = set_info_rec_size(&info);\n\tif (err)\n\t\treturn err;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tinfo.run_time_ns = stats.nsecs;\n\tinfo.run_cnt = stats.cnt;\n\tinfo.recursion_misses = stats.misses;\n\n\tinfo.verified_insns = prog->aux->verified_insns;\n\n\tif (!bpf_capable()) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tinfo.nr_jited_func_lens = 0;\n\t\tinfo.nr_func_info = 0;\n\t\tinfo.nr_line_info = 0;\n\t\tinfo.nr_jited_line_info = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog, file->f_cred);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tunsigned long ksym_addr;\n\t\t\tu64 __user *user_ksyms;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tksym_addr = (unsigned long)\n\t\t\t\t\t\tprog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (put_user((u64) ksym_addr,\n\t\t\t\t\t\t     &user_ksyms[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tksym_addr = (unsigned long) prog->bpf_func;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tfunc_len =\n\t\t\t\t\t\tprog->aux->func[i]->jited_len;\n\t\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfunc_len = prog->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\n\tif (prog->aux->btf)\n\t\tinfo.btf_id = btf_obj_id(prog->aux->btf);\n\n\tulen = info.nr_func_info;\n\tinfo.nr_func_info = prog->aux->func_info_cnt;\n\tif (info.nr_func_info && ulen) {\n\t\tchar __user *user_finfo;\n\n\t\tuser_finfo = u64_to_user_ptr(info.func_info);\n\t\tulen = min_t(u32, info.nr_func_info, ulen);\n\t\tif (copy_to_user(user_finfo, prog->aux->func_info,\n\t\t\t\t info.func_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_line_info;\n\tinfo.nr_line_info = prog->aux->nr_linfo;\n\tif (info.nr_line_info && ulen) {\n\t\t__u8 __user *user_linfo;\n\n\t\tuser_linfo = u64_to_user_ptr(info.line_info);\n\t\tulen = min_t(u32, info.nr_line_info, ulen);\n\t\tif (copy_to_user(user_linfo, prog->aux->linfo,\n\t\t\t\t info.line_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_jited_line_info;\n\tif (prog->aux->jited_linfo)\n\t\tinfo.nr_jited_line_info = prog->aux->nr_linfo;\n\telse\n\t\tinfo.nr_jited_line_info = 0;\n\tif (info.nr_jited_line_info && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\t__u64 __user *user_linfo;\n\t\t\tu32 i;\n\n\t\t\tuser_linfo = u64_to_user_ptr(info.jited_line_info);\n\t\t\tulen = min_t(u32, info.nr_jited_line_info, ulen);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (put_user((__u64)(long)prog->aux->jited_linfo[i],\n\t\t\t\t\t     &user_linfo[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_line_info = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_prog_tags;\n\tinfo.nr_prog_tags = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\t__u8 __user (*user_prog_tags)[BPF_TAG_SIZE];\n\t\tu32 i;\n\n\t\tuser_prog_tags = u64_to_user_ptr(info.prog_tags);\n\t\tulen = min_t(u32, info.nr_prog_tags, ulen);\n\t\tif (prog->aux->func_cnt) {\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (copy_to_user(user_prog_tags[i],\n\t\t\t\t\t\t prog->aux->func[i]->tag,\n\t\t\t\t\t\t BPF_TAG_SIZE))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(user_prog_tags[0],\n\t\t\t\t\t prog->tag, BPF_TAG_SIZE))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_info_by_fd(struct file *file,\n\t\t\t\t   struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info;\n\tu32 info_len = attr->info.info_len;\n\tstruct bpf_prog_kstats stats;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i])) {\n\t\t\t\tmutex_unlock(&prog->aux->used_maps_mutex);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t}\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\terr = set_info_rec_size(&info);\n\tif (err)\n\t\treturn err;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tinfo.run_time_ns = stats.nsecs;\n\tinfo.run_cnt = stats.cnt;\n\tinfo.recursion_misses = stats.misses;\n\n\tinfo.verified_insns = prog->aux->verified_insns;\n\n\tif (!bpf_capable()) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tinfo.nr_jited_func_lens = 0;\n\t\tinfo.nr_func_info = 0;\n\t\tinfo.nr_line_info = 0;\n\t\tinfo.nr_jited_line_info = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog, file->f_cred);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tunsigned long ksym_addr;\n\t\t\tu64 __user *user_ksyms;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tksym_addr = (unsigned long)\n\t\t\t\t\t\tprog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (put_user((u64) ksym_addr,\n\t\t\t\t\t\t     &user_ksyms[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tksym_addr = (unsigned long) prog->bpf_func;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tfunc_len =\n\t\t\t\t\t\tprog->aux->func[i]->jited_len;\n\t\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfunc_len = prog->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\n\tif (prog->aux->btf)\n\t\tinfo.btf_id = btf_obj_id(prog->aux->btf);\n\n\tulen = info.nr_func_info;\n\tinfo.nr_func_info = prog->aux->func_info_cnt;\n\tif (info.nr_func_info && ulen) {\n\t\tchar __user *user_finfo;\n\n\t\tuser_finfo = u64_to_user_ptr(info.func_info);\n\t\tulen = min_t(u32, info.nr_func_info, ulen);\n\t\tif (copy_to_user(user_finfo, prog->aux->func_info,\n\t\t\t\t info.func_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_line_info;\n\tinfo.nr_line_info = prog->aux->nr_linfo;\n\tif (info.nr_line_info && ulen) {\n\t\t__u8 __user *user_linfo;\n\n\t\tuser_linfo = u64_to_user_ptr(info.line_info);\n\t\tulen = min_t(u32, info.nr_line_info, ulen);\n\t\tif (copy_to_user(user_linfo, prog->aux->linfo,\n\t\t\t\t info.line_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_jited_line_info;\n\tif (prog->aux->jited_linfo)\n\t\tinfo.nr_jited_line_info = prog->aux->nr_linfo;\n\telse\n\t\tinfo.nr_jited_line_info = 0;\n\tif (info.nr_jited_line_info && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\t__u64 __user *user_linfo;\n\t\t\tu32 i;\n\n\t\t\tuser_linfo = u64_to_user_ptr(info.jited_line_info);\n\t\t\tulen = min_t(u32, info.nr_jited_line_info, ulen);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (put_user((__u64)(long)prog->aux->jited_linfo[i],\n\t\t\t\t\t     &user_linfo[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_line_info = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_prog_tags;\n\tinfo.nr_prog_tags = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\t__u8 __user (*user_prog_tags)[BPF_TAG_SIZE];\n\t\tu32 i;\n\n\t\tuser_prog_tags = u64_to_user_ptr(info.prog_tags);\n\t\tulen = min_t(u32, info.nr_prog_tags, ulen);\n\t\tif (prog->aux->func_cnt) {\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (copy_to_user(user_prog_tags[i],\n\t\t\t\t\t\t prog->aux->func[i]->tag,\n\t\t\t\t\t\t BPF_TAG_SIZE))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(user_prog_tags[0],\n\t\t\t\t\t prog->tag, BPF_TAG_SIZE))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ_GET_INFO_BY_FD"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file, f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file, f.file->private_data, attr, uattr);\n\telse if (f.file->f_op == &bpf_link_fops)\n\t\terr = bpf_link_get_info_by_fd(f.file, f.file->private_data,\n\t\t\t\t\t      attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_link_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3958-3992",
    "snippet": "static int bpf_link_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_link *link,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_link_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_link_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = link->type;\n\tinfo.id = link->id;\n\tinfo.prog_id = link->prog->aux->id;\n\n\tif (link->ops->fill_link_info) {\n\t\terr = link->ops->fill_link_info(link, &info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_len",
            "&uattr->info.info_len"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_len"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link->ops->fill_link_info",
          "args": [
            "link",
            "&info"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "uinfo",
            "info_len"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "USER_BPFPTR(uinfo)",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3968
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USER_BPFPTR",
          "args": [
            "uinfo"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_link_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_link *link,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_link_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_link_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = link->type;\n\tinfo.id = link->id;\n\tinfo.prog_id = link->prog->aux->id;\n\n\tif (link->ops->fill_link_info) {\n\t\terr = link->ops->fill_link_info(link, &info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_btf_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3942-3956",
    "snippet": "static int bpf_btf_get_info_by_fd(struct file *file,\n\t\t\t\t  struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_get_info_by_fd",
          "args": [
            "btf",
            "attr",
            "uattr"
          ],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_info_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6095-6153",
          "snippet": "int btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info;\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tchar __user *uname;\n\tu32 uinfo_len, uname_len, name_len;\n\tint ret = 0;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tinfo.kernel_btf = btf->kernel_btf;\n\n\tuname = u64_to_user_ptr(info.name);\n\tuname_len = info.name_len;\n\tif (!uname ^ !uname_len)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(btf->name);\n\tinfo.name_len = name_len;\n\n\tif (uname) {\n\t\tif (uname_len >= name_len + 1) {\n\t\t\tif (copy_to_user(uname, btf->name, name_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(uname, btf->name, uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, uname + uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* let user-space know about too short buffer */\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info;\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tchar __user *uname;\n\tu32 uinfo_len, uname_len, name_len;\n\tint ret = 0;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tinfo.kernel_btf = btf->kernel_btf;\n\n\tuname = u64_to_user_ptr(info.name);\n\tuname_len = info.name_len;\n\tif (!uname ^ !uname_len)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(btf->name);\n\tinfo.name_len = name_len;\n\n\tif (uname) {\n\t\tif (uname_len >= name_len + 1) {\n\t\t\tif (copy_to_user(uname, btf->name, name_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(uname, btf->name, uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, uname + uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* let user-space know about too short buffer */\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "USER_BPFPTR(uinfo)",
            "sizeof(*uinfo)",
            "info_len"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USER_BPFPTR",
          "args": [
            "uinfo"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_info_by_fd(struct file *file,\n\t\t\t\t  struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}"
  },
  {
    "function_name": "bpf_map_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3897-3940",
    "snippet": "static int bpf_map_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tinfo.map_extra = map->map_extra;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_obj_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\tinfo.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_len",
            "&uattr->info.info_len"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_len"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_info_fill",
          "args": [
            "&info",
            "map"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_info_fill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "521-544",
          "snippet": "int bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map)\n{\n\tstruct ns_get_path_bpf_map_args args = {\n\t\t.offmap\t= map_to_offmap(map),\n\t\t.info\t= info,\n\t};\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tint res;\n\n\tres = ns_get_path_cb(&ns_path, bpf_map_offload_info_fill_ns, &args);\n\tif (res) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn res;\n\t}\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map)\n{\n\tstruct ns_get_path_bpf_map_args args = {\n\t\t.offmap\t= map_to_offmap(map),\n\t\t.info\t= info,\n\t};\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tint res;\n\n\tres = ns_get_path_cb(&ns_path, bpf_map_offload_info_fill_ns, &args);\n\tif (res) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn res;\n\t}\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_obj_id",
          "args": [
            "map->btf"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "btf_obj_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6176-6179",
          "snippet": "u32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "info.name",
            "map->name",
            "sizeof(map->name)"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "USER_BPFPTR(uinfo)",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3907
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USER_BPFPTR",
          "args": [
            "uinfo"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_get_info_by_fd(struct file *file,\n\t\t\t\t  struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info;\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tinfo.map_extra = map->map_extra;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_obj_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\tinfo.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3613-3895",
    "snippet": "static int bpf_prog_get_info_by_fd(struct file *file,\n\t\t\t\t   struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info;\n\tu32 info_len = attr->info.info_len;\n\tstruct bpf_prog_kstats stats;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i])) {\n\t\t\t\tmutex_unlock(&prog->aux->used_maps_mutex);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t}\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\terr = set_info_rec_size(&info);\n\tif (err)\n\t\treturn err;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tinfo.run_time_ns = stats.nsecs;\n\tinfo.run_cnt = stats.cnt;\n\tinfo.recursion_misses = stats.misses;\n\n\tinfo.verified_insns = prog->aux->verified_insns;\n\n\tif (!bpf_capable()) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tinfo.nr_jited_func_lens = 0;\n\t\tinfo.nr_func_info = 0;\n\t\tinfo.nr_line_info = 0;\n\t\tinfo.nr_jited_line_info = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog, file->f_cred);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tunsigned long ksym_addr;\n\t\t\tu64 __user *user_ksyms;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tksym_addr = (unsigned long)\n\t\t\t\t\t\tprog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (put_user((u64) ksym_addr,\n\t\t\t\t\t\t     &user_ksyms[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tksym_addr = (unsigned long) prog->bpf_func;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tfunc_len =\n\t\t\t\t\t\tprog->aux->func[i]->jited_len;\n\t\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfunc_len = prog->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\n\tif (prog->aux->btf)\n\t\tinfo.btf_id = btf_obj_id(prog->aux->btf);\n\n\tulen = info.nr_func_info;\n\tinfo.nr_func_info = prog->aux->func_info_cnt;\n\tif (info.nr_func_info && ulen) {\n\t\tchar __user *user_finfo;\n\n\t\tuser_finfo = u64_to_user_ptr(info.func_info);\n\t\tulen = min_t(u32, info.nr_func_info, ulen);\n\t\tif (copy_to_user(user_finfo, prog->aux->func_info,\n\t\t\t\t info.func_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_line_info;\n\tinfo.nr_line_info = prog->aux->nr_linfo;\n\tif (info.nr_line_info && ulen) {\n\t\t__u8 __user *user_linfo;\n\n\t\tuser_linfo = u64_to_user_ptr(info.line_info);\n\t\tulen = min_t(u32, info.nr_line_info, ulen);\n\t\tif (copy_to_user(user_linfo, prog->aux->linfo,\n\t\t\t\t info.line_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_jited_line_info;\n\tif (prog->aux->jited_linfo)\n\t\tinfo.nr_jited_line_info = prog->aux->nr_linfo;\n\telse\n\t\tinfo.nr_jited_line_info = 0;\n\tif (info.nr_jited_line_info && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\t__u64 __user *user_linfo;\n\t\t\tu32 i;\n\n\t\t\tuser_linfo = u64_to_user_ptr(info.jited_line_info);\n\t\t\tulen = min_t(u32, info.nr_jited_line_info, ulen);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (put_user((__u64)(long)prog->aux->jited_linfo[i],\n\t\t\t\t\t     &user_linfo[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_line_info = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_prog_tags;\n\tinfo.nr_prog_tags = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\t__u8 __user (*user_prog_tags)[BPF_TAG_SIZE];\n\t\tu32 i;\n\n\t\tuser_prog_tags = u64_to_user_ptr(info.prog_tags);\n\t\tulen = min_t(u32, info.nr_prog_tags, ulen);\n\t\tif (prog->aux->func_cnt) {\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (copy_to_user(user_prog_tags[i],\n\t\t\t\t\t\t prog->aux->func[i]->tag,\n\t\t\t\t\t\t BPF_TAG_SIZE))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(user_prog_tags[0],\n\t\t\t\t\t prog->tag, BPF_TAG_SIZE))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_len",
            "&uattr->info.info_len"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_len"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_prog_tags",
            "ulen"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.prog_tags"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(__u64)(long)prog->aux->jited_linfo[i]",
            "&user_linfo[i]"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_jited_line_info",
            "ulen"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_line_info"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "file->f_cred"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_line_info",
            "ulen"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.line_info"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_func_info",
            "ulen"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.func_info"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_obj_id",
          "args": [
            "prog->aux->btf"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "btf_obj_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6176-6179",
          "snippet": "u32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "func_len",
            "&user_lens[0]"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "func_len",
            "&user_lens[i]"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_func_lens"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_jited_func_lens",
            "ulen"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "file->f_cred"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(u64) ksym_addr",
            "&user_ksyms[0]"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(u64) ksym_addr",
            "&user_ksyms[i]"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_ksyms"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_jited_ksyms",
            "ulen"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "file->f_cred"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "len",
            "free"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.jited_prog_len",
            "ulen"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_prog_insns"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "file->f_cred"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_info_fill",
          "args": [
            "&info",
            "prog"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_info_fill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "294-341",
          "snippet": "int bpf_prog_offload_info_fill(struct bpf_prog_info *info,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct ns_get_path_bpf_prog_args args = {\n\t\t.prog\t= prog,\n\t\t.info\t= info,\n\t};\n\tstruct bpf_prog_aux *aux = prog->aux;\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tchar __user *uinsns;\n\tint res;\n\tu32 ulen;\n\n\tres = ns_get_path_cb(&ns_path, bpf_prog_offload_info_fill_ns, &args);\n\tif (res) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn res;\n\t}\n\n\tdown_read(&bpf_devs_lock);\n\n\tif (!aux->offload) {\n\t\tup_read(&bpf_devs_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tulen = info->jited_prog_len;\n\tinfo->jited_prog_len = aux->offload->jited_len;\n\tif (info->jited_prog_len && ulen) {\n\t\tuinsns = u64_to_user_ptr(info->jited_prog_insns);\n\t\tulen = min_t(u32, info->jited_prog_len, ulen);\n\t\tif (copy_to_user(uinsns, aux->offload->jited_image, ulen)) {\n\t\t\tup_read(&bpf_devs_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tup_read(&bpf_devs_lock);\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_prog_offload_info_fill(struct bpf_prog_info *info,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct ns_get_path_bpf_prog_args args = {\n\t\t.prog\t= prog,\n\t\t.info\t= info,\n\t};\n\tstruct bpf_prog_aux *aux = prog->aux;\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tchar __user *uinsns;\n\tint res;\n\tu32 ulen;\n\n\tres = ns_get_path_cb(&ns_path, bpf_prog_offload_info_fill_ns, &args);\n\tif (res) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn res;\n\t}\n\n\tdown_read(&bpf_devs_lock);\n\n\tif (!aux->offload) {\n\t\tup_read(&bpf_devs_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tulen = info->jited_prog_len;\n\tinfo->jited_prog_len = aux->offload->jited_len;\n\tif (info->jited_prog_len && ulen) {\n\t\tuinsns = u64_to_user_ptr(info->jited_prog_insns);\n\t\tulen = min_t(u32, info->jited_prog_len, ulen);\n\t\tif (copy_to_user(uinsns, aux->offload->jited_image, ulen)) {\n\t\t\tup_read(&bpf_devs_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tup_read(&bpf_devs_lock);\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "insns_sanitized"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.xlated_prog_len",
            "ulen"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.xlated_prog_insns"
          ],
          "line": 3697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_insn_prepare_dump",
          "args": [
            "prog",
            "file->f_cred"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_insn_prepare_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3530-3580",
          "snippet": "static struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog,\n\t\t\t\t\t      const struct cred *f_cred)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu32 off, type;\n\tu64 imm;\n\tu8 code;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tcode = insns[i].code;\n\n\t\tif (code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (code == (BPF_JMP | BPF_CALL) ||\n\t\t    code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok(f_cred))\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (BPF_CLASS(code) == BPF_LDX && BPF_MODE(code) == BPF_PROBE_MEM) {\n\t\t\tinsns[i].code = BPF_LDX | BPF_SIZE(code) | BPF_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm, &off, &type);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = type;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = off;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog,\n\t\t\t\t\t      const struct cred *f_cred)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu32 off, type;\n\tu64 imm;\n\tu8 code;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tcode = insns[i].code;\n\n\t\tif (code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (code == (BPF_JMP | BPF_CALL) ||\n\t\t    code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok(f_cred))\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (BPF_CLASS(code) == BPF_LDX && BPF_MODE(code) == BPF_PROBE_MEM) {\n\t\t\tinsns[i].code = BPF_LDX | BPF_SIZE(code) | BPF_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm, &off, &type);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = type;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = off;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "file->f_cred"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_stats",
          "args": [
            "prog",
            "&stats"
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1848-1873",
          "snippet": "static void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_info_rec_size",
          "args": [
            "&info"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "set_info_rec_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3582-3611",
          "snippet": "static int set_info_rec_size(struct bpf_prog_info *info)\n{\n\t/*\n\t * Ensure info.*_rec_size is the same as kernel expected size\n\t *\n\t * or\n\t *\n\t * Only allow zero *_rec_size if both _rec_size and _cnt are\n\t * zero.  In this case, the kernel will set the expected\n\t * _rec_size back to the info.\n\t */\n\n\tif ((info->nr_func_info || info->func_info_rec_size) &&\n\t    info->func_info_rec_size != sizeof(struct bpf_func_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_line_info || info->line_info_rec_size) &&\n\t    info->line_info_rec_size != sizeof(struct bpf_line_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&\n\t    info->jited_line_info_rec_size != sizeof(__u64))\n\t\treturn -EINVAL;\n\n\tinfo->func_info_rec_size = sizeof(struct bpf_func_info);\n\tinfo->line_info_rec_size = sizeof(struct bpf_line_info);\n\tinfo->jited_line_info_rec_size = sizeof(__u64);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int set_info_rec_size(struct bpf_prog_info *info)\n{\n\t/*\n\t * Ensure info.*_rec_size is the same as kernel expected size\n\t *\n\t * or\n\t *\n\t * Only allow zero *_rec_size if both _rec_size and _cnt are\n\t * zero.  In this case, the kernel will set the expected\n\t * _rec_size back to the info.\n\t */\n\n\tif ((info->nr_func_info || info->func_info_rec_size) &&\n\t    info->func_info_rec_size != sizeof(struct bpf_func_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_line_info || info->line_info_rec_size) &&\n\t    info->line_info_rec_size != sizeof(struct bpf_line_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&\n\t    info->jited_line_info_rec_size != sizeof(__u64))\n\t\treturn -EINVAL;\n\n\tinfo->func_info_rec_size = sizeof(struct bpf_func_info);\n\tinfo->line_info_rec_size = sizeof(struct bpf_line_info);\n\tinfo->jited_line_info_rec_size = sizeof(__u64);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "prog->aux->used_maps[i]->id",
            "&user_map_ids[i]"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.map_ids"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_map_ids",
            "ulen"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "info.name",
            "prog->aux->name",
            "sizeof(prog->aux->name)"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "prog->aux->user->uid"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "uinfo",
            "info_len"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "USER_BPFPTR(uinfo)",
            "sizeof(info)",
            "info_len"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USER_BPFPTR",
          "args": [
            "uinfo"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_info_by_fd(struct file *file,\n\t\t\t\t   struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info;\n\tu32 info_len = attr->info.info_len;\n\tstruct bpf_prog_kstats stats;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(USER_BPFPTR(uinfo), sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i])) {\n\t\t\t\tmutex_unlock(&prog->aux->used_maps_mutex);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t}\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\n\terr = set_info_rec_size(&info);\n\tif (err)\n\t\treturn err;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tinfo.run_time_ns = stats.nsecs;\n\tinfo.run_cnt = stats.cnt;\n\tinfo.recursion_misses = stats.misses;\n\n\tinfo.verified_insns = prog->aux->verified_insns;\n\n\tif (!bpf_capable()) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tinfo.nr_jited_func_lens = 0;\n\t\tinfo.nr_func_info = 0;\n\t\tinfo.nr_line_info = 0;\n\t\tinfo.nr_jited_line_info = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog, file->f_cred);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tunsigned long ksym_addr;\n\t\t\tu64 __user *user_ksyms;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tksym_addr = (unsigned long)\n\t\t\t\t\t\tprog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (put_user((u64) ksym_addr,\n\t\t\t\t\t\t     &user_ksyms[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tksym_addr = (unsigned long) prog->bpf_func;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\t\tfunc_len =\n\t\t\t\t\t\tprog->aux->func[i]->jited_len;\n\t\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfunc_len = prog->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[0]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\n\tif (prog->aux->btf)\n\t\tinfo.btf_id = btf_obj_id(prog->aux->btf);\n\n\tulen = info.nr_func_info;\n\tinfo.nr_func_info = prog->aux->func_info_cnt;\n\tif (info.nr_func_info && ulen) {\n\t\tchar __user *user_finfo;\n\n\t\tuser_finfo = u64_to_user_ptr(info.func_info);\n\t\tulen = min_t(u32, info.nr_func_info, ulen);\n\t\tif (copy_to_user(user_finfo, prog->aux->func_info,\n\t\t\t\t info.func_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_line_info;\n\tinfo.nr_line_info = prog->aux->nr_linfo;\n\tif (info.nr_line_info && ulen) {\n\t\t__u8 __user *user_linfo;\n\n\t\tuser_linfo = u64_to_user_ptr(info.line_info);\n\t\tulen = min_t(u32, info.nr_line_info, ulen);\n\t\tif (copy_to_user(user_linfo, prog->aux->linfo,\n\t\t\t\t info.line_info_rec_size * ulen))\n\t\t\treturn -EFAULT;\n\t}\n\n\tulen = info.nr_jited_line_info;\n\tif (prog->aux->jited_linfo)\n\t\tinfo.nr_jited_line_info = prog->aux->nr_linfo;\n\telse\n\t\tinfo.nr_jited_line_info = 0;\n\tif (info.nr_jited_line_info && ulen) {\n\t\tif (bpf_dump_raw_ok(file->f_cred)) {\n\t\t\t__u64 __user *user_linfo;\n\t\t\tu32 i;\n\n\t\t\tuser_linfo = u64_to_user_ptr(info.jited_line_info);\n\t\t\tulen = min_t(u32, info.nr_jited_line_info, ulen);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (put_user((__u64)(long)prog->aux->jited_linfo[i],\n\t\t\t\t\t     &user_linfo[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_line_info = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_prog_tags;\n\tinfo.nr_prog_tags = prog->aux->func_cnt ? : 1;\n\tif (ulen) {\n\t\t__u8 __user (*user_prog_tags)[BPF_TAG_SIZE];\n\t\tu32 i;\n\n\t\tuser_prog_tags = u64_to_user_ptr(info.prog_tags);\n\t\tulen = min_t(u32, info.nr_prog_tags, ulen);\n\t\tif (prog->aux->func_cnt) {\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tif (copy_to_user(user_prog_tags[i],\n\t\t\t\t\t\t prog->aux->func[i]->tag,\n\t\t\t\t\t\t BPF_TAG_SIZE))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_to_user(user_prog_tags[0],\n\t\t\t\t\t prog->tag, BPF_TAG_SIZE))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_info_rec_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3582-3611",
    "snippet": "static int set_info_rec_size(struct bpf_prog_info *info)\n{\n\t/*\n\t * Ensure info.*_rec_size is the same as kernel expected size\n\t *\n\t * or\n\t *\n\t * Only allow zero *_rec_size if both _rec_size and _cnt are\n\t * zero.  In this case, the kernel will set the expected\n\t * _rec_size back to the info.\n\t */\n\n\tif ((info->nr_func_info || info->func_info_rec_size) &&\n\t    info->func_info_rec_size != sizeof(struct bpf_func_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_line_info || info->line_info_rec_size) &&\n\t    info->line_info_rec_size != sizeof(struct bpf_line_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&\n\t    info->jited_line_info_rec_size != sizeof(__u64))\n\t\treturn -EINVAL;\n\n\tinfo->func_info_rec_size = sizeof(struct bpf_func_info);\n\tinfo->line_info_rec_size = sizeof(struct bpf_line_info);\n\tinfo->jited_line_info_rec_size = sizeof(__u64);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int set_info_rec_size(struct bpf_prog_info *info)\n{\n\t/*\n\t * Ensure info.*_rec_size is the same as kernel expected size\n\t *\n\t * or\n\t *\n\t * Only allow zero *_rec_size if both _rec_size and _cnt are\n\t * zero.  In this case, the kernel will set the expected\n\t * _rec_size back to the info.\n\t */\n\n\tif ((info->nr_func_info || info->func_info_rec_size) &&\n\t    info->func_info_rec_size != sizeof(struct bpf_func_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_line_info || info->line_info_rec_size) &&\n\t    info->line_info_rec_size != sizeof(struct bpf_line_info))\n\t\treturn -EINVAL;\n\n\tif ((info->nr_jited_line_info || info->jited_line_info_rec_size) &&\n\t    info->jited_line_info_rec_size != sizeof(__u64))\n\t\treturn -EINVAL;\n\n\tinfo->func_info_rec_size = sizeof(struct bpf_func_info);\n\tinfo->line_info_rec_size = sizeof(struct bpf_line_info);\n\tinfo->jited_line_info_rec_size = sizeof(__u64);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_insn_prepare_dump",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3530-3580",
    "snippet": "static struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog,\n\t\t\t\t\t      const struct cred *f_cred)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu32 off, type;\n\tu64 imm;\n\tu8 code;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tcode = insns[i].code;\n\n\t\tif (code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (code == (BPF_JMP | BPF_CALL) ||\n\t\t    code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok(f_cred))\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (BPF_CLASS(code) == BPF_LDX && BPF_MODE(code) == BPF_PROBE_MEM) {\n\t\t\tinsns[i].code = BPF_LDX | BPF_SIZE(code) | BPF_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm, &off, &type);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = type;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = off;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_from_imm",
          "args": [
            "prog",
            "imm",
            "&off",
            "&type"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_from_imm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3502-3528",
          "snippet": "static const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr, u32 *off,\n\t\t\t\t\t      u32 *type)\n{\n\tconst struct bpf_map *map;\n\tint i;\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tfor (i = 0, *off = 0; i < prog->aux->used_map_cnt; i++) {\n\t\tmap = prog->aux->used_maps[i];\n\t\tif (map == (void *)addr) {\n\t\t\t*type = BPF_PSEUDO_MAP_FD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!map->ops->map_direct_value_meta)\n\t\t\tcontinue;\n\t\tif (!map->ops->map_direct_value_meta(map, addr, off)) {\n\t\t\t*type = BPF_PSEUDO_MAP_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmap = NULL;\n\nout:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr, u32 *off,\n\t\t\t\t\t      u32 *type)\n{\n\tconst struct bpf_map *map;\n\tint i;\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tfor (i = 0, *off = 0; i < prog->aux->used_map_cnt; i++) {\n\t\tmap = prog->aux->used_maps[i];\n\t\tif (map == (void *)addr) {\n\t\t\t*type = BPF_PSEUDO_MAP_FD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!map->ops->map_direct_value_meta)\n\t\t\tcontinue;\n\t\tif (!map->ops->map_direct_value_meta(map, addr, off)) {\n\t\t\t*type = BPF_PSEUDO_MAP_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmap = NULL;\n\nout:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "code"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "code"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CLASS",
          "args": [
            "code"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [
            "f_cred"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "prog->insnsi",
            "bpf_prog_insn_size(prog)",
            "GFP_USER"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog,\n\t\t\t\t\t      const struct cred *f_cred)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu32 off, type;\n\tu64 imm;\n\tu8 code;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tcode = insns[i].code;\n\n\t\tif (code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (code == (BPF_JMP | BPF_CALL) ||\n\t\t    code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok(f_cred))\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (BPF_CLASS(code) == BPF_LDX && BPF_MODE(code) == BPF_PROBE_MEM) {\n\t\t\tinsns[i].code = BPF_LDX | BPF_SIZE(code) | BPF_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm, &off, &type);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = type;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = off;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}"
  },
  {
    "function_name": "bpf_map_from_imm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3502-3528",
    "snippet": "static const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr, u32 *off,\n\t\t\t\t\t      u32 *type)\n{\n\tconst struct bpf_map *map;\n\tint i;\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tfor (i = 0, *off = 0; i < prog->aux->used_map_cnt; i++) {\n\t\tmap = prog->aux->used_maps[i];\n\t\tif (map == (void *)addr) {\n\t\t\t*type = BPF_PSEUDO_MAP_FD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!map->ops->map_direct_value_meta)\n\t\t\tcontinue;\n\t\tif (!map->ops->map_direct_value_meta(map, addr, off)) {\n\t\t\t*type = BPF_PSEUDO_MAP_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmap = NULL;\n\nout:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_direct_value_meta",
          "args": [
            "map",
            "addr",
            "off"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&prog->aux->used_maps_mutex"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr, u32 *off,\n\t\t\t\t\t      u32 *type)\n{\n\tconst struct bpf_map *map;\n\tint i;\n\n\tmutex_lock(&prog->aux->used_maps_mutex);\n\tfor (i = 0, *off = 0; i < prog->aux->used_map_cnt; i++) {\n\t\tmap = prog->aux->used_maps[i];\n\t\tif (map == (void *)addr) {\n\t\t\t*type = BPF_PSEUDO_MAP_FD;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!map->ops->map_direct_value_meta)\n\t\t\tcontinue;\n\t\tif (!map->ops->map_direct_value_meta(map, addr, off)) {\n\t\t\t*type = BPF_PSEUDO_MAP_VALUE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmap = NULL;\n\nout:\n\tmutex_unlock(&prog->aux->used_maps_mutex);\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_get_fd_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3466-3500",
    "snippet": "static int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put_with_uref",
          "args": [
            "map"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_new_fd",
          "args": [
            "map",
            "f_flags"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "708-718",
          "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_inc_not_zero",
          "args": [
            "map",
            "true"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1006-1017",
          "snippet": "static struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&map_idr",
            "id"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_file_flag",
          "args": [
            "attr->open_flags"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "720-729",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_GET_FD_BY_ID"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = __bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put_with_uref(map);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_prog_get_fd_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3441-3462",
    "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_new_fd",
          "args": [
            "prog"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1915-1925",
          "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_by_id",
          "args": [
            "id"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3424-3439",
          "snippet": "struct bpf_prog *bpf_prog_by_id(u32 id)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstruct bpf_prog *bpf_prog_by_id(u32 id)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_GET_FD_BY_ID"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_prog_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3424-3439",
    "snippet": "struct bpf_prog *bpf_prog_by_id(u32 id)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\treturn prog;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc_not_zero",
          "args": [
            "prog"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&prog_idr",
            "id"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstruct bpf_prog *bpf_prog_by_id(u32 id)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_prog_get_curr_or_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3403-3420",
    "snippet": "struct bpf_prog *bpf_prog_get_curr_or_next(u32 *id)\n{\n\tstruct bpf_prog *prog;\n\n\tspin_lock_bh(&prog_idr_lock);\nagain:\n\tprog = idr_get_next(&prog_idr, id);\n\tif (prog) {\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\t\tif (IS_ERR(prog)) {\n\t\t\t(*id)++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&prog_idr_lock);\n\n\treturn prog;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc_not_zero",
          "args": [
            "prog"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "&prog_idr",
            "id"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstruct bpf_prog *bpf_prog_get_curr_or_next(u32 *id)\n{\n\tstruct bpf_prog *prog;\n\n\tspin_lock_bh(&prog_idr_lock);\nagain:\n\tprog = idr_get_next(&prog_idr, id);\n\tif (prog) {\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\t\tif (IS_ERR(prog)) {\n\t\t\t(*id)++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&prog_idr_lock);\n\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_map_get_curr_or_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3384-3401",
    "snippet": "struct bpf_map *bpf_map_get_curr_or_next(u32 *id)\n{\n\tstruct bpf_map *map;\n\n\tspin_lock_bh(&map_idr_lock);\nagain:\n\tmap = idr_get_next(&map_idr, id);\n\tif (map) {\n\t\tmap = __bpf_map_inc_not_zero(map, false);\n\t\tif (IS_ERR(map)) {\n\t\t\t(*id)++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_inc_not_zero",
          "args": [
            "map",
            "false"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1006-1017",
          "snippet": "static struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "&map_idr",
            "id"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstruct bpf_map *bpf_map_get_curr_or_next(u32 *id)\n{\n\tstruct bpf_map *map;\n\n\tspin_lock_bh(&map_idr_lock);\nagain:\n\tmap = idr_get_next(&map_idr, id);\n\tif (map) {\n\t\tmap = __bpf_map_inc_not_zero(map, false);\n\t\tif (IS_ERR(map)) {\n\t\t\t(*id)++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_obj_get_next_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3358-3382",
    "snippet": "static int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "next_id",
            "&uattr->next_id"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "lock"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "idr",
            "&next_id"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "lock"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ_GET_NEXT_ID"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_prog_test_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3328-3354",
    "snippet": "static int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_in && !attr->test.ctx_in) ||\n\t    (!attr->test.ctx_size_in && attr->test.ctx_in))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_out && !attr->test.ctx_out) ||\n\t    (!attr->test.ctx_size_out && attr->test.ctx_out))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog->aux->ops->test_run",
          "args": [
            "prog",
            "attr",
            "uattr"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->test.prog_fd"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_TEST_RUN"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_in && !attr->test.ctx_in) ||\n\t    (!attr->test.ctx_size_in && attr->test.ctx_in))\n\t\treturn -EINVAL;\n\n\tif ((attr->test.ctx_size_out && !attr->test.ctx_out) ||\n\t    (!attr->test.ctx_size_out && attr->test.ctx_out))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_prog_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3281-3324",
    "snippet": "static int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\tcase BPF_CGROUP_SYSCTL:\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn cgroup_bpf_prog_query(attr, uattr);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tcase BPF_FLOW_DISSECTOR:\n\tcase BPF_SK_LOOKUP:\n\t\treturn netns_bpf_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netns_bpf_prog_query",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_prog_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "271-295",
          "snippet": "int netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t union bpf_attr __user *uattr)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->query.attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->query.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_query(attr, uattr, net, type);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tput_net(net);\n\treturn ret;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t union bpf_attr __user *uattr)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->query.attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->query.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_query(attr, uattr, net, type);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tput_net(net);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lirc_prog_query",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_query",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "1014-1028",
          "snippet": "int cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_QUERY"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\tcase BPF_CGROUP_SYSCTL:\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn cgroup_bpf_prog_query(attr, uattr);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tcase BPF_FLOW_DISSECTOR:\n\tcase BPF_SK_LOOKUP:\n\t\treturn netns_bpf_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3249-3277",
    "snippet": "static int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\t\treturn sock_map_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\treturn netns_bpf_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\treturn cgroup_bpf_prog_detach(attr, ptype);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_detach",
          "args": [
            "attr",
            "ptype"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "857-877",
          "snippet": "int cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_prog_detach",
          "args": [
            "attr",
            "ptype"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_prog_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "383-407",
          "snippet": "int netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (attr->target_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tbpf_prog_put(prog);\n\n\treturn ret;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (attr->target_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tbpf_prog_put(prog);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lirc_prog_detach",
          "args": [
            "attr"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_prog_detach",
          "args": [
            "attr",
            "ptype"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_type_to_prog_type",
          "args": [
            "attr->attach_type"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_to_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3133-3186",
          "snippet": "static enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_DETACH"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\t\treturn sock_map_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\treturn netns_bpf_prog_detach(attr, ptype);\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\treturn cgroup_bpf_prog_detach(attr, ptype);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3193-3245",
    "snippet": "static int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\tif (ptype == BPF_PROG_TYPE_UNSPEC)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = netns_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI | BPF_F_REPLACE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_attach",
          "args": [
            "attr",
            "ptype",
            "prog"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/cgroup.c",
          "lines": "828-855",
          "snippet": "int cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *replace_prog = NULL;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tif ((attr->attach_flags & BPF_F_ALLOW_MULTI) &&\n\t    (attr->attach_flags & BPF_F_REPLACE)) {\n\t\treplace_prog = bpf_prog_get_type(attr->replace_bpf_fd, ptype);\n\t\tif (IS_ERR(replace_prog)) {\n\t\t\tcgroup_put(cgrp);\n\t\t\treturn PTR_ERR(replace_prog);\n\t\t}\n\t}\n\n\tret = cgroup_bpf_attach(cgrp, prog, replace_prog, NULL,\n\t\t\t\tattr->attach_type, attr->attach_flags);\n\n\tif (replace_prog)\n\t\tbpf_prog_put(replace_prog);\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <net/bpf_sk_storage.h>",
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/string.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <net/bpf_sk_storage.h>\n#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/string.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *replace_prog = NULL;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tif ((attr->attach_flags & BPF_F_ALLOW_MULTI) &&\n\t    (attr->attach_flags & BPF_F_REPLACE)) {\n\t\treplace_prog = bpf_prog_get_type(attr->replace_bpf_fd, ptype);\n\t\tif (IS_ERR(replace_prog)) {\n\t\t\tcgroup_put(cgrp);\n\t\t\treturn PTR_ERR(replace_prog);\n\t\t}\n\t}\n\n\tret = cgroup_bpf_attach(cgrp, prog, replace_prog, NULL,\n\t\t\t\tattr->attach_type, attr->attach_flags);\n\n\tif (replace_prog)\n\t\tbpf_prog_put(replace_prog);\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_prog_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_prog_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "297-361",
          "snippet": "int netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *run_array;\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *attached;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->target_fd || attr->attach_flags || attr->replace_bpf_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = current->nsproxy->net_ns;\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* Attaching prog directly is not compatible with links */\n\tif (!list_empty(&net->bpf.links[type])) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\tret = flow_dissector_bpf_prog_attach_check(net, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tattached = net->bpf.progs[type];\n\tif (attached == prog) {\n\t\t/* The same program cannot be attached twice */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array) {\n\t\tWRITE_ONCE(run_array->items[0].prog, prog);\n\t} else {\n\t\trun_array = bpf_prog_array_alloc(1, GFP_KERNEL);\n\t\tif (!run_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trun_array->items[0].prog = prog;\n\t\trcu_assign_pointer(net->bpf.run_array[type], run_array);\n\t}\n\n\tnet->bpf.progs[type] = prog;\n\tif (attached)\n\t\tbpf_prog_put(attached);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *run_array;\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *attached;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->target_fd || attr->attach_flags || attr->replace_bpf_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = current->nsproxy->net_ns;\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* Attaching prog directly is not compatible with links */\n\tif (!list_empty(&net->bpf.links[type])) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\tret = flow_dissector_bpf_prog_attach_check(net, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tattached = net->bpf.progs[type];\n\tif (attached == prog) {\n\t\t/* The same program cannot be attached twice */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array) {\n\t\tWRITE_ONCE(run_array->items[0].prog, prog);\n\t} else {\n\t\trun_array = bpf_prog_array_alloc(1, GFP_KERNEL);\n\t\tif (!run_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trun_array->items[0].prog = prog;\n\t\trcu_assign_pointer(net->bpf.run_array[type], run_array);\n\t}\n\n\tnet->bpf.progs[type] = prog;\n\tif (attached)\n\t\tbpf_prog_put(attached);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lirc_prog_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_get_from_fd",
          "args": [
            "attr",
            "prog"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_attach_check_attach_type",
          "args": [
            "prog",
            "attr->attach_type"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_attach_check_attach_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3110-3131",
          "snippet": "static int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->attach_bpf_fd",
            "ptype"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "586-598",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_type_to_prog_type",
          "args": [
            "attr->attach_type"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "attach_type_to_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3133-3186",
          "snippet": "static enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_ATTACH"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI | BPF_F_REPLACE)\n\nstatic int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tptype = attach_type_to_prog_type(attr->attach_type);\n\tif (ptype == BPF_PROG_TYPE_UNSPEC)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = netns_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "attach_type_to_prog_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3133-3186",
    "snippet": "static enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic enum bpf_prog_type\nattach_type_to_prog_type(enum bpf_attach_type attach_type)\n{\n\tswitch (attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\treturn BPF_PROG_TYPE_CGROUP_SKB;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_UDP4_RECVMSG:\n\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\treturn BPF_PROG_TYPE_SOCK_OPS;\n\tcase BPF_CGROUP_DEVICE:\n\t\treturn BPF_PROG_TYPE_CGROUP_DEVICE;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_MSG;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\tcase BPF_SK_SKB_VERDICT:\n\t\treturn BPF_PROG_TYPE_SK_SKB;\n\tcase BPF_LIRC_MODE2:\n\t\treturn BPF_PROG_TYPE_LIRC_MODE2;\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn BPF_PROG_TYPE_FLOW_DISSECTOR;\n\tcase BPF_CGROUP_SYSCTL:\n\t\treturn BPF_PROG_TYPE_CGROUP_SYSCTL;\n\tcase BPF_CGROUP_GETSOCKOPT:\n\tcase BPF_CGROUP_SETSOCKOPT:\n\t\treturn BPF_PROG_TYPE_CGROUP_SOCKOPT;\n\tcase BPF_TRACE_ITER:\n\t\treturn BPF_PROG_TYPE_TRACING;\n\tcase BPF_SK_LOOKUP:\n\t\treturn BPF_PROG_TYPE_SK_LOOKUP;\n\tcase BPF_XDP:\n\t\treturn BPF_PROG_TYPE_XDP;\n\tdefault:\n\t\treturn BPF_PROG_TYPE_UNSPEC;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_attach_check_attach_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3110-3131",
    "snippet": "static int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t/* cg-skb progs can be loaded by unpriv user.\n\t\t\t * check permissions at attach time.\n\t\t\t */\n\t\t\treturn -EPERM;\n\t\treturn prog->enforce_expected_attach_type &&\n\t\t\tprog->expected_attach_type != attach_type ?\n\t\t\t-EINVAL : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "bpf_raw_tracepoint_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "3021-3108",
    "snippet": "static int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_raw_tp_link *link;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tconst char *tp_name;\n\tchar buf[128];\n\tint err;\n\n\tif (CHECK_ATTR(BPF_RAW_TRACEPOINT_OPEN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->raw_tracepoint.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_EXT:\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (attr->raw_tracepoint.name) {\n\t\t\t/* The attach point for this category of programs\n\t\t\t * should be specified via btf_id during program load.\n\t\t\t */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tif (prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog->expected_attach_type == BPF_TRACE_RAW_TP) {\n\t\t\ttp_name = prog->aux->attach_func_name;\n\t\t\tbreak;\n\t\t}\n\t\terr = bpf_tracing_prog_attach(prog, 0, 0);\n\t\tif (err >= 0)\n\t\t\treturn err;\n\t\tgoto out_put_prog;\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\t\tif (strncpy_from_user(buf,\n\t\t\t\t      u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t\t      sizeof(buf) - 1) < 0) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\ttp_name = buf;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tbtp = bpf_get_raw_tracepoint(tp_name);\n\tif (!btp) {\n\t\terr = -ENOENT;\n\t\tgoto out_put_prog;\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_btp;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_RAW_TRACEPOINT,\n\t\t      &bpf_raw_tp_link_lops, prog);\n\tlink->btp = btp;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_btp;\n\t}\n\n\terr = bpf_probe_register(link->btp, prog);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_btp;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_btp:\n\tbpf_put_raw_tracepoint(btp);\nout_put_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_put_raw_tracepoint",
          "args": [
            "btp"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_put_raw_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "1973-1981",
          "snippet": "void bpf_put_raw_tracepoint(struct bpf_raw_event_map *btp)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)btp);\n\tmodule_put(mod);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_put_raw_tracepoint(struct bpf_raw_event_map *btp)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)btp);\n\tmodule_put(mod);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_probe_register",
          "args": [
            "link->btp",
            "prog"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_probe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "2055-2058",
          "snippet": "int bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\treturn __bpf_probe_register(btp, prog);\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\treturn __bpf_probe_register(btp, prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&link->link",
            "&link_primer"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&link->link",
            "BPF_LINK_TYPE_RAW_TRACEPOINT",
            "&bpf_raw_tp_link_lops",
            "prog"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_USER"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_raw_tracepoint",
          "args": [
            "tp_name"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_raw_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "1961-1971",
          "snippet": "struct bpf_raw_event_map *bpf_get_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\n\treturn bpf_get_raw_tracepoint_module(name);\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct bpf_raw_event_map __start__bpf_raw_tp[];",
            "extern struct bpf_raw_event_map __stop__bpf_raw_tp[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nextern struct bpf_raw_event_map __start__bpf_raw_tp[];\nextern struct bpf_raw_event_map __stop__bpf_raw_tp[];\n\nstruct bpf_raw_event_map *bpf_get_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\n\treturn bpf_get_raw_tracepoint_module(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "buf",
            "u64_to_user_ptr(attr->raw_tracepoint.name)",
            "sizeof(buf) - 1"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->raw_tracepoint.name"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_tracing_prog_attach",
          "args": [
            "prog",
            "0",
            "0"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_tracing_prog_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2696-2870",
          "snippet": "static int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};\n\nstatic int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->raw_tracepoint.prog_fd"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_RAW_TRACEPOINT_OPEN"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_raw_tp_link_lops = {\n\t.release = bpf_raw_tp_link_release,\n\t.dealloc = bpf_raw_tp_link_dealloc,\n\t.show_fdinfo = bpf_raw_tp_link_show_fdinfo,\n\t.fill_link_info = bpf_raw_tp_link_fill_link_info,\n};\n\nstatic int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_raw_tp_link *link;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tconst char *tp_name;\n\tchar buf[128];\n\tint err;\n\n\tif (CHECK_ATTR(BPF_RAW_TRACEPOINT_OPEN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->raw_tracepoint.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_EXT:\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (attr->raw_tracepoint.name) {\n\t\t\t/* The attach point for this category of programs\n\t\t\t * should be specified via btf_id during program load.\n\t\t\t */\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tif (prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog->expected_attach_type == BPF_TRACE_RAW_TP) {\n\t\t\ttp_name = prog->aux->attach_func_name;\n\t\t\tbreak;\n\t\t}\n\t\terr = bpf_tracing_prog_attach(prog, 0, 0);\n\t\tif (err >= 0)\n\t\t\treturn err;\n\t\tgoto out_put_prog;\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\t\tif (strncpy_from_user(buf,\n\t\t\t\t      u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t\t      sizeof(buf) - 1) < 0) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\ttp_name = buf;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tbtp = bpf_get_raw_tracepoint(tp_name);\n\tif (!btp) {\n\t\terr = -ENOENT;\n\t\tgoto out_put_prog;\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_btp;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_RAW_TRACEPOINT,\n\t\t      &bpf_raw_tp_link_lops, prog);\n\tlink->btp = btp;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_btp;\n\t}\n\n\terr = bpf_probe_register(link->btp, prog);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_btp;\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_btp:\n\tbpf_put_raw_tracepoint(btp);\nout_put_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_perf_link_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2973-3016",
    "snippet": "static int bpf_perf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_perf_link *link;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tperf_file = perf_event_get(attr->link_create.target_fd);\n\tif (IS_ERR(perf_file))\n\t\treturn PTR_ERR(perf_file);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_file;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_PERF_EVENT, &bpf_perf_link_lops, prog);\n\tlink->perf_file = perf_file;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_file;\n\t}\n\n\tevent = perf_file->private_data;\n\terr = perf_event_set_bpf_prog(event, prog, attr->link_create.perf_event.bpf_cookie);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_file;\n\t}\n\t/* perf_event_set_bpf_prog() doesn't take its own refcnt on prog */\n\tbpf_prog_inc(prog);\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_file:\n\tfput(perf_file);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "perf_file"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "prog"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_set_bpf_prog",
          "args": [
            "event",
            "prog",
            "attr->link_create.perf_event.bpf_cookie"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_set_bpf_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "10154-10158",
          "snippet": "int perf_event_set_bpf_prog(struct perf_event *event, struct bpf_prog *prog,\n\t\t\t    u64 bpf_cookie)\n{\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nint perf_event_set_bpf_prog(struct perf_event *event, struct bpf_prog *prog,\n\t\t\t    u64 bpf_cookie)\n{\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&link->link",
            "&link_primer"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&link->link",
            "BPF_LINK_TYPE_PERF_EVENT",
            "&bpf_perf_link_lops",
            "prog"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_USER"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "perf_file"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "perf_file"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_get",
          "args": [
            "attr->link_create.target_fd"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12898-12910",
          "snippet": "struct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static const struct file_operations perf_fops;",
            "static const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic const struct file_operations perf_fops;\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\nstruct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_perf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_perf_link *link;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tperf_file = perf_event_get(attr->link_create.target_fd);\n\tif (IS_ERR(perf_file))\n\t\treturn PTR_ERR(perf_file);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_file;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_PERF_EVENT, &bpf_perf_link_lops, prog);\n\tlink->perf_file = perf_file;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\tgoto out_put_file;\n\t}\n\n\tevent = perf_file->private_data;\n\terr = perf_event_set_bpf_prog(event, prog, attr->link_create.perf_event.bpf_cookie);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_file;\n\t}\n\t/* perf_event_set_bpf_prog() doesn't take its own refcnt on prog */\n\tbpf_prog_inc(prog);\n\n\treturn bpf_link_settle(&link_primer);\n\nout_put_file:\n\tfput(perf_file);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_perf_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2961-2966",
    "snippet": "static void bpf_perf_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_perf_link *perf_link = container_of(link, struct bpf_perf_link, link);\n\n\tkfree(perf_link);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "perf_link"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_perf_link",
            "link"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_perf_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_perf_link *perf_link = container_of(link, struct bpf_perf_link, link);\n\n\tkfree(perf_link);\n}"
  },
  {
    "function_name": "bpf_perf_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2952-2959",
    "snippet": "static void bpf_perf_link_release(struct bpf_link *link)\n{\n\tstruct bpf_perf_link *perf_link = container_of(link, struct bpf_perf_link, link);\n\tstruct perf_event *event = perf_link->perf_file->private_data;\n\n\tperf_event_free_bpf_prog(event);\n\tfput(perf_link->perf_file);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "perf_link->perf_file"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_free_bpf_prog",
          "args": [
            "event"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_free_bpf_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "10160-10162",
          "snippet": "void perf_event_free_bpf_prog(struct perf_event *event)\n{\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_free_bpf_prog(struct perf_event *event)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_perf_link",
            "link"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_perf_link_release(struct bpf_link *link)\n{\n\tstruct bpf_perf_link *perf_link = container_of(link, struct bpf_perf_link, link);\n\tstruct perf_event *event = perf_link->perf_file->private_data;\n\n\tperf_event_free_bpf_prog(event);\n\tfput(perf_link->perf_file);\n}"
  },
  {
    "function_name": "bpf_raw_tp_link_fill_link_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2905-2937",
    "snippet": "static int bpf_raw_tp_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t  struct bpf_link_info *info)\n{\n\tstruct bpf_raw_tp_link *raw_tp_link =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->raw_tracepoint.tp_name);\n\tconst char *tp_name = raw_tp_link->btp->tp->name;\n\tu32 ulen = info->raw_tracepoint.tp_name_len;\n\tsize_t tp_len = strlen(tp_name);\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\tinfo->raw_tracepoint.tp_name_len = tp_len + 1;\n\n\tif (!ubuf)\n\t\treturn 0;\n\n\tif (ulen >= tp_len + 1) {\n\t\tif (copy_to_user(ubuf, tp_name, tp_len + 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tchar zero = '\\0';\n\n\t\tif (copy_to_user(ubuf, tp_name, ulen - 1))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf + ulen - 1"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "tp_name",
            "ulen - 1"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tp_name"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info->raw_tracepoint.tp_name"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_raw_tp_link",
            "link"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_raw_tp_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t  struct bpf_link_info *info)\n{\n\tstruct bpf_raw_tp_link *raw_tp_link =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->raw_tracepoint.tp_name);\n\tconst char *tp_name = raw_tp_link->btp->tp->name;\n\tu32 ulen = info->raw_tracepoint.tp_name_len;\n\tsize_t tp_len = strlen(tp_name);\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\tinfo->raw_tracepoint.tp_name_len = tp_len + 1;\n\n\tif (!ubuf)\n\t\treturn 0;\n\n\tif (ulen >= tp_len + 1) {\n\t\tif (copy_to_user(ubuf, tp_name, tp_len + 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tchar zero = '\\0';\n\n\t\tif (copy_to_user(ubuf, tp_name, ulen - 1))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_raw_tp_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2894-2903",
    "snippet": "static void bpf_raw_tp_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\tstruct seq_file *seq)\n{\n\tstruct bpf_raw_tp_link *raw_tp_link =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tseq_printf(seq,\n\t\t   \"tp_name:\\t%s\\n\",\n\t\t   raw_tp_link->btp->tp->name);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"tp_name:\\t%s\\n\"",
            "raw_tp_link->btp->tp->name"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_raw_tp_link",
            "link"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_raw_tp_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\tstruct seq_file *seq)\n{\n\tstruct bpf_raw_tp_link *raw_tp_link =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tseq_printf(seq,\n\t\t   \"tp_name:\\t%s\\n\",\n\t\t   raw_tp_link->btp->tp->name);\n}"
  },
  {
    "function_name": "bpf_raw_tp_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2886-2892",
    "snippet": "static void bpf_raw_tp_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_raw_tp_link *raw_tp =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tkfree(raw_tp);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "raw_tp"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_raw_tp_link",
            "link"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_raw_tp_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_raw_tp_link *raw_tp =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tkfree(raw_tp);\n}"
  },
  {
    "function_name": "bpf_raw_tp_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2877-2884",
    "snippet": "static void bpf_raw_tp_link_release(struct bpf_link *link)\n{\n\tstruct bpf_raw_tp_link *raw_tp =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tbpf_probe_unregister(raw_tp->btp, raw_tp->link.prog);\n\tbpf_put_raw_tracepoint(raw_tp->btp);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_put_raw_tracepoint",
          "args": [
            "raw_tp->btp"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_put_raw_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "1973-1981",
          "snippet": "void bpf_put_raw_tracepoint(struct bpf_raw_event_map *btp)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)btp);\n\tmodule_put(mod);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_put_raw_tracepoint(struct bpf_raw_event_map *btp)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)btp);\n\tmodule_put(mod);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_probe_unregister",
          "args": [
            "raw_tp->btp",
            "raw_tp->link.prog"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_probe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/bpf_trace.c",
          "lines": "2060-2063",
          "snippet": "int bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\treturn tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n}",
          "includes": [
            "#include \"bpf_trace.h\"",
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <asm/tlb.h>",
            "#include <uapi/linux/btf.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <net/bpf_sk_storage.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_trace.h\"\n#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <asm/tlb.h>\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\treturn tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_raw_tp_link",
            "link"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_raw_tp_link_release(struct bpf_link *link)\n{\n\tstruct bpf_raw_tp_link *raw_tp =\n\t\tcontainer_of(link, struct bpf_raw_tp_link, link);\n\n\tbpf_probe_unregister(raw_tp->btp, raw_tp->link.prog);\n\tbpf_put_raw_tracepoint(raw_tp->btp);\n}"
  },
  {
    "function_name": "bpf_tracing_prog_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2696-2870",
    "snippet": "static int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "tgt_prog"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&prog->aux->dst_mutex"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_put",
          "args": [
            "tr"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "513-535",
          "snippet": "void bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(trampoline_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic DEFINE_MUTEX(trampoline_mutex);\n\nvoid bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_link_prog",
          "args": [
            "prog",
            "tr"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_link_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "422-468",
          "snippet": "int bpf_trampoline_link_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err = 0;\n\tint cnt;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (tr->extension_prog) {\n\t\t/* cannot attach fentry/fexit if extension prog is attached.\n\t\t * cannot overwrite extension prog either.\n\t\t */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tcnt = tr->progs_cnt[BPF_TRAMP_FENTRY] + tr->progs_cnt[BPF_TRAMP_FEXIT];\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\t/* Cannot attach extension if fentry/fexit are in use. */\n\t\tif (cnt) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\ttr->extension_prog = prog;\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP, NULL,\n\t\t\t\t\t prog->bpf_func);\n\t\tgoto out;\n\t}\n\tif (cnt >= BPF_MAX_TRAMP_PROGS) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\tif (!hlist_unhashed(&prog->aux->tramp_hlist)) {\n\t\t/* prog already linked */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\thlist_add_head(&prog->aux->tramp_hlist, &tr->progs_hlist[kind]);\n\ttr->progs_cnt[kind]++;\n\terr = bpf_trampoline_update(tr);\n\tif (err) {\n\t\thlist_del_init(&prog->aux->tramp_hlist);\n\t\ttr->progs_cnt[kind]--;\n\t}\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint bpf_trampoline_link_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err = 0;\n\tint cnt;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (tr->extension_prog) {\n\t\t/* cannot attach fentry/fexit if extension prog is attached.\n\t\t * cannot overwrite extension prog either.\n\t\t */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tcnt = tr->progs_cnt[BPF_TRAMP_FENTRY] + tr->progs_cnt[BPF_TRAMP_FEXIT];\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\t/* Cannot attach extension if fentry/fexit are in use. */\n\t\tif (cnt) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\ttr->extension_prog = prog;\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP, NULL,\n\t\t\t\t\t prog->bpf_func);\n\t\tgoto out;\n\t}\n\tif (cnt >= BPF_MAX_TRAMP_PROGS) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\tif (!hlist_unhashed(&prog->aux->tramp_hlist)) {\n\t\t/* prog already linked */\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\thlist_add_head(&prog->aux->tramp_hlist, &tr->progs_hlist[kind]);\n\ttr->progs_cnt[kind]++;\n\terr = bpf_trampoline_update(tr);\n\tif (err) {\n\t\thlist_del_init(&prog->aux->tramp_hlist);\n\t\ttr->progs_cnt[kind]--;\n\t}\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&link->link",
            "&link_primer"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_get",
          "args": [
            "key",
            "&tgt_info"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "493-511",
          "snippet": "struct bpf_trampoline *bpf_trampoline_get(u64 key,\n\t\t\t\t\t  struct bpf_attach_target_info *tgt_info)\n{\n\tstruct bpf_trampoline *tr;\n\n\ttr = bpf_trampoline_lookup(key);\n\tif (!tr)\n\t\treturn NULL;\n\n\tmutex_lock(&tr->mutex);\n\tif (tr->func.addr)\n\t\tgoto out;\n\n\tmemcpy(&tr->func.model, &tgt_info->fmodel, sizeof(tgt_info->fmodel));\n\ttr->func.addr = (void *)tgt_info->tgt_addr;\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn tr;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic __always_inline u64;\n\nstruct bpf_trampoline *bpf_trampoline_get(u64 key,\n\t\t\t\t\t  struct bpf_attach_target_info *tgt_info)\n{\n\tstruct bpf_trampoline *tr;\n\n\ttr = bpf_trampoline_lookup(key);\n\tif (!tr)\n\t\treturn NULL;\n\n\tmutex_lock(&tr->mutex);\n\tif (tr->func.addr)\n\t\tgoto out;\n\n\tmemcpy(&tr->func.model, &tgt_info->fmodel, sizeof(tgt_info->fmodel));\n\ttr->func.addr = (void *)tgt_info->tgt_addr;\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_check_attach_target",
          "args": [
            "NULL",
            "prog",
            "tgt_prog",
            "btf_id",
            "&tgt_info"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_attach_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "13875-14107",
          "snippet": "int bpf_check_attach_target(struct bpf_verifier_log *log,\n\t\t\t    const struct bpf_prog *prog,\n\t\t\t    const struct bpf_prog *tgt_prog,\n\t\t\t    u32 btf_id,\n\t\t\t    struct bpf_attach_target_info *tgt_info)\n{\n\tbool prog_extension = prog->type == BPF_PROG_TYPE_EXT;\n\tconst char prefix[] = \"btf_trace_\";\n\tint ret = 0, subprog = -1, i;\n\tconst struct btf_type *t;\n\tbool conservative = true;\n\tconst char *tname;\n\tstruct btf *btf;\n\tlong addr = 0;\n\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Tracing programs must provide btf_id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbtf = tgt_prog ? tgt_prog->aux->btf : prog->aux->attach_btf;\n\tif (!btf) {\n\t\tbpf_log(log,\n\t\t\t\"FENTRY/FEXIT program can only be attached to another program annotated with BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t) {\n\t\tbpf_log(log, \"attach_btf_id %u is invalid\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"attach_btf_id %u doesn't have a name\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\tif (tgt_prog) {\n\t\tstruct bpf_prog_aux *aux = tgt_prog->aux;\n\n\t\tfor (i = 0; i < aux->func_info_cnt; i++)\n\t\t\tif (aux->func_info[i].type_id == btf_id) {\n\t\t\t\tsubprog = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (subprog == -1) {\n\t\t\tbpf_log(log, \"Subprog %s doesn't exist\\n\", tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconservative = aux->func_info_aux[subprog].unreliable;\n\t\tif (prog_extension) {\n\t\t\tif (conservative) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Cannot replace static functions\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!prog->jit_requested) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Extension programs should be JITed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (!tgt_prog->jited) {\n\t\t\tbpf_log(log, \"Can attach to only JITed progs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == prog->type) {\n\t\t\t/* Cannot fentry/fexit another fentry/fexit program.\n\t\t\t * Cannot attach program extension to another extension.\n\t\t\t * It's ok to attach fentry/fexit to extension program.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot recursively attach\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog_extension &&\n\t\t    (tgt_prog->expected_attach_type == BPF_TRACE_FENTRY ||\n\t\t     tgt_prog->expected_attach_type == BPF_TRACE_FEXIT)) {\n\t\t\t/* Program extensions can extend all program types\n\t\t\t * except fentry/fexit. The reason is the following.\n\t\t\t * The fentry/fexit programs are used for performance\n\t\t\t * analysis, stats and can be attached to any program\n\t\t\t * type except themselves. When extension program is\n\t\t\t * replacing XDP function it is necessary to allow\n\t\t\t * performance analysis of all functions. Both original\n\t\t\t * XDP program and its program extension. Hence\n\t\t\t * attaching fentry/fexit to BPF_PROG_TYPE_EXT is\n\t\t\t * allowed. If extending of fentry/fexit was allowed it\n\t\t\t * would be possible to create long call chain\n\t\t\t * fentry->extension->fentry->extension beyond\n\t\t\t * reasonable stack size. Hence extending fentry is not\n\t\t\t * allowed.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot extend fentry/fexit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (prog_extension) {\n\t\t\tbpf_log(log, \"Cannot replace kernel functions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_RAW_TP:\n\t\tif (tgt_prog) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"Only FENTRY/FEXIT progs are attachable to another BPF prog\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_typedef(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a typedef\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strncmp(prefix, tname, sizeof(prefix) - 1)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u points to wrong type name %s\\n\",\n\t\t\t\tbtf_id, tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttname += sizeof(prefix) - 1;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_ptr(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase BPF_TRACE_ITER:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tif (!prog_extension)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase BPF_MODIFY_RETURN:\n\tcase BPF_LSM_MAC:\n\tcase BPF_TRACE_FENTRY:\n\tcase BPF_TRACE_FEXIT:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prog_extension &&\n\t\t    btf_check_type_match(log, prog, btf, t))\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\n\t\tif ((prog->aux->saved_dst_prog_type || prog->aux->saved_dst_attach_type) &&\n\t\t    (!tgt_prog || prog->aux->saved_dst_prog_type != tgt_prog->type ||\n\t\t     prog->aux->saved_dst_attach_type != tgt_prog->expected_attach_type))\n\t\t\treturn -EINVAL;\n\n\t\tif (tgt_prog && conservative)\n\t\t\tt = NULL;\n\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (tgt_prog) {\n\t\t\tif (subprog == 0)\n\t\t\t\taddr = (long) tgt_prog->bpf_func;\n\t\t\telse\n\t\t\t\taddr = (long) tgt_prog->aux->func[subprog]->bpf_func;\n\t\t} else {\n\t\t\taddr = kallsyms_lookup_name(tname);\n\t\t\tif (!addr) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"The address of function %s cannot be found\\n\",\n\t\t\t\t\ttname);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\n\t\tif (prog->aux->sleepable) {\n\t\t\tret = -EINVAL;\n\t\t\tswitch (prog->type) {\n\t\t\tcase BPF_PROG_TYPE_TRACING:\n\t\t\t\t/* fentry/fexit/fmod_ret progs can be sleepable only if they are\n\t\t\t\t * attached to ALLOW_ERROR_INJECTION and are not in denylist.\n\t\t\t\t */\n\t\t\t\tif (!check_non_sleepable_error_inject(btf_id) &&\n\t\t\t\t    within_error_injection_list(addr))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_PROG_TYPE_LSM:\n\t\t\t\t/* LSM progs check that they are attached to bpf_lsm_*() funcs.\n\t\t\t\t * Only some of them are sleepable.\n\t\t\t\t */\n\t\t\t\tif (bpf_lsm_is_sleepable_hook(btf_id))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s is not sleepable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (prog->expected_attach_type == BPF_MODIFY_RETURN) {\n\t\t\tif (tgt_prog) {\n\t\t\t\tbpf_log(log, \"can't modify return codes of BPF programs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = check_attach_modify_return(addr, tname);\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s() is not modifiable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\ttgt_info->tgt_addr = addr;\n\ttgt_info->tgt_name = tname;\n\ttgt_info->tgt_type = t;\n\treturn 0;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nint bpf_check_attach_target(struct bpf_verifier_log *log,\n\t\t\t    const struct bpf_prog *prog,\n\t\t\t    const struct bpf_prog *tgt_prog,\n\t\t\t    u32 btf_id,\n\t\t\t    struct bpf_attach_target_info *tgt_info)\n{\n\tbool prog_extension = prog->type == BPF_PROG_TYPE_EXT;\n\tconst char prefix[] = \"btf_trace_\";\n\tint ret = 0, subprog = -1, i;\n\tconst struct btf_type *t;\n\tbool conservative = true;\n\tconst char *tname;\n\tstruct btf *btf;\n\tlong addr = 0;\n\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Tracing programs must provide btf_id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbtf = tgt_prog ? tgt_prog->aux->btf : prog->aux->attach_btf;\n\tif (!btf) {\n\t\tbpf_log(log,\n\t\t\t\"FENTRY/FEXIT program can only be attached to another program annotated with BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t) {\n\t\tbpf_log(log, \"attach_btf_id %u is invalid\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"attach_btf_id %u doesn't have a name\\n\", btf_id);\n\t\treturn -EINVAL;\n\t}\n\tif (tgt_prog) {\n\t\tstruct bpf_prog_aux *aux = tgt_prog->aux;\n\n\t\tfor (i = 0; i < aux->func_info_cnt; i++)\n\t\t\tif (aux->func_info[i].type_id == btf_id) {\n\t\t\t\tsubprog = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (subprog == -1) {\n\t\t\tbpf_log(log, \"Subprog %s doesn't exist\\n\", tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconservative = aux->func_info_aux[subprog].unreliable;\n\t\tif (prog_extension) {\n\t\t\tif (conservative) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Cannot replace static functions\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!prog->jit_requested) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"Extension programs should be JITed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (!tgt_prog->jited) {\n\t\t\tbpf_log(log, \"Can attach to only JITed progs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == prog->type) {\n\t\t\t/* Cannot fentry/fexit another fentry/fexit program.\n\t\t\t * Cannot attach program extension to another extension.\n\t\t\t * It's ok to attach fentry/fexit to extension program.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot recursively attach\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_TRACING &&\n\t\t    prog_extension &&\n\t\t    (tgt_prog->expected_attach_type == BPF_TRACE_FENTRY ||\n\t\t     tgt_prog->expected_attach_type == BPF_TRACE_FEXIT)) {\n\t\t\t/* Program extensions can extend all program types\n\t\t\t * except fentry/fexit. The reason is the following.\n\t\t\t * The fentry/fexit programs are used for performance\n\t\t\t * analysis, stats and can be attached to any program\n\t\t\t * type except themselves. When extension program is\n\t\t\t * replacing XDP function it is necessary to allow\n\t\t\t * performance analysis of all functions. Both original\n\t\t\t * XDP program and its program extension. Hence\n\t\t\t * attaching fentry/fexit to BPF_PROG_TYPE_EXT is\n\t\t\t * allowed. If extending of fentry/fexit was allowed it\n\t\t\t * would be possible to create long call chain\n\t\t\t * fentry->extension->fentry->extension beyond\n\t\t\t * reasonable stack size. Hence extending fentry is not\n\t\t\t * allowed.\n\t\t\t */\n\t\t\tbpf_log(log, \"Cannot extend fentry/fexit\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (prog_extension) {\n\t\t\tbpf_log(log, \"Cannot replace kernel functions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (prog->expected_attach_type) {\n\tcase BPF_TRACE_RAW_TP:\n\t\tif (tgt_prog) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"Only FENTRY/FEXIT progs are attachable to another BPF prog\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_typedef(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a typedef\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strncmp(prefix, tname, sizeof(prefix) - 1)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u points to wrong type name %s\\n\",\n\t\t\t\tbtf_id, tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttname += sizeof(prefix) - 1;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_ptr(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\t/* should never happen in valid vmlinux build */\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase BPF_TRACE_ITER:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tif (!prog_extension)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase BPF_MODIFY_RETURN:\n\tcase BPF_LSM_MAC:\n\tcase BPF_TRACE_FENTRY:\n\tcase BPF_TRACE_FEXIT:\n\t\tif (!btf_type_is_func(t)) {\n\t\t\tbpf_log(log, \"attach_btf_id %u is not a function\\n\",\n\t\t\t\tbtf_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (prog_extension &&\n\t\t    btf_check_type_match(log, prog, btf, t))\n\t\t\treturn -EINVAL;\n\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (!btf_type_is_func_proto(t))\n\t\t\treturn -EINVAL;\n\n\t\tif ((prog->aux->saved_dst_prog_type || prog->aux->saved_dst_attach_type) &&\n\t\t    (!tgt_prog || prog->aux->saved_dst_prog_type != tgt_prog->type ||\n\t\t     prog->aux->saved_dst_attach_type != tgt_prog->expected_attach_type))\n\t\t\treturn -EINVAL;\n\n\t\tif (tgt_prog && conservative)\n\t\t\tt = NULL;\n\n\t\tret = btf_distill_func_proto(log, btf, t, tname, &tgt_info->fmodel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (tgt_prog) {\n\t\t\tif (subprog == 0)\n\t\t\t\taddr = (long) tgt_prog->bpf_func;\n\t\t\telse\n\t\t\t\taddr = (long) tgt_prog->aux->func[subprog]->bpf_func;\n\t\t} else {\n\t\t\taddr = kallsyms_lookup_name(tname);\n\t\t\tif (!addr) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"The address of function %s cannot be found\\n\",\n\t\t\t\t\ttname);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\n\t\tif (prog->aux->sleepable) {\n\t\t\tret = -EINVAL;\n\t\t\tswitch (prog->type) {\n\t\t\tcase BPF_PROG_TYPE_TRACING:\n\t\t\t\t/* fentry/fexit/fmod_ret progs can be sleepable only if they are\n\t\t\t\t * attached to ALLOW_ERROR_INJECTION and are not in denylist.\n\t\t\t\t */\n\t\t\t\tif (!check_non_sleepable_error_inject(btf_id) &&\n\t\t\t\t    within_error_injection_list(addr))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_PROG_TYPE_LSM:\n\t\t\t\t/* LSM progs check that they are attached to bpf_lsm_*() funcs.\n\t\t\t\t * Only some of them are sleepable.\n\t\t\t\t */\n\t\t\t\tif (bpf_lsm_is_sleepable_hook(btf_id))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s is not sleepable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (prog->expected_attach_type == BPF_MODIFY_RETURN) {\n\t\t\tif (tgt_prog) {\n\t\t\t\tbpf_log(log, \"can't modify return codes of BPF programs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = check_attach_modify_return(addr, tname);\n\t\t\tif (ret) {\n\t\t\t\tbpf_log(log, \"%s() is not modifiable\\n\", tname);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\ttgt_info->tgt_addr = addr;\n\ttgt_info->tgt_name = tname;\n\ttgt_info->tgt_type = t;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_compute_key",
          "args": [
            "NULL",
            "prog->aux->attach_btf",
            "btf_id"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&prog->aux->dst_mutex"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&link->link",
            "BPF_LINK_TYPE_TRACING",
            "&bpf_tracing_link_lops",
            "prog"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_USER"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_compute_key",
          "args": [
            "tgt_prog",
            "NULL",
            "btf_id"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tgt_prog"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tgt_prog"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "tgt_prog_fd"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_tracing_link_lops = {\n\t.release = bpf_tracing_link_release,\n\t.dealloc = bpf_tracing_link_dealloc,\n\t.show_fdinfo = bpf_tracing_link_show_fdinfo,\n\t.fill_link_info = bpf_tracing_link_fill_link_info,\n};\n\nstatic int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/* For now we only allow new targets for BPF_PROG_TYPE_EXT */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(prog, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_tracing_link_fill_link_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2675-2687",
    "snippet": "static int bpf_tracing_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t   struct bpf_link_info *info)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tinfo->tracing.attach_type = tr_link->attach_type;\n\tbpf_trampoline_unpack_key(tr_link->trampoline->key,\n\t\t\t\t  &info->tracing.target_obj_id,\n\t\t\t\t  &info->tracing.target_btf_id);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_trampoline_unpack_key",
          "args": [
            "tr_link->trampoline->key",
            "&info->tracing.target_obj_id",
            "&info->tracing.target_btf_id"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_tracing_link",
            "link"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_tracing_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\t   struct bpf_link_info *info)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tinfo->tracing.attach_type = tr_link->attach_type;\n\tbpf_trampoline_unpack_key(tr_link->trampoline->key,\n\t\t\t\t  &info->tracing.target_obj_id,\n\t\t\t\t  &info->tracing.target_btf_id);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_tracing_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2664-2673",
    "snippet": "static void bpf_tracing_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\t struct seq_file *seq)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tseq_printf(seq,\n\t\t   \"attach_type:\\t%d\\n\",\n\t\t   tr_link->attach_type);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"attach_type:\\t%d\\n\"",
            "tr_link->attach_type"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_tracing_link",
            "link"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_tracing_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t\t struct seq_file *seq)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tseq_printf(seq,\n\t\t   \"attach_type:\\t%d\\n\",\n\t\t   tr_link->attach_type);\n}"
  },
  {
    "function_name": "bpf_tracing_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2656-2662",
    "snippet": "static void bpf_tracing_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tkfree(tr_link);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr_link"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_tracing_link",
            "link"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_tracing_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tkfree(tr_link);\n}"
  },
  {
    "function_name": "bpf_tracing_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2641-2654",
    "snippet": "static void bpf_tracing_link_release(struct bpf_link *link)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tWARN_ON_ONCE(bpf_trampoline_unlink_prog(link->prog,\n\t\t\t\t\t\ttr_link->trampoline));\n\n\tbpf_trampoline_put(tr_link->trampoline);\n\n\t/* tgt_prog is NULL if target is a kernel function */\n\tif (tr_link->tgt_prog)\n\t\tbpf_prog_put(tr_link->tgt_prog);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "tr_link->tgt_prog"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_put",
          "args": [
            "tr_link->trampoline"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "513-535",
          "snippet": "void bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(trampoline_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic DEFINE_MUTEX(trampoline_mutex);\n\nvoid bpf_trampoline_put(struct bpf_trampoline *tr)\n{\n\tif (!tr)\n\t\treturn;\n\tmutex_lock(&trampoline_mutex);\n\tif (!refcount_dec_and_test(&tr->refcnt))\n\t\tgoto out;\n\tWARN_ON_ONCE(mutex_is_locked(&tr->mutex));\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FENTRY])))\n\t\tgoto out;\n\tif (WARN_ON_ONCE(!hlist_empty(&tr->progs_hlist[BPF_TRAMP_FEXIT])))\n\t\tgoto out;\n\t/* This code will be executed even when the last bpf_tramp_image\n\t * is alive. All progs are detached from the trampoline and the\n\t * trampoline image is patched with jmp into epilogue to skip\n\t * fexit progs. The fentry-only trampoline will be freed via\n\t * multiple rcu callbacks.\n\t */\n\thlist_del(&tr->hlist);\n\tkfree(tr);\nout:\n\tmutex_unlock(&trampoline_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bpf_trampoline_unlink_prog(link->prog,\n\t\t\t\t\t\ttr_link->trampoline)"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_trampoline_unlink_prog",
          "args": [
            "link->prog",
            "tr_link->trampoline"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_unlink_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "471-491",
          "snippet": "int bpf_trampoline_unlink_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\tWARN_ON_ONCE(!tr->extension_prog);\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP,\n\t\t\t\t\t tr->extension_prog->bpf_func, NULL);\n\t\ttr->extension_prog = NULL;\n\t\tgoto out;\n\t}\n\thlist_del_init(&prog->aux->tramp_hlist);\n\ttr->progs_cnt[kind]--;\n\terr = bpf_trampoline_update(tr);\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nint bpf_trampoline_unlink_prog(struct bpf_prog *prog, struct bpf_trampoline *tr)\n{\n\tenum bpf_tramp_prog_type kind;\n\tint err;\n\n\tkind = bpf_attach_type_to_tramp(prog);\n\tmutex_lock(&tr->mutex);\n\tif (kind == BPF_TRAMP_REPLACE) {\n\t\tWARN_ON_ONCE(!tr->extension_prog);\n\t\terr = bpf_arch_text_poke(tr->func.addr, BPF_MOD_JUMP,\n\t\t\t\t\t tr->extension_prog->bpf_func, NULL);\n\t\ttr->extension_prog = NULL;\n\t\tgoto out;\n\t}\n\thlist_del_init(&prog->aux->tramp_hlist);\n\ttr->progs_cnt[kind]--;\n\terr = bpf_trampoline_update(tr);\nout:\n\tmutex_unlock(&tr->mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_tracing_link",
            "link"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_tracing_link_release(struct bpf_link *link)\n{\n\tstruct bpf_tracing_link *tr_link =\n\t\tcontainer_of(link, struct bpf_tracing_link, link);\n\n\tWARN_ON_ONCE(bpf_trampoline_unlink_prog(link->prog,\n\t\t\t\t\t\ttr_link->trampoline));\n\n\tbpf_trampoline_put(tr_link->trampoline);\n\n\t/* tgt_prog is NULL if target is a kernel function */\n\tif (tr_link->tgt_prog)\n\t\tbpf_prog_put(tr_link->tgt_prog);\n}"
  },
  {
    "function_name": "bpf_link_get_from_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2615-2632",
    "snippet": "struct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_inc",
          "args": [
            "link"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4401-4404",
          "snippet": "static struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}"
  },
  {
    "function_name": "bpf_link_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2610-2613",
    "snippet": "int bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-link\"",
            "&bpf_link_fops",
            "link",
            "O_CLOEXEC"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}"
  },
  {
    "function_name": "bpf_link_settle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2598-2608",
    "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(link_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "primer->fd",
            "primer->file"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
  },
  {
    "function_name": "bpf_link_prime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2568-2596",
    "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_free_id",
          "args": [
            "id"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2426-2434",
          "snippet": "static void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "\"bpf_link\"",
            "&bpf_link_fops",
            "link",
            "O_CLOEXEC"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_alloc_id",
          "args": [
            "link"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2542-2553",
          "snippet": "static int bpf_link_alloc_id(struct bpf_link *link)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&link_idr_lock);\n\tid = idr_alloc_cyclic(&link_idr, link, 1, INT_MAX, GFP_ATOMIC);\n\tspin_unlock_bh(&link_idr_lock);\n\tidr_preload_end();\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic int bpf_link_alloc_id(struct bpf_link *link)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&link_idr_lock);\n\tid = idr_alloc_cyclic(&link_idr, link, 1, INT_MAX, GFP_ATOMIC);\n\tspin_unlock_bh(&link_idr_lock);\n\tidr_preload_end();\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "O_CLOEXEC"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_link_alloc_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2542-2553",
    "snippet": "static int bpf_link_alloc_id(struct bpf_link *link)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&link_idr_lock);\n\tid = idr_alloc_cyclic(&link_idr, link, 1, INT_MAX, GFP_ATOMIC);\n\tspin_unlock_bh(&link_idr_lock);\n\tidr_preload_end();\n\n\treturn id;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(link_idr);",
      "static DEFINE_SPINLOCK(link_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&link_idr",
            "link",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic int bpf_link_alloc_id(struct bpf_link *link)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&link_idr_lock);\n\tid = idr_alloc_cyclic(&link_idr, link, 1, INT_MAX, GFP_ATOMIC);\n\tspin_unlock_bh(&link_idr_lock);\n\tidr_preload_end();\n\n\treturn id;\n}"
  },
  {
    "function_name": "bpf_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2512-2530",
    "snippet": "static void bpf_link_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_link *link = filp->private_data;\n\tconst struct bpf_prog *prog = link->prog;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"link_type:\\t%s\\n\"\n\t\t   \"link_id:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"prog_id:\\t%u\\n\",\n\t\t   bpf_link_type_strs[link->type],\n\t\t   link->id,\n\t\t   prog_tag,\n\t\t   prog->aux->id);\n\tif (link->ops->show_fdinfo)\n\t\tlink->ops->show_fdinfo(link, m);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "link->ops->show_fdinfo",
          "args": [
            "link",
            "m"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"link_type:\\t%s\\n\"\n\t\t   \"link_id:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"prog_id:\\t%u\\n\"",
            "bpf_link_type_strs[link->type]",
            "link->id",
            "prog_tag",
            "prog->aux->id"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "prog_tag",
            "prog->tag",
            "sizeof(prog->tag)"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_link_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_link *link = filp->private_data;\n\tconst struct bpf_prog *prog = link->prog;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"link_type:\\t%s\\n\"\n\t\t   \"link_id:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"prog_id:\\t%u\\n\",\n\t\t   bpf_link_type_strs[link->type],\n\t\t   link->id,\n\t\t   prog_tag,\n\t\t   prog->aux->id);\n\tif (link->ops->show_fdinfo)\n\t\tlink->ops->show_fdinfo(link, m);\n}"
  },
  {
    "function_name": "bpf_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2492-2498",
    "snippet": "static int bpf_link_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_link *link = filp->private_data;\n\n\tbpf_link_put(link);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "link"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_link_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_link *link = filp->private_data;\n\n\tbpf_link_put(link);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_link_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2479-2490",
    "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_free",
          "args": [
            "link"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2457-2467",
          "snippet": "static void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&link->work"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&link->work",
            "bpf_link_put_deferred"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec_and_test",
          "args": [
            "&link->refcnt"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
  },
  {
    "function_name": "bpf_link_put_deferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2469-2474",
    "snippet": "static void bpf_link_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_link *link = container_of(work, struct bpf_link, work);\n\n\tbpf_link_free(link);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_free",
          "args": [
            "link"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2457-2467",
          "snippet": "static void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_link",
            "work"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_link_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_link *link = container_of(work, struct bpf_link, work);\n\n\tbpf_link_free(link);\n}"
  },
  {
    "function_name": "bpf_link_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2457-2467",
    "snippet": "static void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "link->ops->dealloc",
          "args": [
            "link"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "link->prog"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link->ops->release",
          "args": [
            "link"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_free_id",
          "args": [
            "link->id"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2426-2434",
          "snippet": "static void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_link_free(struct bpf_link *link)\n{\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\t/* detach BPF program, clean up used resources */\n\t\tlink->ops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\t/* free bpf_link and its containing memory */\n\tlink->ops->dealloc(link);\n}"
  },
  {
    "function_name": "bpf_link_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2451-2454",
    "snippet": "void bpf_link_inc(struct bpf_link *link)\n{\n\tatomic64_inc(&link->refcnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&link->refcnt"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_inc(struct bpf_link *link)\n{\n\tatomic64_inc(&link->refcnt);\n}"
  },
  {
    "function_name": "bpf_link_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2443-2449",
    "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "primer->fd"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "primer->file"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_free_id",
          "args": [
            "primer->id"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2426-2434",
          "snippet": "static void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
  },
  {
    "function_name": "bpf_link_free_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2426-2434",
    "snippet": "static void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(link_idr);",
      "static DEFINE_SPINLOCK(link_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&link_idr",
            "id"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&link_idr_lock"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstatic void bpf_link_free_id(int id)\n{\n\tif (!id)\n\t\treturn;\n\n\tspin_lock_bh(&link_idr_lock);\n\tidr_remove(&link_idr, id);\n\tspin_unlock_bh(&link_idr_lock);\n}"
  },
  {
    "function_name": "bpf_link_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2416-2424",
    "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&link->refcnt",
            "1"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
  },
  {
    "function_name": "bpf_obj_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2406-2414",
    "snippet": "static int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_obj_get_user",
          "args": [
            "u64_to_user_ptr(attr->pathname)",
            "attr->file_flags"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->pathname"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}"
  },
  {
    "function_name": "bpf_obj_pin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2398-2404",
    "snippet": "static int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_obj_pin_user",
          "args": [
            "attr->bpf_fd",
            "u64_to_user_ptr(attr->pathname)"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_pin_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "481-496",
          "snippet": "int bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tret = bpf_obj_do_pin(pathname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tret = bpf_obj_do_pin(pathname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->pathname"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}"
  },
  {
    "function_name": "bpf_prog_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2204-2394",
    "snippet": "static int bpf_prog_load(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog, *dst_prog = NULL;\n\tstruct btf *attach_btf = NULL;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT |\n\t\t\t\t BPF_F_ANY_ALIGNMENT |\n\t\t\t\t BPF_F_TEST_STATE_FREQ |\n\t\t\t\t BPF_F_SLEEPABLE |\n\t\t\t\t BPF_F_TEST_RND_HI32))\n\t\treturn -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&\n\t    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_bpfptr(license,\n\t\t\t\tmake_bpfptr(attr->license, uattr.is_kernel),\n\t\t\t\tsizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 ||\n\t    attr->insn_cnt > (bpf_capable() ? BPF_COMPLEXITY_LIMIT_INSNS : BPF_MAXINSNS))\n\t\treturn -E2BIG;\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\tif (is_net_admin_prog_type(type) && !capable(CAP_NET_ADMIN) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (is_perfmon_prog_type(type) && !perfmon_capable())\n\t\treturn -EPERM;\n\n\t/* attach_prog_fd/attach_btf_obj_fd can specify fd of either bpf_prog\n\t * or btf, we need to check which one it is\n\t */\n\tif (attr->attach_prog_fd) {\n\t\tdst_prog = bpf_prog_get(attr->attach_prog_fd);\n\t\tif (IS_ERR(dst_prog)) {\n\t\t\tdst_prog = NULL;\n\t\t\tattach_btf = btf_get_by_fd(attr->attach_btf_obj_fd);\n\t\t\tif (IS_ERR(attach_btf))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!btf_is_kernel(attach_btf)) {\n\t\t\t\t/* attaching through specifying bpf_prog's BTF\n\t\t\t\t * objects directly might be supported eventually\n\t\t\t\t */\n\t\t\t\tbtf_put(attach_btf);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t}\n\t} else if (attr->attach_btf_id) {\n\t\t/* fall back to vmlinux BTF, if BTF type ID is specified */\n\t\tattach_btf = bpf_get_btf_vmlinux();\n\t\tif (IS_ERR(attach_btf))\n\t\t\treturn PTR_ERR(attach_btf);\n\t\tif (!attach_btf)\n\t\t\treturn -EINVAL;\n\t\tbtf_get(attach_btf);\n\t}\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach(type, attr->expected_attach_type,\n\t\t\t\t       attach_btf, attr->attach_btf_id,\n\t\t\t\t       dst_prog)) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -EINVAL;\n\t}\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -ENOMEM;\n\t}\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\tprog->aux->attach_btf = attach_btf;\n\tprog->aux->attach_btf_id = attr->attach_btf_id;\n\tprog->aux->dst_prog = dst_prog;\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\tprog->aux->sleepable = attr->prog_flags & BPF_F_SLEEPABLE;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog;\n\n\tprog->aux->user = get_current_user();\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(prog->insns,\n\t\t\t     make_bpfptr(attr->insns, uattr.is_kernel),\n\t\t\t     bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog_sec;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic64_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog_sec;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\tprog->aux->load_time = ktime_get_boottime_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,\n\t\t\t       sizeof(attr->prog_name));\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr, uattr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\t/* Upon success of bpf_prog_alloc_id(), the BPF prog is\n\t * effectively publicly exposed. However, retrieving via\n\t * bpf_prog_get_fd_by_id() will take another reference,\n\t * therefore it cannot be gone underneath us.\n\t *\n\t * Only for the time /after/ successful bpf_prog_new_fd()\n\t * and before returning to userspace, we might just hold\n\t * one reference and any parallel close on that fd could\n\t * rip everything out. Hence, below notifications must\n\t * happen before bpf_prog_new_fd().\n\t *\n\t * Also, any failure handling from this point onwards must\n\t * be using bpf_prog_put() given the program is exposed.\n\t */\n\tbpf_prog_kallsyms_add(prog);\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_LOAD);\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0)\n\t\tbpf_prog_put(prog);\n\treturn err;\n\nfree_used_maps:\n\t/* In case we have subprogs, we need to wait for a grace\n\t * period before we can tear down JIT memory since symbols\n\t * are already exposed under kallsyms.\n\t */\n\t__bpf_prog_put_noref(prog, prog->aux->func_cnt);\n\treturn err;\nfree_prog_sec:\n\tfree_uid(prog->aux->user);\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog:\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\tbpf_prog_free(prog);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_free",
          "args": [
            "prog"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2304-2312",
          "snippet": "void bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tif (aux->dst_prog)\n\t\tbpf_prog_put(aux->dst_prog);\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tif (aux->dst_prog)\n\t\tbpf_prog_put(aux->dst_prog);\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "prog->aux->attach_btf"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_free",
          "args": [
            "prog->aux"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "prog->aux->user"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user.c",
          "lines": "178-187",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_prog_put_noref",
          "args": [
            "prog",
            "prog->aux->func_cnt"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put_noref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1779-1797",
          "snippet": "static void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_new_fd",
          "args": [
            "prog"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1915-1925",
          "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_audit_prog",
          "args": [
            "prog",
            "BPF_AUDIT_LOAD"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_audit_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1704-1721",
          "snippet": "static void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};\n\nstatic void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_bpf_event",
          "args": [
            "prog",
            "PERF_BPF_EVENT_PROG_LOAD",
            "0"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_bpf_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8956-8996",
          "snippet": "void perf_event_bpf_event(struct bpf_prog *prog,\n\t\t\t  enum perf_bpf_event_type type,\n\t\t\t  u16 flags)\n{\n\tstruct perf_bpf_event bpf_event;\n\n\tif (type <= PERF_BPF_EVENT_UNKNOWN ||\n\t    type >= PERF_BPF_EVENT_MAX)\n\t\treturn;\n\n\tswitch (type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\tif (atomic_read(&nr_ksymbol_events))\n\t\t\tperf_event_bpf_emit_ksymbols(prog, type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!atomic_read(&nr_bpf_events))\n\t\treturn;\n\n\tbpf_event = (struct perf_bpf_event){\n\t\t.prog = prog,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_BPF_EVENT,\n\t\t\t\t.size = sizeof(bpf_event.event_id),\n\t\t\t},\n\t\t\t.type = type,\n\t\t\t.flags = flags,\n\t\t\t.id = prog->aux->id,\n\t\t},\n\t};\n\n\tBUILD_BUG_ON(BPF_TAG_SIZE % sizeof(u64));\n\n\tmemcpy(bpf_event.event_id.tag, prog->tag, BPF_TAG_SIZE);\n\tperf_iterate_sb(perf_event_bpf_output, &bpf_event, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static atomic_t nr_bpf_events",
            "static __always_inline enum",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic atomic_t nr_bpf_events;\nstatic __always_inline enum;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_bpf_event(struct bpf_prog *prog,\n\t\t\t  enum perf_bpf_event_type type,\n\t\t\t  u16 flags)\n{\n\tstruct perf_bpf_event bpf_event;\n\n\tif (type <= PERF_BPF_EVENT_UNKNOWN ||\n\t    type >= PERF_BPF_EVENT_MAX)\n\t\treturn;\n\n\tswitch (type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\tif (atomic_read(&nr_ksymbol_events))\n\t\t\tperf_event_bpf_emit_ksymbols(prog, type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!atomic_read(&nr_bpf_events))\n\t\treturn;\n\n\tbpf_event = (struct perf_bpf_event){\n\t\t.prog = prog,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_BPF_EVENT,\n\t\t\t\t.size = sizeof(bpf_event.event_id),\n\t\t\t},\n\t\t\t.type = type,\n\t\t\t.flags = flags,\n\t\t\t.id = prog->aux->id,\n\t\t},\n\t};\n\n\tBUILD_BUG_ON(BPF_TAG_SIZE % sizeof(u64));\n\n\tmemcpy(bpf_event.event_id.tag, prog->tag, BPF_TAG_SIZE);\n\tperf_iterate_sb(perf_event_bpf_output, &bpf_event, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_add",
          "args": [
            "prog"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "657-668",
          "snippet": "void bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !bpf_capable())\n\t\treturn;\n\n\tbpf_prog_ksym_set_addr(fp);\n\tbpf_prog_ksym_set_name(fp);\n\tfp->aux->ksym.prog = true;\n\n\tbpf_ksym_add(&fp->aux->ksym);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !bpf_capable())\n\t\treturn;\n\n\tbpf_prog_ksym_set_addr(fp);\n\tbpf_prog_ksym_set_name(fp);\n\tfp->aux->ksym.prog = true;\n\n\tbpf_ksym_add(&fp->aux->ksym);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_alloc_id",
          "args": [
            "prog"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1723-1740",
          "snippet": "static int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_select_runtime",
          "args": [
            "prog",
            "&err"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_select_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1904-1954",
          "snippet": "struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tbool jit_needed = false;\n\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tif (IS_ENABLED(CONFIG_BPF_JIT_ALWAYS_ON) ||\n\t    bpf_prog_has_kfunc_call(fp))\n\t\tjit_needed = true;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\t*err = bpf_prog_alloc_jited_linfo(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\n\t\tfp = bpf_int_jit_compile(fp);\n\t\tbpf_prog_jit_attempt_done(fp);\n\t\tif (!fp->jited && jit_needed) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstruct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tbool jit_needed = false;\n\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tif (IS_ENABLED(CONFIG_BPF_JIT_ALWAYS_ON) ||\n\t    bpf_prog_has_kfunc_call(fp))\n\t\tjit_needed = true;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\t*err = bpf_prog_alloc_jited_linfo(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\n\t\tfp = bpf_int_jit_compile(fp);\n\t\tbpf_prog_jit_attempt_done(fp);\n\t\tif (!fp->jited && jit_needed) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_check",
          "args": [
            "&prog",
            "attr",
            "uattr"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "77-98",
          "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_name_cpy",
          "args": [
            "prog->aux->name",
            "attr->prog_name",
            "sizeof(attr->prog_name)"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_name_cpy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "742-761",
          "snippet": "int bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_boottime_ns",
          "args": [],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prog_type",
          "args": [
            "type",
            "prog"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "find_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1674-1691",
          "snippet": "static int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};\n\nstatic int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_init",
          "args": [
            "prog",
            "attr"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "80-125",
          "snippet": "int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr)\n{\n\tstruct bpf_offload_netdev *ondev;\n\tstruct bpf_prog_offload *offload;\n\tint err;\n\n\tif (attr->prog_type != BPF_PROG_TYPE_SCHED_CLS &&\n\t    attr->prog_type != BPF_PROG_TYPE_XDP)\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags)\n\t\treturn -EINVAL;\n\n\toffload = kzalloc(sizeof(*offload), GFP_USER);\n\tif (!offload)\n\t\treturn -ENOMEM;\n\n\toffload->prog = prog;\n\n\toffload->netdev = dev_get_by_index(current->nsproxy->net_ns,\n\t\t\t\t\t   attr->prog_ifindex);\n\terr = bpf_dev_offload_check(offload->netdev);\n\tif (err)\n\t\tgoto err_maybe_put;\n\n\tdown_write(&bpf_devs_lock);\n\tondev = bpf_offload_find_netdev(offload->netdev);\n\tif (!ondev) {\n\t\terr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\toffload->offdev = ondev->offdev;\n\tprog->aux->offload = offload;\n\tlist_add_tail(&offload->offloads, &ondev->progs);\n\tdev_put(offload->netdev);\n\tup_write(&bpf_devs_lock);\n\n\treturn 0;\nerr_unlock:\n\tup_write(&bpf_devs_lock);\nerr_maybe_put:\n\tif (offload->netdev)\n\t\tdev_put(offload->netdev);\n\tkfree(offload);\n\treturn err;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr)\n{\n\tstruct bpf_offload_netdev *ondev;\n\tstruct bpf_prog_offload *offload;\n\tint err;\n\n\tif (attr->prog_type != BPF_PROG_TYPE_SCHED_CLS &&\n\t    attr->prog_type != BPF_PROG_TYPE_XDP)\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags)\n\t\treturn -EINVAL;\n\n\toffload = kzalloc(sizeof(*offload), GFP_USER);\n\tif (!offload)\n\t\treturn -ENOMEM;\n\n\toffload->prog = prog;\n\n\toffload->netdev = dev_get_by_index(current->nsproxy->net_ns,\n\t\t\t\t\t   attr->prog_ifindex);\n\terr = bpf_dev_offload_check(offload->netdev);\n\tif (err)\n\t\tgoto err_maybe_put;\n\n\tdown_write(&bpf_devs_lock);\n\tondev = bpf_offload_find_netdev(offload->netdev);\n\tif (!ondev) {\n\t\terr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\toffload->offdev = ondev->offdev;\n\tprog->aux->offload = offload;\n\tlist_add_tail(&offload->offloads, &ondev->progs);\n\tdev_put(offload->netdev);\n\tup_write(&bpf_devs_lock);\n\n\treturn 0;\nerr_unlock:\n\tup_write(&bpf_devs_lock);\nerr_maybe_put:\n\tif (offload->netdev)\n\t\tdev_put(offload->netdev);\n\tkfree(offload);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&prog->aux->refcnt",
            "1"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_bpfptr",
          "args": [
            "prog->insns",
            "make_bpfptr(attr->insns, uattr.is_kernel)",
            "bpf_prog_insn_size(prog)"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->insns",
            "uattr.is_kernel"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_alloc",
          "args": [
            "prog->aux"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_alloc",
          "args": [
            "bpf_prog_size(attr->insn_cnt)",
            "GFP_USER"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "116-141",
          "snippet": "struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL_ACCOUNT | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *prog;\n\tint cpu;\n\n\tprog = bpf_prog_alloc_no_stats(size, gfp_extra_flags);\n\tif (!prog)\n\t\treturn NULL;\n\n\tprog->stats = alloc_percpu_gfp(struct bpf_prog_stats, gfp_flags);\n\tif (!prog->stats) {\n\t\tfree_percpu(prog->active);\n\t\tkfree(prog->aux);\n\t\tvfree(prog);\n\t\treturn NULL;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_prog_stats *pstats;\n\n\t\tpstats = per_cpu_ptr(prog->stats, cpu);\n\t\tu64_stats_init(&pstats->syncp);\n\t}\n\treturn prog;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstruct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL_ACCOUNT | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog *prog;\n\tint cpu;\n\n\tprog = bpf_prog_alloc_no_stats(size, gfp_extra_flags);\n\tif (!prog)\n\t\treturn NULL;\n\n\tprog->stats = alloc_percpu_gfp(struct bpf_prog_stats, gfp_flags);\n\tif (!prog->stats) {\n\t\tfree_percpu(prog->active);\n\t\tkfree(prog->aux);\n\t\tvfree(prog);\n\t\treturn NULL;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct bpf_prog_stats *pstats;\n\n\t\tpstats = per_cpu_ptr(prog->stats, cpu);\n\t\tu64_stats_init(&pstats->syncp);\n\t}\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_size",
          "args": [
            "attr->insn_cnt"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_load_check_attach",
          "args": [
            "type",
            "attr->expected_attach_type",
            "attach_btf",
            "attr->attach_btf_id",
            "dst_prog"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_load_check_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2054-2150",
          "snippet": "static int\nbpf_prog_load_check_attach(enum bpf_prog_type prog_type,\n\t\t\t   enum bpf_attach_type expected_attach_type,\n\t\t\t   struct btf *attach_btf, u32 btf_id,\n\t\t\t   struct bpf_prog *dst_prog)\n{\n\tif (btf_id) {\n\t\tif (btf_id > BTF_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (!attach_btf && !dst_prog)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_TRACING:\n\t\tcase BPF_PROG_TYPE_LSM:\n\t\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\tcase BPF_PROG_TYPE_EXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attach_btf && (!btf_id || dst_prog))\n\t\treturn -EINVAL;\n\n\tif (dst_prog && prog_type != BPF_PROG_TYPE_TRACING &&\n\t    prog_type != BPF_PROG_TYPE_EXT)\n\t\treturn -EINVAL;\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\t\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tcase BPF_CGROUP_UDP4_RECVMSG:\n\t\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_INGRESS:\n\t\tcase BPF_CGROUP_INET_EGRESS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_SETSOCKOPT:\n\t\tcase BPF_CGROUP_GETSOCKOPT:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tif (expected_attach_type == BPF_SK_LOOKUP)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_SK_REUSEPORT_SELECT:\n\t\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SYSCALL:\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (expected_attach_type)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int\nbpf_prog_load_check_attach(enum bpf_prog_type prog_type,\n\t\t\t   enum bpf_attach_type expected_attach_type,\n\t\t\t   struct btf *attach_btf, u32 btf_id,\n\t\t\t   struct bpf_prog *dst_prog)\n{\n\tif (btf_id) {\n\t\tif (btf_id > BTF_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (!attach_btf && !dst_prog)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_TRACING:\n\t\tcase BPF_PROG_TYPE_LSM:\n\t\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\tcase BPF_PROG_TYPE_EXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attach_btf && (!btf_id || dst_prog))\n\t\treturn -EINVAL;\n\n\tif (dst_prog && prog_type != BPF_PROG_TYPE_TRACING &&\n\t    prog_type != BPF_PROG_TYPE_EXT)\n\t\treturn -EINVAL;\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\t\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tcase BPF_CGROUP_UDP4_RECVMSG:\n\t\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_INGRESS:\n\t\tcase BPF_CGROUP_INET_EGRESS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_SETSOCKOPT:\n\t\tcase BPF_CGROUP_GETSOCKOPT:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tif (expected_attach_type == BPF_SK_LOOKUP)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_SK_REUSEPORT_SELECT:\n\t\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SYSCALL:\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (expected_attach_type)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_load_fixup_attach_type",
          "args": [
            "attr"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_load_fixup_attach_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2035-2052",
          "snippet": "static void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_SK_REUSEPORT_SELECT;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_SK_REUSEPORT_SELECT;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_get",
          "args": [
            "attach_btf"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4044-4053",
          "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "attach_btf"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "attach_btf"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_btf_vmlinux",
          "args": [],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_btf_vmlinux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "14201-14210",
          "snippet": "struct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct btf *btf_vmlinux;",
            "static DEFINE_MUTEX(bpf_verifier_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstruct btf *btf_vmlinux;\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\nstruct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_is_kernel",
          "args": [
            "attach_btf"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "btf_is_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6181-6184",
          "snippet": "bool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "attach_btf"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_get_by_fd",
          "args": [
            "attr->attach_btf_obj_fd"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6073-6093",
          "snippet": "struct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst_prog"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->attach_prog_fd"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perfmon_capable",
          "args": [],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_perfmon_prog_type",
          "args": [
            "type"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "is_perfmon_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2183-2199",
          "snippet": "static bool is_perfmon_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_LSM:\n\tcase BPF_PROG_TYPE_STRUCT_OPS: /* has access to struct sock */\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic bool is_perfmon_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_LSM:\n\tcase BPF_PROG_TYPE_STRUCT_OPS: /* has access to struct sock */\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_net_admin_prog_type",
          "args": [
            "type"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "is_net_admin_prog_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2152-2181",
          "snippet": "static bool is_net_admin_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\t/* always unpriv */\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\t/* equivalent to SOCKET_FILTER. need CAP_BPF only */\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic bool is_net_admin_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\t/* always unpriv */\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\t/* equivalent to SOCKET_FILTER. need CAP_BPF only */\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "license_is_gpl_compatible",
          "args": [
            "license"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_bpfptr",
          "args": [
            "license",
            "make_bpfptr(attr->license, uattr.is_kernel)",
            "sizeof(license) - 1"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->license",
            "uattr.is_kernel"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_LOAD"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_load(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog, *dst_prog = NULL;\n\tstruct btf *attach_btf = NULL;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~(BPF_F_STRICT_ALIGNMENT |\n\t\t\t\t BPF_F_ANY_ALIGNMENT |\n\t\t\t\t BPF_F_TEST_STATE_FREQ |\n\t\t\t\t BPF_F_SLEEPABLE |\n\t\t\t\t BPF_F_TEST_RND_HI32))\n\t\treturn -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &&\n\t    (attr->prog_flags & BPF_F_ANY_ALIGNMENT) &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_bpfptr(license,\n\t\t\t\tmake_bpfptr(attr->license, uattr.is_kernel),\n\t\t\t\tsizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 ||\n\t    attr->insn_cnt > (bpf_capable() ? BPF_COMPLEXITY_LIMIT_INSNS : BPF_MAXINSNS))\n\t\treturn -E2BIG;\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !bpf_capable())\n\t\treturn -EPERM;\n\n\tif (is_net_admin_prog_type(type) && !capable(CAP_NET_ADMIN) && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (is_perfmon_prog_type(type) && !perfmon_capable())\n\t\treturn -EPERM;\n\n\t/* attach_prog_fd/attach_btf_obj_fd can specify fd of either bpf_prog\n\t * or btf, we need to check which one it is\n\t */\n\tif (attr->attach_prog_fd) {\n\t\tdst_prog = bpf_prog_get(attr->attach_prog_fd);\n\t\tif (IS_ERR(dst_prog)) {\n\t\t\tdst_prog = NULL;\n\t\t\tattach_btf = btf_get_by_fd(attr->attach_btf_obj_fd);\n\t\t\tif (IS_ERR(attach_btf))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!btf_is_kernel(attach_btf)) {\n\t\t\t\t/* attaching through specifying bpf_prog's BTF\n\t\t\t\t * objects directly might be supported eventually\n\t\t\t\t */\n\t\t\t\tbtf_put(attach_btf);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t}\n\t} else if (attr->attach_btf_id) {\n\t\t/* fall back to vmlinux BTF, if BTF type ID is specified */\n\t\tattach_btf = bpf_get_btf_vmlinux();\n\t\tif (IS_ERR(attach_btf))\n\t\t\treturn PTR_ERR(attach_btf);\n\t\tif (!attach_btf)\n\t\t\treturn -EINVAL;\n\t\tbtf_get(attach_btf);\n\t}\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach(type, attr->expected_attach_type,\n\t\t\t\t       attach_btf, attr->attach_btf_id,\n\t\t\t\t       dst_prog)) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -EINVAL;\n\t}\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog) {\n\t\tif (dst_prog)\n\t\t\tbpf_prog_put(dst_prog);\n\t\tif (attach_btf)\n\t\t\tbtf_put(attach_btf);\n\t\treturn -ENOMEM;\n\t}\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\tprog->aux->attach_btf = attach_btf;\n\tprog->aux->attach_btf_id = attr->attach_btf_id;\n\tprog->aux->dst_prog = dst_prog;\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\tprog->aux->sleepable = attr->prog_flags & BPF_F_SLEEPABLE;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog;\n\n\tprog->aux->user = get_current_user();\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(prog->insns,\n\t\t\t     make_bpfptr(attr->insns, uattr.is_kernel),\n\t\t\t     bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog_sec;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic64_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog_sec;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\tprog->aux->load_time = ktime_get_boottime_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,\n\t\t\t       sizeof(attr->prog_name));\n\tif (err < 0)\n\t\tgoto free_prog_sec;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr, uattr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\t/* Upon success of bpf_prog_alloc_id(), the BPF prog is\n\t * effectively publicly exposed. However, retrieving via\n\t * bpf_prog_get_fd_by_id() will take another reference,\n\t * therefore it cannot be gone underneath us.\n\t *\n\t * Only for the time /after/ successful bpf_prog_new_fd()\n\t * and before returning to userspace, we might just hold\n\t * one reference and any parallel close on that fd could\n\t * rip everything out. Hence, below notifications must\n\t * happen before bpf_prog_new_fd().\n\t *\n\t * Also, any failure handling from this point onwards must\n\t * be using bpf_prog_put() given the program is exposed.\n\t */\n\tbpf_prog_kallsyms_add(prog);\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_LOAD);\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0)\n\t\tbpf_prog_put(prog);\n\treturn err;\n\nfree_used_maps:\n\t/* In case we have subprogs, we need to wait for a grace\n\t * period before we can tear down JIT memory since symbols\n\t * are already exposed under kallsyms.\n\t */\n\t__bpf_prog_put_noref(prog, prog->aux->func_cnt);\n\treturn err;\nfree_prog_sec:\n\tfree_uid(prog->aux->user);\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog:\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\tbpf_prog_free(prog);\n\treturn err;\n}"
  },
  {
    "function_name": "is_perfmon_prog_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2183-2199",
    "snippet": "static bool is_perfmon_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_LSM:\n\tcase BPF_PROG_TYPE_STRUCT_OPS: /* has access to struct sock */\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic bool is_perfmon_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_KPROBE:\n\tcase BPF_PROG_TYPE_TRACEPOINT:\n\tcase BPF_PROG_TYPE_PERF_EVENT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT:\n\tcase BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE:\n\tcase BPF_PROG_TYPE_TRACING:\n\tcase BPF_PROG_TYPE_LSM:\n\tcase BPF_PROG_TYPE_STRUCT_OPS: /* has access to struct sock */\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "is_net_admin_prog_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2152-2181",
    "snippet": "static bool is_net_admin_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\t/* always unpriv */\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\t/* equivalent to SOCKET_FILTER. need CAP_BPF only */\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic bool is_net_admin_prog_type(enum bpf_prog_type prog_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\tcase BPF_PROG_TYPE_LWT_SEG6LOCAL:\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\tcase BPF_PROG_TYPE_CGROUP_DEVICE:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\tcase BPF_PROG_TYPE_CGROUP_SYSCTL:\n\tcase BPF_PROG_TYPE_SOCK_OPS:\n\tcase BPF_PROG_TYPE_EXT: /* extends any prog */\n\t\treturn true;\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\t/* always unpriv */\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\t/* equivalent to SOCKET_FILTER. need CAP_BPF only */\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_load_check_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2054-2150",
    "snippet": "static int\nbpf_prog_load_check_attach(enum bpf_prog_type prog_type,\n\t\t\t   enum bpf_attach_type expected_attach_type,\n\t\t\t   struct btf *attach_btf, u32 btf_id,\n\t\t\t   struct bpf_prog *dst_prog)\n{\n\tif (btf_id) {\n\t\tif (btf_id > BTF_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (!attach_btf && !dst_prog)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_TRACING:\n\t\tcase BPF_PROG_TYPE_LSM:\n\t\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\tcase BPF_PROG_TYPE_EXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attach_btf && (!btf_id || dst_prog))\n\t\treturn -EINVAL;\n\n\tif (dst_prog && prog_type != BPF_PROG_TYPE_TRACING &&\n\t    prog_type != BPF_PROG_TYPE_EXT)\n\t\treturn -EINVAL;\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\t\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tcase BPF_CGROUP_UDP4_RECVMSG:\n\t\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_INGRESS:\n\t\tcase BPF_CGROUP_INET_EGRESS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_SETSOCKOPT:\n\t\tcase BPF_CGROUP_GETSOCKOPT:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tif (expected_attach_type == BPF_SK_LOOKUP)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_SK_REUSEPORT_SELECT:\n\t\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SYSCALL:\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (expected_attach_type)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int\nbpf_prog_load_check_attach(enum bpf_prog_type prog_type,\n\t\t\t   enum bpf_attach_type expected_attach_type,\n\t\t\t   struct btf *attach_btf, u32 btf_id,\n\t\t\t   struct bpf_prog *dst_prog)\n{\n\tif (btf_id) {\n\t\tif (btf_id > BTF_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (!attach_btf && !dst_prog)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (prog_type) {\n\t\tcase BPF_PROG_TYPE_TRACING:\n\t\tcase BPF_PROG_TYPE_LSM:\n\t\tcase BPF_PROG_TYPE_STRUCT_OPS:\n\t\tcase BPF_PROG_TYPE_EXT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attach_btf && (!btf_id || dst_prog))\n\t\treturn -EINVAL;\n\n\tif (dst_prog && prog_type != BPF_PROG_TYPE_TRACING &&\n\t    prog_type != BPF_PROG_TYPE_EXT)\n\t\treturn -EINVAL;\n\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET_SOCK_RELEASE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_INET4_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET6_GETPEERNAME:\n\t\tcase BPF_CGROUP_INET4_GETSOCKNAME:\n\t\tcase BPF_CGROUP_INET6_GETSOCKNAME:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tcase BPF_CGROUP_UDP4_RECVMSG:\n\t\tcase BPF_CGROUP_UDP6_RECVMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SKB:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_INGRESS:\n\t\tcase BPF_CGROUP_INET_EGRESS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCKOPT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_SETSOCKOPT:\n\t\tcase BPF_CGROUP_GETSOCKOPT:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SK_LOOKUP:\n\t\tif (expected_attach_type == BPF_SK_LOOKUP)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_SK_REUSEPORT_SELECT:\n\t\tcase BPF_SK_REUSEPORT_SELECT_OR_MIGRATE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_SYSCALL:\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (expected_attach_type)\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_load_fixup_attach_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2035-2052",
    "snippet": "static void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_SK_REUSEPORT_SELECT;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\tcase BPF_PROG_TYPE_SK_REUSEPORT:\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_SK_REUSEPORT_SELECT;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_get_type_dev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2016-2020",
    "snippet": "struct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_get",
          "args": [
            "ufd",
            "&type",
            "attach_drv"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1991-2009",
          "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}"
  },
  {
    "function_name": "bpf_prog_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "2011-2014",
    "snippet": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\treturn __bpf_prog_get(ufd, NULL, false);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_get",
          "args": [
            "ufd",
            "NULL",
            "false"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1991-2009",
          "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\treturn __bpf_prog_get(ufd, NULL, false);\n}"
  },
  {
    "function_name": "__bpf_prog_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1991-2009",
    "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "prog"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_ok",
          "args": [
            "prog",
            "attach_type",
            "attach_drv"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1976-1989",
          "snippet": "bool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nbool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "____bpf_prog_get",
          "args": [
            "f"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "____bpf_prog_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1927-1937",
          "snippet": "static struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tbpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_prog_get_ok",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1976-1989",
    "snippet": "bool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nbool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "bpf_prog_inc_not_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1963-1973",
    "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_fetch_add_unless",
          "args": [
            "&prog->aux->refcnt",
            "1",
            "0"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_prog_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1956-1959",
    "snippet": "void bpf_prog_inc(struct bpf_prog *prog)\n{\n\tatomic64_inc(&prog->aux->refcnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&prog->aux->refcnt"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_inc(struct bpf_prog *prog)\n{\n\tatomic64_inc(&prog->aux->refcnt);\n}"
  },
  {
    "function_name": "bpf_prog_sub",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1945-1953",
    "snippet": "void bpf_prog_sub(struct bpf_prog *prog, int i)\n{\n\t/* Only to be used for undoing previous bpf_prog_add() in some\n\t * error path. We still know that another entity in our call\n\t * path holds a reference to the program, thus atomic_sub() can\n\t * be safely used in such cases!\n\t */\n\tWARN_ON(atomic64_sub_return(i, &prog->aux->refcnt) == 0);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic64_sub_return(i, &prog->aux->refcnt) == 0"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_sub_return",
          "args": [
            "i",
            "&prog->aux->refcnt"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_sub(struct bpf_prog *prog, int i)\n{\n\t/* Only to be used for undoing previous bpf_prog_add() in some\n\t * error path. We still know that another entity in our call\n\t * path holds a reference to the program, thus atomic_sub() can\n\t * be safely used in such cases!\n\t */\n\tWARN_ON(atomic64_sub_return(i, &prog->aux->refcnt) == 0);\n}"
  },
  {
    "function_name": "bpf_prog_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1939-1942",
    "snippet": "void bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tatomic64_add(i, &prog->aux->refcnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "i",
            "&prog->aux->refcnt"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tatomic64_add(i, &prog->aux->refcnt);\n}"
  },
  {
    "function_name": "____bpf_prog_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1927-1937",
    "snippet": "static struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
  },
  {
    "function_name": "bpf_prog_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1915-1925",
    "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-prog\"",
            "&bpf_prog_fops",
            "prog",
            "O_RDWR | O_CLOEXEC"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_prog",
          "args": [
            "prog"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
  },
  {
    "function_name": "bpf_prog_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1876-1903",
    "snippet": "static void bpf_prog_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_prog *prog = filp->private_data;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\tstruct bpf_prog_kstats stats;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\"\n\t\t   \"run_time_ns:\\t%llu\\n\"\n\t\t   \"run_cnt:\\t%llu\\n\"\n\t\t   \"recursion_misses:\\t%llu\\n\"\n\t\t   \"verified_insns:\\t%u\\n\",\n\t\t   prog->type,\n\t\t   prog->jited,\n\t\t   prog_tag,\n\t\t   prog->pages * 1ULL << PAGE_SHIFT,\n\t\t   prog->aux->id,\n\t\t   stats.nsecs,\n\t\t   stats.cnt,\n\t\t   stats.misses,\n\t\t   prog->aux->verified_insns);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\"\n\t\t   \"run_time_ns:\\t%llu\\n\"\n\t\t   \"run_cnt:\\t%llu\\n\"\n\t\t   \"recursion_misses:\\t%llu\\n\"\n\t\t   \"verified_insns:\\t%u\\n\"",
            "prog->type",
            "prog->jited",
            "prog_tag",
            "prog->pages * 1ULL << PAGE_SHIFT",
            "prog->aux->id",
            "stats.nsecs",
            "stats.cnt",
            "stats.misses",
            "prog->aux->verified_insns"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "prog_tag",
            "prog->tag",
            "sizeof(prog->tag)"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_stats",
          "args": [
            "prog",
            "&stats"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1848-1873",
          "snippet": "static void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_prog *prog = filp->private_data;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\tstruct bpf_prog_kstats stats;\n\n\tbpf_prog_get_stats(prog, &stats);\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\"\n\t\t   \"run_time_ns:\\t%llu\\n\"\n\t\t   \"run_cnt:\\t%llu\\n\"\n\t\t   \"recursion_misses:\\t%llu\\n\"\n\t\t   \"verified_insns:\\t%u\\n\",\n\t\t   prog->type,\n\t\t   prog->jited,\n\t\t   prog_tag,\n\t\t   prog->pages * 1ULL << PAGE_SHIFT,\n\t\t   prog->aux->id,\n\t\t   stats.nsecs,\n\t\t   stats.cnt,\n\t\t   stats.misses,\n\t\t   prog->aux->verified_insns);\n}"
  },
  {
    "function_name": "bpf_prog_get_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1848-1873",
    "snippet": "static void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_fetch_retry_irq",
          "args": [
            "&st->syncp",
            "start"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_read",
          "args": [
            "&st->misses"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_read",
          "args": [
            "&st->cnt"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_read",
          "args": [
            "&st->nsecs"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_fetch_begin_irq",
          "args": [
            "&st->syncp"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "prog->stats",
            "cpu"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_get_stats(const struct bpf_prog *prog,\n\t\t\t       struct bpf_prog_kstats *stats)\n{\n\tu64 nsecs = 0, cnt = 0, misses = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct bpf_prog_stats *st;\n\t\tunsigned int start;\n\t\tu64 tnsecs, tcnt, tmisses;\n\n\t\tst = per_cpu_ptr(prog->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&st->syncp);\n\t\t\ttnsecs = u64_stats_read(&st->nsecs);\n\t\t\ttcnt = u64_stats_read(&st->cnt);\n\t\t\ttmisses = u64_stats_read(&st->misses);\n\t\t} while (u64_stats_fetch_retry_irq(&st->syncp, start));\n\t\tnsecs += tnsecs;\n\t\tcnt += tcnt;\n\t\tmisses += tmisses;\n\t}\n\tstats->nsecs = nsecs;\n\tstats->cnt = cnt;\n\tstats->misses = misses;\n}"
  },
  {
    "function_name": "bpf_prog_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1834-1840",
    "snippet": "static int bpf_prog_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_prog *prog = filp->private_data;\n\n\tbpf_prog_put(prog);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_prog *prog = filp->private_data;\n\n\tbpf_prog_put(prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1828-1831",
    "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_put",
          "args": [
            "prog",
            "true"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1811-1826",
          "snippet": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tstruct bpf_prog_aux *aux = prog->aux;\n\n\tif (atomic64_dec_and_test(&aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\n\t\tif (in_irq() || irqs_disabled()) {\n\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);\n\t\t\tschedule_work(&aux->work);\n\t\t} else {\n\t\t\tbpf_prog_put_deferred(&aux->work);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tstruct bpf_prog_aux *aux = prog->aux;\n\n\tif (atomic64_dec_and_test(&aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\n\t\tif (in_irq() || irqs_disabled()) {\n\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);\n\t\t\tschedule_work(&aux->work);\n\t\t} else {\n\t\t\tbpf_prog_put_deferred(&aux->work);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
  },
  {
    "function_name": "__bpf_prog_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1811-1826",
    "snippet": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tstruct bpf_prog_aux *aux = prog->aux;\n\n\tif (atomic64_dec_and_test(&aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\n\t\tif (in_irq() || irqs_disabled()) {\n\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);\n\t\t\tschedule_work(&aux->work);\n\t\t} else {\n\t\t\tbpf_prog_put_deferred(&aux->work);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put_deferred",
          "args": [
            "&aux->work"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1799-1809",
          "snippet": "static void bpf_prog_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *prog;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tprog = aux->prog;\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);\n\t__bpf_prog_put_noref(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *prog;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tprog = aux->prog;\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);\n\t__bpf_prog_put_noref(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&aux->work"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&aux->work",
            "bpf_prog_put_deferred"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_free_id",
          "args": [
            "prog",
            "do_idr_lock"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1742-1766",
          "snippet": "void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&prog_idr_lock, flags);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&prog_idr_lock, flags);\n\telse\n\t\t__release(&prog_idr_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nvoid bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&prog_idr_lock, flags);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&prog_idr_lock, flags);\n\telse\n\t\t__release(&prog_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_dec_and_test",
          "args": [
            "&aux->refcnt"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tstruct bpf_prog_aux *aux = prog->aux;\n\n\tif (atomic64_dec_and_test(&aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\n\t\tif (in_irq() || irqs_disabled()) {\n\t\t\tINIT_WORK(&aux->work, bpf_prog_put_deferred);\n\t\t\tschedule_work(&aux->work);\n\t\t} else {\n\t\t\tbpf_prog_put_deferred(&aux->work);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_put_deferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1799-1809",
    "snippet": "static void bpf_prog_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *prog;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tprog = aux->prog;\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);\n\t__bpf_prog_put_noref(prog, true);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_put_noref",
          "args": [
            "prog",
            "true"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put_noref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1779-1797",
          "snippet": "static void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_audit_prog",
          "args": [
            "prog",
            "BPF_AUDIT_UNLOAD"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_audit_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1704-1721",
          "snippet": "static void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};\n\nstatic void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_bpf_event",
          "args": [
            "prog",
            "PERF_BPF_EVENT_PROG_UNLOAD",
            "0"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_bpf_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8956-8996",
          "snippet": "void perf_event_bpf_event(struct bpf_prog *prog,\n\t\t\t  enum perf_bpf_event_type type,\n\t\t\t  u16 flags)\n{\n\tstruct perf_bpf_event bpf_event;\n\n\tif (type <= PERF_BPF_EVENT_UNKNOWN ||\n\t    type >= PERF_BPF_EVENT_MAX)\n\t\treturn;\n\n\tswitch (type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\tif (atomic_read(&nr_ksymbol_events))\n\t\t\tperf_event_bpf_emit_ksymbols(prog, type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!atomic_read(&nr_bpf_events))\n\t\treturn;\n\n\tbpf_event = (struct perf_bpf_event){\n\t\t.prog = prog,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_BPF_EVENT,\n\t\t\t\t.size = sizeof(bpf_event.event_id),\n\t\t\t},\n\t\t\t.type = type,\n\t\t\t.flags = flags,\n\t\t\t.id = prog->aux->id,\n\t\t},\n\t};\n\n\tBUILD_BUG_ON(BPF_TAG_SIZE % sizeof(u64));\n\n\tmemcpy(bpf_event.event_id.tag, prog->tag, BPF_TAG_SIZE);\n\tperf_iterate_sb(perf_event_bpf_output, &bpf_event, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static atomic_t nr_bpf_events",
            "static __always_inline enum",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic atomic_t nr_bpf_events;\nstatic __always_inline enum;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_bpf_event(struct bpf_prog *prog,\n\t\t\t  enum perf_bpf_event_type type,\n\t\t\t  u16 flags)\n{\n\tstruct perf_bpf_event bpf_event;\n\n\tif (type <= PERF_BPF_EVENT_UNKNOWN ||\n\t    type >= PERF_BPF_EVENT_MAX)\n\t\treturn;\n\n\tswitch (type) {\n\tcase PERF_BPF_EVENT_PROG_LOAD:\n\tcase PERF_BPF_EVENT_PROG_UNLOAD:\n\t\tif (atomic_read(&nr_ksymbol_events))\n\t\t\tperf_event_bpf_emit_ksymbols(prog, type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!atomic_read(&nr_bpf_events))\n\t\treturn;\n\n\tbpf_event = (struct perf_bpf_event){\n\t\t.prog = prog,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_BPF_EVENT,\n\t\t\t\t.size = sizeof(bpf_event.event_id),\n\t\t\t},\n\t\t\t.type = type,\n\t\t\t.flags = flags,\n\t\t\t.id = prog->aux->id,\n\t\t},\n\t};\n\n\tBUILD_BUG_ON(BPF_TAG_SIZE % sizeof(u64));\n\n\tmemcpy(bpf_event.event_id.tag, prog->tag, BPF_TAG_SIZE);\n\tperf_iterate_sb(perf_event_bpf_output, &bpf_event, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_prog_aux",
            "work"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_put_deferred(struct work_struct *work)\n{\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *prog;\n\n\taux = container_of(work, struct bpf_prog_aux, work);\n\tprog = aux->prog;\n\tperf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_UNLOAD, 0);\n\tbpf_audit_prog(prog, BPF_AUDIT_UNLOAD);\n\t__bpf_prog_put_noref(prog, true);\n}"
  },
  {
    "function_name": "__bpf_prog_put_noref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1779-1797",
    "snippet": "static void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_put_rcu",
          "args": [
            "&prog->aux->rcu"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1768-1777",
          "snippet": "static void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tkvfree(aux->func_info);\n\tkfree(aux->func_info_aux);\n\tfree_uid(aux->user);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tkvfree(aux->func_info);\n\tkfree(aux->func_info_aux);\n\tfree_uid(aux->user);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&prog->aux->rcu",
            "__bpf_prog_put_rcu"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "prog->aux->attach_btf"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prog->aux->kfunc_tab"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "prog->aux->linfo"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "prog->aux->jited_linfo"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del_all",
          "args": [
            "prog"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "523-527",
          "snippet": "void bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_noref(struct bpf_prog *prog, bool deferred)\n{\n\tbpf_prog_kallsyms_del_all(prog);\n\tbtf_put(prog->aux->btf);\n\tkvfree(prog->aux->jited_linfo);\n\tkvfree(prog->aux->linfo);\n\tkfree(prog->aux->kfunc_tab);\n\tif (prog->aux->attach_btf)\n\t\tbtf_put(prog->aux->attach_btf);\n\n\tif (deferred) {\n\t\tif (prog->aux->sleepable)\n\t\t\tcall_rcu_tasks_trace(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t\telse\n\t\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t} else {\n\t\t__bpf_prog_put_rcu(&prog->aux->rcu);\n\t}\n}"
  },
  {
    "function_name": "__bpf_prog_put_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1768-1777",
    "snippet": "static void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tkvfree(aux->func_info);\n\tkfree(aux->func_info_aux);\n\tfree_uid(aux->user);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_free",
          "args": [
            "aux->prog"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2304-2312",
          "snippet": "void bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tif (aux->dst_prog)\n\t\tbpf_prog_put(aux->dst_prog);\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tif (aux->dst_prog)\n\t\tbpf_prog_put(aux->dst_prog);\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_free",
          "args": [
            "aux"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "aux->user"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user.c",
          "lines": "178-187",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux->func_info_aux"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "aux->func_info"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_prog_aux",
            "rcu"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tkvfree(aux->func_info);\n\tkfree(aux->func_info_aux);\n\tfree_uid(aux->user);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}"
  },
  {
    "function_name": "bpf_prog_free_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1742-1766",
    "snippet": "void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&prog_idr_lock, flags);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&prog_idr_lock, flags);\n\telse\n\t\t__release(&prog_idr_lock);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "253-274",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&prog_idr_lock",
            "flags"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&prog_idr",
            "prog->aux->id"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquire",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&prog_idr_lock",
            "flags"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nvoid bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&prog_idr_lock, flags);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&prog_idr_lock, flags);\n\telse\n\t\t__release(&prog_idr_lock);\n}"
  },
  {
    "function_name": "bpf_prog_alloc_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1723-1740",
    "snippet": "static int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&prog_idr",
            "prog",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "bpf_audit_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1704-1721",
    "snippet": "static void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"prog-id=%u op=%s\"",
            "prog->aux->id",
            "bpf_audit_str[op]"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "ctx",
            "GFP_ATOMIC",
            "AUDIT_BPF"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "op >= BPF_AUDIT_MAX"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const char * const bpf_audit_str[BPF_AUDIT_MAX] = {\n\t[BPF_AUDIT_LOAD]   = \"LOAD\",\n\t[BPF_AUDIT_UNLOAD] = \"UNLOAD\",\n};\n\nstatic void bpf_audit_prog(const struct bpf_prog *prog, unsigned int op)\n{\n\tstruct audit_context *ctx = NULL;\n\tstruct audit_buffer *ab;\n\n\tif (WARN_ON_ONCE(op >= BPF_AUDIT_MAX))\n\t\treturn;\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\tif (op == BPF_AUDIT_LOAD)\n\t\tctx = audit_context();\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_BPF);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"prog-id=%u op=%s\",\n\t\t\t prog->aux->id, bpf_audit_str[op]);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "find_prog_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1674-1691",
    "snippet": "static int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "type",
            "ARRAY_SIZE(bpf_prog_types)"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_prog_types"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_prog_types"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};\n\nstatic int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}"
  },
  {
    "function_name": "map_freeze",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1622-1661",
    "snippet": "static int map_freeze(const union bpf_attr *attr)\n{\n\tint err = 0, ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_FREEZE))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||\n\t    map_value_has_timer(map)) {\n\t\tfdput(f);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&map->freeze_mutex);\n\tif (bpf_map_write_active(map)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (READ_ONCE(map->frozen)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (!bpf_capable()) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tWRITE_ONCE(map->frozen, true);\nerr_put:\n\tmutex_unlock(&map->freeze_mutex);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&map->freeze_mutex"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "map->frozen",
            "true"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "map->frozen"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active",
          "args": [
            "map"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "146-149",
          "snippet": "bool bpf_map_write_active(const struct bpf_map *map)\n{\n\treturn atomic64_read(&map->writecnt) != 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nbool bpf_map_write_active(const struct bpf_map *map)\n{\n\treturn atomic64_read(&map->writecnt) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&map->freeze_mutex"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_timer",
          "args": [
            "map"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_FREEZE"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_freeze(const union bpf_attr *attr)\n{\n\tint err = 0, ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_FREEZE))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (map->map_type == BPF_MAP_TYPE_STRUCT_OPS ||\n\t    map_value_has_timer(map)) {\n\t\tfdput(f);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&map->freeze_mutex);\n\tif (bpf_map_write_active(map)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (READ_ONCE(map->frozen)) {\n\t\terr = -EBUSY;\n\t\tgoto err_put;\n\t}\n\tif (!bpf_capable()) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tWRITE_ONCE(map->frozen, true);\nerr_put:\n\tmutex_unlock(&map->freeze_mutex);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_lookup_and_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1529-1618",
    "snippet": "static int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||\n\t    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (attr->flags &&\n\t    (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t     map->map_type == BPF_MAP_TYPE_STACK)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -ENOTSUPP;\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\tif (!bpf_map_is_dev_bound(map)) {\n\t\t\tbpf_disable_instrumentation();\n\t\t\trcu_read_lock();\n\t\t\terr = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);\n\t\t\trcu_read_unlock();\n\t\t\tbpf_enable_instrumentation();\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0) {\n\t\terr = -EFAULT;\n\t\tgoto free_value;\n\t}\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_dec",
          "args": [
            "map"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "141-144",
          "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "value"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uvalue",
            "value",
            "value_size"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_instrumentation",
          "args": [],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_lookup_and_delete_elem",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_disable_instrumentation",
          "args": [],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_pop_elem",
          "args": [
            "map",
            "value"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_copy_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1045-1054",
          "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_LOOKUP_AND_DELETE_ELEM"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->value"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ) ||\n\t    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (attr->flags &&\n\t    (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t     map->map_type == BPF_MAP_TYPE_STACK)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -ENOTSUPP;\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\tif (!bpf_map_is_dev_bound(map)) {\n\t\t\tbpf_disable_instrumentation();\n\t\t\trcu_read_lock();\n\t\t\terr = map->ops->map_lookup_and_delete_elem(map, key, value, attr->flags);\n\t\t\trcu_read_unlock();\n\t\t\tbpf_enable_instrumentation();\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0) {\n\t\terr = -EFAULT;\n\t\tgoto free_value;\n\t}\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "generic_map_lookup_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1428-1525",
    "snippet": "int generic_map_lookup_batch(struct bpf_map *map,\n\t\t\t\t    const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr)\n{\n\tvoid __user *uobatch = u64_to_user_ptr(attr->batch.out_batch);\n\tvoid __user *ubatch = u64_to_user_ptr(attr->batch.in_batch);\n\tvoid __user *values = u64_to_user_ptr(attr->batch.values);\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tvoid *buf, *buf_prevkey, *prev_key, *key, *value;\n\tint err, retry = MAP_LOOKUP_RETRIES;\n\tu32 value_size, cp, max_count;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map))\n\t\treturn -EINVAL;\n\n\tvalue_size = bpf_map_value_size(map);\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tif (put_user(0, &uattr->batch.count))\n\t\treturn -EFAULT;\n\n\tbuf_prevkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!buf_prevkey)\n\t\treturn -ENOMEM;\n\n\tbuf = kvmalloc(map->key_size + value_size, GFP_USER | __GFP_NOWARN);\n\tif (!buf) {\n\t\tkvfree(buf_prevkey);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = -EFAULT;\n\tprev_key = NULL;\n\tif (ubatch && copy_from_user(buf_prevkey, ubatch, map->key_size))\n\t\tgoto free_buf;\n\tkey = buf;\n\tvalue = key + map->key_size;\n\tif (ubatch)\n\t\tprev_key = buf_prevkey;\n\n\tfor (cp = 0; cp < max_count;) {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_get_next_key(map, prev_key, key);\n\t\trcu_read_unlock();\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = bpf_map_copy_value(map, key, value,\n\t\t\t\t\t attr->batch.elem_flags);\n\n\t\tif (err == -ENOENT) {\n\t\t\tif (retry) {\n\t\t\t\tretry--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto free_buf;\n\n\t\tif (copy_to_user(keys + cp * map->key_size, key,\n\t\t\t\t map->key_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free_buf;\n\t\t}\n\t\tif (copy_to_user(values + cp * value_size, value, value_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free_buf;\n\t\t}\n\n\t\tif (!prev_key)\n\t\t\tprev_key = buf_prevkey;\n\n\t\tswap(prev_key, key);\n\t\tretry = MAP_LOOKUP_RETRIES;\n\t\tcp++;\n\t}\n\n\tif (err == -EFAULT)\n\t\tgoto free_buf;\n\n\tif ((copy_to_user(&uattr->batch.count, &cp, sizeof(cp)) ||\n\t\t    (cp && copy_to_user(uobatch, prev_key, map->key_size))))\n\t\terr = -EFAULT;\n\nfree_buf:\n\tkvfree(buf_prevkey);\n\tkvfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define MAP_LOOKUP_RETRIES 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "buf"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "buf_prevkey"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uobatch",
            "prev_key",
            "map->key_size"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "prev_key",
            "key"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "974-1018",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_copy_value",
          "args": [
            "map",
            "key",
            "value",
            "attr->batch.elem_flags"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_copy_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "232-291",
          "snippet": "static int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_get_next_key",
          "args": [
            "map",
            "prev_key",
            "key"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf_prevkey",
            "ubatch",
            "map->key_size"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "buf_prevkey"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "map->key_size + value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "map->key_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "&uattr->batch.count"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.keys"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.values"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.in_batch"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.out_batch"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\n#define MAP_LOOKUP_RETRIES 3\n\nint generic_map_lookup_batch(struct bpf_map *map,\n\t\t\t\t    const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr)\n{\n\tvoid __user *uobatch = u64_to_user_ptr(attr->batch.out_batch);\n\tvoid __user *ubatch = u64_to_user_ptr(attr->batch.in_batch);\n\tvoid __user *values = u64_to_user_ptr(attr->batch.values);\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tvoid *buf, *buf_prevkey, *prev_key, *key, *value;\n\tint err, retry = MAP_LOOKUP_RETRIES;\n\tu32 value_size, cp, max_count;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map))\n\t\treturn -EINVAL;\n\n\tvalue_size = bpf_map_value_size(map);\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tif (put_user(0, &uattr->batch.count))\n\t\treturn -EFAULT;\n\n\tbuf_prevkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!buf_prevkey)\n\t\treturn -ENOMEM;\n\n\tbuf = kvmalloc(map->key_size + value_size, GFP_USER | __GFP_NOWARN);\n\tif (!buf) {\n\t\tkvfree(buf_prevkey);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = -EFAULT;\n\tprev_key = NULL;\n\tif (ubatch && copy_from_user(buf_prevkey, ubatch, map->key_size))\n\t\tgoto free_buf;\n\tkey = buf;\n\tvalue = key + map->key_size;\n\tif (ubatch)\n\t\tprev_key = buf_prevkey;\n\n\tfor (cp = 0; cp < max_count;) {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_get_next_key(map, prev_key, key);\n\t\trcu_read_unlock();\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = bpf_map_copy_value(map, key, value,\n\t\t\t\t\t attr->batch.elem_flags);\n\n\t\tif (err == -ENOENT) {\n\t\t\tif (retry) {\n\t\t\t\tretry--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err)\n\t\t\tgoto free_buf;\n\n\t\tif (copy_to_user(keys + cp * map->key_size, key,\n\t\t\t\t map->key_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free_buf;\n\t\t}\n\t\tif (copy_to_user(values + cp * value_size, value, value_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free_buf;\n\t\t}\n\n\t\tif (!prev_key)\n\t\t\tprev_key = buf_prevkey;\n\n\t\tswap(prev_key, key);\n\t\tretry = MAP_LOOKUP_RETRIES;\n\t\tcp++;\n\t}\n\n\tif (err == -EFAULT)\n\t\tgoto free_buf;\n\n\tif ((copy_to_user(&uattr->batch.count, &cp, sizeof(cp)) ||\n\t\t    (cp && copy_to_user(uobatch, prev_key, map->key_size))))\n\t\terr = -EFAULT;\n\nfree_buf:\n\tkvfree(buf_prevkey);\n\tkvfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "generic_map_update_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1366-1424",
    "snippet": "int generic_map_update_batch(struct bpf_map *map,\n\t\t\t     const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tvoid __user *values = u64_to_user_ptr(attr->batch.values);\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tu32 value_size, cp, max_count;\n\tint ufd = attr->batch.map_fd;\n\tvoid *key, *value;\n\tstruct fd f;\n\tint err = 0;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\treturn -EINVAL;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value) {\n\t\tkvfree(key);\n\t\treturn -ENOMEM;\n\t}\n\n\tf = fdget(ufd); /* bpf_map_do_batch() guarantees ufd is valid */\n\tfor (cp = 0; cp < max_count; cp++) {\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(key, keys + cp * map->key_size,\n\t\t    map->key_size) ||\n\t\t    copy_from_user(value, values + cp * value_size, value_size))\n\t\t\tbreak;\n\n\t\terr = bpf_map_update_value(map, f, key, value,\n\t\t\t\t\t   attr->batch.elem_flags);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (copy_to_user(&uattr->batch.count, &cp, sizeof(cp)))\n\t\terr = -EFAULT;\n\n\tkvfree(value);\n\tkvfree(key);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "value"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&uattr->batch.count",
            "&cp",
            "sizeof(cp)"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_update_value",
          "args": [
            "map",
            "f",
            "key",
            "value",
            "attr->batch.elem_flags"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_update_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "175-230",
          "snippet": "static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "value",
            "values + cp * value_size",
            "value_size"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "key",
            "keys + cp * map->key_size",
            "map->key_size"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "map->key_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.keys"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.values"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint generic_map_update_batch(struct bpf_map *map,\n\t\t\t     const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tvoid __user *values = u64_to_user_ptr(attr->batch.values);\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tu32 value_size, cp, max_count;\n\tint ufd = attr->batch.map_fd;\n\tvoid *key, *value;\n\tstruct fd f;\n\tint err = 0;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\treturn -EINVAL;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value) {\n\t\tkvfree(key);\n\t\treturn -ENOMEM;\n\t}\n\n\tf = fdget(ufd); /* bpf_map_do_batch() guarantees ufd is valid */\n\tfor (cp = 0; cp < max_count; cp++) {\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(key, keys + cp * map->key_size,\n\t\t    map->key_size) ||\n\t\t    copy_from_user(value, values + cp * value_size, value_size))\n\t\t\tbreak;\n\n\t\terr = bpf_map_update_value(map, f, key, value,\n\t\t\t\t\t   attr->batch.elem_flags);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (copy_to_user(&uattr->batch.count, &cp, sizeof(cp)))\n\t\terr = -EFAULT;\n\n\tkvfree(value);\n\tkvfree(key);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "generic_map_delete_batch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1314-1364",
    "snippet": "int generic_map_delete_batch(struct bpf_map *map,\n\t\t\t     const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tu32 cp, max_count;\n\tint err = 0;\n\tvoid *key;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tfor (cp = 0; cp < max_count; cp++) {\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(key, keys + cp * map->key_size,\n\t\t\t\t   map->key_size))\n\t\t\tbreak;\n\n\t\tif (bpf_map_is_dev_bound(map)) {\n\t\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\t\tbreak;\n\t\t}\n\n\t\tbpf_disable_instrumentation();\n\t\trcu_read_lock();\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\trcu_read_unlock();\n\t\tbpf_enable_instrumentation();\n\t\tmaybe_wait_bpf_programs(map);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (copy_to_user(&uattr->batch.count, &cp, sizeof(cp)))\n\t\terr = -EFAULT;\n\n\tkvfree(key);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&uattr->batch.count",
            "&cp",
            "sizeof(cp)"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "164-173",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_instrumentation",
          "args": [],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_disable_instrumentation",
          "args": [],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "465-476",
          "snippet": "int bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "key",
            "keys + cp * map->key_size",
            "map->key_size"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "map->key_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->batch.keys"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint generic_map_delete_batch(struct bpf_map *map,\n\t\t\t     const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tvoid __user *keys = u64_to_user_ptr(attr->batch.keys);\n\tu32 cp, max_count;\n\tint err = 0;\n\tvoid *key;\n\n\tif (attr->batch.elem_flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tif ((attr->batch.elem_flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmax_count = attr->batch.count;\n\tif (!max_count)\n\t\treturn 0;\n\n\tkey = kvmalloc(map->key_size, GFP_USER | __GFP_NOWARN);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\tfor (cp = 0; cp < max_count; cp++) {\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(key, keys + cp * map->key_size,\n\t\t\t\t   map->key_size))\n\t\t\tbreak;\n\n\t\tif (bpf_map_is_dev_bound(map)) {\n\t\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\t\tbreak;\n\t\t}\n\n\t\tbpf_disable_instrumentation();\n\t\trcu_read_lock();\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\trcu_read_unlock();\n\t\tbpf_enable_instrumentation();\n\t\tmaybe_wait_bpf_programs(map);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (copy_to_user(&uattr->batch.count, &cp, sizeof(cp)))\n\t\terr = -EFAULT;\n\n\tkvfree(key);\n\treturn err;\n}"
  },
  {
    "function_name": "map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1250-1312",
    "snippet": "static int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kvmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkvfree(next_key);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "next_key"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "unext_key",
            "next_key",
            "map->key_size"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_get_next_key",
          "args": [
            "map",
            "key",
            "next_key"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_get_next_key",
          "args": [
            "map",
            "key",
            "next_key"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_get_next_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "478-489",
          "snippet": "int bpf_map_offload_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_get_next_key(offmap, key, next_key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_get_next_key(offmap, key, next_key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "map->key_size",
            "GFP_USER"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_copy_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1045-1054",
          "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_GET_NEXT_KEY"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->next_key"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kvmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkvfree(next_key);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1195-1245",
    "snippet": "static int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t} else if (IS_FD_PROG_ARRAY(map) ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* These maps require sleepable context */\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tbpf_disable_instrumentation();\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_dec",
          "args": [
            "map"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "141-144",
          "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "164-173",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_instrumentation",
          "args": [],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_disable_instrumentation",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FD_PROG_ARRAY",
          "args": [
            "map"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "465-476",
          "snippet": "int bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_copy_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1045-1054",
          "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_DELETE_ELEM"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t} else if (IS_FD_PROG_ARRAY(map) ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* These maps require sleepable context */\n\t\terr = map->ops->map_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tbpf_disable_instrumentation();\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1134-1191",
    "snippet": "static int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tbpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);\n\tbpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = ___bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = bpf_map_update_value(map, f, key, value, attr->flags);\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_dec",
          "args": [
            "map"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "141-144",
          "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "value"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_update_value",
          "args": [
            "map",
            "f",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_update_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "175-230",
          "snippet": "static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_bpfptr",
          "args": [
            "value",
            "uvalue",
            "value_size"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_copy_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1045-1054",
          "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_UPDATE_ELEM"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->value",
            "uattr.is_kernel"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->key",
            "uattr.is_kernel"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_update_elem(union bpf_attr *attr, bpfptr_t uattr)\n{\n\tbpfptr_t ukey = make_bpfptr(attr->key, uattr.is_kernel);\n\tbpfptr_t uvalue = make_bpfptr(attr->value, uattr.is_kernel);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tbpf_map_write_active_inc(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = ___bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_bpfptr(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = bpf_map_update_value(map, f, key, value, attr->flags);\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1059-1129",
    "snippet": "static int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\tif (copy_from_user(value, uvalue, value_size))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\t\tgoto free_value;\n\t}\n\n\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "key"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "value"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uvalue",
            "value",
            "value_size"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_copy_value",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_copy_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "232-291",
          "snippet": "static int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "value",
            "uvalue",
            "value_size"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "___bpf_copy_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1045-1054",
          "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_get_sys_perms",
          "args": [
            "map",
            "f"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "map_get_sys_perms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "531-541",
          "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_LOOKUP_ELEM"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->value"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tif (attr->flags & ~BPF_F_LOCK)\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (!(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif ((attr->flags & BPF_F_LOCK) &&\n\t    !map_value_has_spin_lock(map)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = bpf_map_value_size(map);\n\n\terr = -ENOMEM;\n\tvalue = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\tif (copy_from_user(value, uvalue, value_size))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\t\tgoto free_value;\n\t}\n\n\terr = bpf_map_copy_value(map, key, value, attr->flags);\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkvfree(value);\nfree_key:\n\tkvfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "___bpf_copy_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1045-1054",
    "snippet": "static void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfptr_is_null",
          "args": [
            "ukey"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmemdup_bpfptr",
          "args": [
            "ukey",
            "key_size"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *___bpf_copy_key(bpfptr_t ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn kvmemdup_bpfptr(ukey, key_size);\n\n\tif (!bpfptr_is_null(ukey))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__bpf_copy_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1034-1043",
    "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn vmemdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmemdup_user",
          "args": [
            "ukey",
            "key_size"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn vmemdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_stackmap_copy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1029-1032",
    "snippet": "int __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_map_inc_not_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1019-1026",
    "snippet": "struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_map_inc_not_zero",
          "args": [
            "map",
            "false"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1006-1017",
          "snippet": "static struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstruct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}"
  },
  {
    "function_name": "__bpf_map_inc_not_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "1006-1017",
    "snippet": "static struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->usercnt"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_fetch_add_unless",
          "args": [
            "&map->refcnt",
            "1",
            "0"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *__bpf_map_inc_not_zero(struct bpf_map *map, bool uref)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&map->refcnt, 1, 0);\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (uref)\n\t\tatomic64_inc(&map->usercnt);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_get_with_uref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "990-1003",
    "snippet": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc_with_uref(map);\n\tfdput(f);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc_with_uref",
          "args": [
            "map"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "968-972",
          "snippet": "void bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc_with_uref(map);\n\tfdput(f);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "975-988",
    "snippet": "struct bpf_map *bpf_map_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc(map);\n\tfdput(f);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc",
          "args": [
            "map"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1019-1026",
          "snippet": "struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstruct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "950-960",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_map *bpf_map_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc(map);\n\tfdput(f);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_inc_with_uref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "968-972",
    "snippet": "void bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->usercnt"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->refcnt"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}"
  },
  {
    "function_name": "bpf_map_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "962-965",
    "snippet": "void bpf_map_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->refcnt"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n}"
  },
  {
    "function_name": "__bpf_map_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "950-960",
    "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
  },
  {
    "function_name": "map_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "832-945",
    "snippet": "static int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type != BPF_MAP_TYPE_BLOOM_FILTER &&\n\t    attr->map_extra != 0)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tmap->timer_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tif (btf_is_kernel(btf)) {\n\t\t\tbtf_put(btf);\n\t\t\terr = -EACCES;\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_free",
          "args": [
            "map"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "map->btf"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_map_free",
          "args": [
            "map"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_put_with_uref",
          "args": [
            "map"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_new_fd",
          "args": [
            "map",
            "f_flags"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "708-718",
          "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_save_memcg",
          "args": [
            "map"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_save_memcg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "466-468",
          "snippet": "static void bpf_map_save_memcg(struct bpf_map *map)\n{\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_save_memcg(struct bpf_map *map)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_alloc_id",
          "args": [
            "map"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "372-388",
          "snippet": "static int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_map_alloc",
          "args": [
            "map"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_check_btf",
          "args": [
            "map",
            "btf",
            "attr->btf_key_type_id",
            "attr->btf_value_type_id"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "map_check_btf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "771-828",
          "snippet": "static int map_check_btf(struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\t/* Some maps allow key to be unspecified. */\n\tif (btf_key_id) {\n\t\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\t\tif (!key_type || key_size != map->key_size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey_type = btf_type_by_id(btf, 0);\n\t\tif (!map->ops->map_check_btf)\n\t\t\treturn -EINVAL;\n\t}\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tmap->spin_lock_off = btf_find_spin_lock(btf, value_type);\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_SK_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_INODE_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\treturn -ENOTSUPP;\n\t\tif (map->spin_lock_off + sizeof(struct bpf_spin_lock) >\n\t\t    map->value_size) {\n\t\t\tWARN_ONCE(1,\n\t\t\t\t  \"verifier bug spin_lock_off %d value_size %d\\n\",\n\t\t\t\t  map->spin_lock_off, map->value_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tmap->timer_off = btf_find_timer(btf, value_type);\n\tif (map_value_has_timer(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, btf, key_type, value_type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_check_btf(struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\t/* Some maps allow key to be unspecified. */\n\tif (btf_key_id) {\n\t\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\t\tif (!key_type || key_size != map->key_size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey_type = btf_type_by_id(btf, 0);\n\t\tif (!map->ops->map_check_btf)\n\t\t\treturn -EINVAL;\n\t}\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tmap->spin_lock_off = btf_find_spin_lock(btf, value_type);\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_SK_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_INODE_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\treturn -ENOTSUPP;\n\t\tif (map->spin_lock_off + sizeof(struct bpf_spin_lock) >\n\t\t    map->value_size) {\n\t\t\tWARN_ONCE(1,\n\t\t\t\t  \"verifier bug spin_lock_off %d value_size %d\\n\",\n\t\t\t\t  map->spin_lock_off, map->value_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tmap->timer_off = btf_find_timer(btf, value_type);\n\tif (map_value_has_timer(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, btf, key_type, value_type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_is_kernel",
          "args": [
            "btf"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "btf_is_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6181-6184",
          "snippet": "bool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_get_by_fd",
          "args": [
            "attr->btf_fd"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_by_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6073-6093",
          "snippet": "struct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&map->freeze_mutex"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->usercnt",
            "1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&map->refcnt",
            "1"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_obj_name_cpy",
          "args": [
            "map->name",
            "attr->map_name",
            "sizeof(attr->map_name)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_name_cpy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "742-761",
          "snippet": "int bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_alloc_map",
          "args": [
            "attr"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_alloc_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "107-134",
          "snippet": "static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};",
            "const struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};\nconst struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "numa_node"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_file_flag",
          "args": [
            "attr->map_flags"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "720-729",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_CREATE"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tif (attr->btf_vmlinux_value_type_id) {\n\t\tif (attr->map_type != BPF_MAP_TYPE_STRUCT_OPS ||\n\t\t    attr->btf_key_type_id || attr->btf_value_type_id)\n\t\t\treturn -EINVAL;\n\t} else if (attr->btf_key_type_id && !attr->btf_value_type_id) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->map_type != BPF_MAP_TYPE_BLOOM_FILTER &&\n\t    attr->map_extra != 0)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name,\n\t\t\t       sizeof(attr->map_name));\n\tif (err < 0)\n\t\tgoto free_map;\n\n\tatomic64_set(&map->refcnt, 1);\n\tatomic64_set(&map->usercnt, 1);\n\tmutex_init(&map->freeze_mutex);\n\n\tmap->spin_lock_off = -EINVAL;\n\tmap->timer_off = -EINVAL;\n\tif (attr->btf_key_type_id || attr->btf_value_type_id ||\n\t    /* Even the map's value is a kernel's struct,\n\t     * the bpf_prog.o must have BTF to begin with\n\t     * to figure out the corresponding kernel's\n\t     * counter part.  Thus, attr->btf_fd has\n\t     * to be valid also.\n\t     */\n\t    attr->btf_vmlinux_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map;\n\t\t}\n\t\tif (btf_is_kernel(btf)) {\n\t\t\tbtf_put(btf);\n\t\t\terr = -EACCES;\n\t\t\tgoto free_map;\n\t\t}\n\t\tmap->btf = btf;\n\n\t\tif (attr->btf_value_type_id) {\n\t\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t\t    attr->btf_value_type_id);\n\t\t\tif (err)\n\t\t\t\tgoto free_map;\n\t\t}\n\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t\tmap->btf_vmlinux_value_type_id =\n\t\t\tattr->btf_vmlinux_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\tbpf_map_save_memcg(map);\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put_with_uref() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put_with_uref(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}"
  },
  {
    "function_name": "map_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "771-828",
    "snippet": "static int map_check_btf(struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\t/* Some maps allow key to be unspecified. */\n\tif (btf_key_id) {\n\t\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\t\tif (!key_type || key_size != map->key_size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey_type = btf_type_by_id(btf, 0);\n\t\tif (!map->ops->map_check_btf)\n\t\t\treturn -EINVAL;\n\t}\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tmap->spin_lock_off = btf_find_spin_lock(btf, value_type);\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_SK_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_INODE_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\treturn -ENOTSUPP;\n\t\tif (map->spin_lock_off + sizeof(struct bpf_spin_lock) >\n\t\t    map->value_size) {\n\t\t\tWARN_ONCE(1,\n\t\t\t\t  \"verifier bug spin_lock_off %d value_size %d\\n\",\n\t\t\t\t  map->spin_lock_off, map->value_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tmap->timer_off = btf_find_timer(btf, value_type);\n\tif (map_value_has_timer(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, btf, key_type, value_type);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_check_btf",
          "args": [
            "map",
            "btf",
            "key_type",
            "value_type"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "map_check_btf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "771-828",
          "snippet": "static int map_check_btf(struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\t/* Some maps allow key to be unspecified. */\n\tif (btf_key_id) {\n\t\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\t\tif (!key_type || key_size != map->key_size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey_type = btf_type_by_id(btf, 0);\n\t\tif (!map->ops->map_check_btf)\n\t\t\treturn -EINVAL;\n\t}\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tmap->spin_lock_off = btf_find_spin_lock(btf, value_type);\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_SK_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_INODE_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\treturn -ENOTSUPP;\n\t\tif (map->spin_lock_off + sizeof(struct bpf_spin_lock) >\n\t\t    map->value_size) {\n\t\t\tWARN_ONCE(1,\n\t\t\t\t  \"verifier bug spin_lock_off %d value_size %d\\n\",\n\t\t\t\t  map->spin_lock_off, map->value_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tmap->timer_off = btf_find_timer(btf, value_type);\n\tif (map_value_has_timer(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, btf, key_type, value_type);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_timer",
          "args": [
            "map"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_find_timer",
          "args": [
            "btf",
            "value_type"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3159-3164",
          "snippet": "int btf_find_timer(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_timer\",\n\t\t\t      sizeof(struct bpf_timer),\n\t\t\t      __alignof__(struct bpf_timer));\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_find_timer(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_timer\",\n\t\t\t      sizeof(struct bpf_timer),\n\t\t\t      __alignof__(struct bpf_timer));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"verifier bug spin_lock_off %d value_size %d\\n\"",
            "map->spin_lock_off",
            "map->value_size"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_find_spin_lock",
          "args": [
            "btf",
            "value_type"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3152-3157",
          "snippet": "int btf_find_spin_lock(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_spin_lock\",\n\t\t\t      sizeof(struct bpf_spin_lock),\n\t\t\t      __alignof__(struct bpf_spin_lock));\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_find_spin_lock(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_spin_lock\",\n\t\t\t      sizeof(struct bpf_spin_lock),\n\t\t\t      __alignof__(struct bpf_spin_lock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&btf_value_id",
            "&value_size"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "0"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int map_check_btf(struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\t/* Some maps allow key to be unspecified. */\n\tif (btf_key_id) {\n\t\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\t\tif (!key_type || key_size != map->key_size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey_type = btf_type_by_id(btf, 0);\n\t\tif (!map->ops->map_check_btf)\n\t\t\treturn -EINVAL;\n\t}\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tmap->spin_lock_off = btf_find_spin_lock(btf, value_type);\n\n\tif (map_value_has_spin_lock(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    map->map_type != BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_SK_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_INODE_STORAGE &&\n\t\t    map->map_type != BPF_MAP_TYPE_TASK_STORAGE)\n\t\t\treturn -ENOTSUPP;\n\t\tif (map->spin_lock_off + sizeof(struct bpf_spin_lock) >\n\t\t    map->value_size) {\n\t\t\tWARN_ONCE(1,\n\t\t\t\t  \"verifier bug spin_lock_off %d value_size %d\\n\",\n\t\t\t\t  map->spin_lock_off, map->value_size);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tmap->timer_off = btf_find_timer(btf, value_type);\n\tif (map_value_has_timer(map)) {\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG)\n\t\t\treturn -EACCES;\n\t\tif (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t    map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, btf, key_type, value_type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "map_check_no_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "763-769",
    "snippet": "int map_check_no_btf(const struct bpf_map *map,\n\t\t     const struct btf *btf,\n\t\t     const struct btf_type *key_type,\n\t\t     const struct btf_type *value_type)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint map_check_no_btf(const struct bpf_map *map,\n\t\t     const struct btf *btf,\n\t\t     const struct btf_type *key_type,\n\t\t     const struct btf_type *value_type)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_obj_name_cpy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "742-761",
    "snippet": "int bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*src"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "size"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_obj_name_cpy(char *dst, const char *src, unsigned int size)\n{\n\tconst char *end = src + size;\n\tconst char *orig_src = src;\n\n\tmemset(dst, 0, size);\n\t/* Copy all isalnum(), '_' and '.' chars. */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) &&\n\t\t    *src != '_' && *src != '.')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in \"size\" number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn src - orig_src;\n}"
  },
  {
    "function_name": "bpf_get_file_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "720-729",
    "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
  },
  {
    "function_name": "bpf_map_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "708-718",
    "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-map\"",
            "&bpf_map_fops",
            "map",
            "flags | O_CLOEXEC"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_map",
          "args": [
            "map",
            "OPEN_FMODE(flags)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "flags"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
  },
  {
    "function_name": "bpf_map_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "687-695",
    "snippet": "static __poll_t bpf_map_poll(struct file *filp, struct poll_table_struct *pts)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_poll)\n\t\treturn map->ops->map_poll(map, filp, pts);\n\n\treturn EPOLLERR;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_poll",
          "args": [
            "map",
            "filp",
            "pts"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic __poll_t bpf_map_poll(struct file *filp, struct poll_table_struct *pts)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_poll)\n\t\treturn map->ops->map_poll(map, filp, pts);\n\n\treturn EPOLLERR;\n}"
  },
  {
    "function_name": "bpf_map_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "638-685",
    "snippet": "static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = filp->private_data;\n\tint err;\n\n\tif (!map->ops->map_mmap || map_value_has_spin_lock(map) ||\n\t    map_value_has_timer(map))\n\t\treturn -ENOTSUPP;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&map->freeze_mutex);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\tif (map->frozen) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* map is meant to be read-only, so do not allow mapping as\n\t\t * writable, because it's possible to leak a writable page\n\t\t * reference and allows user-space to still modify it after\n\t\t * freezing, while verifier will assume contents do not change\n\t\t */\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG) {\n\t\t\terr = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* set default open/close callbacks */\n\tvma->vm_ops = &bpf_map_default_vmops;\n\tvma->vm_private_data = map;\n\tvma->vm_flags &= ~VM_MAYEXEC;\n\tif (!(vma->vm_flags & VM_WRITE))\n\t\t/* disallow re-mapping with PROT_WRITE */\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\terr = map->ops->map_mmap(map, vma);\n\tif (err)\n\t\tgoto out;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\nout:\n\tmutex_unlock(&map->freeze_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct bpf_map_default_vmops = {\n\t.open\t\t= bpf_map_mmap_open,\n\t.close\t\t= bpf_map_mmap_close,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&map->freeze_mutex"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_mmap",
          "args": [
            "map",
            "vma"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&map->freeze_mutex"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_value_has_timer",
          "args": [
            "map"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct vm_operations_struct bpf_map_default_vmops = {\n\t.open\t\t= bpf_map_mmap_open,\n\t.close\t\t= bpf_map_mmap_close,\n};\n\nstatic int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = filp->private_data;\n\tint err;\n\n\tif (!map->ops->map_mmap || map_value_has_spin_lock(map) ||\n\t    map_value_has_timer(map))\n\t\treturn -ENOTSUPP;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&map->freeze_mutex);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\tif (map->frozen) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* map is meant to be read-only, so do not allow mapping as\n\t\t * writable, because it's possible to leak a writable page\n\t\t * reference and allows user-space to still modify it after\n\t\t * freezing, while verifier will assume contents do not change\n\t\t */\n\t\tif (map->map_flags & BPF_F_RDONLY_PROG) {\n\t\t\terr = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* set default open/close callbacks */\n\tvma->vm_ops = &bpf_map_default_vmops;\n\tvma->vm_private_data = map;\n\tvma->vm_flags &= ~VM_MAYEXEC;\n\tif (!(vma->vm_flags & VM_WRITE))\n\t\t/* disallow re-mapping with PROT_WRITE */\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\terr = map->ops->map_mmap(map, vma);\n\tif (err)\n\t\tgoto out;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\nout:\n\tmutex_unlock(&map->freeze_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_map_mmap_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "625-631",
    "snippet": "static void bpf_map_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_dec(map);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_write_active_dec",
          "args": [
            "map"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "141-144",
          "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_dec(map);\n}"
  },
  {
    "function_name": "bpf_map_mmap_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "616-622",
    "snippet": "static void bpf_map_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_write_active_inc",
          "args": [
            "map"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_write_active_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "136-139",
          "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\n}"
  },
  {
    "function_name": "bpf_dummy_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "606-613",
    "snippet": "static ssize_t bpf_dummy_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t siz, loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_WRITE.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic ssize_t bpf_dummy_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t siz, loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_WRITE.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_dummy_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "597-604",
    "snippet": "static ssize_t bpf_dummy_read(struct file *filp, char __user *buf, size_t siz,\n\t\t\t      loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_READ.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic ssize_t bpf_dummy_read(struct file *filp, char __user *buf, size_t siz,\n\t\t\t      loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_READ.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_map_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "557-594",
    "snippet": "static void bpf_map_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_map *map = filp->private_data;\n\tconst struct bpf_array *array;\n\tu32 type = 0, jited = 0;\n\n\tif (map->map_type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tspin_lock(&array->aux->owner.lock);\n\t\ttype  = array->aux->owner.type;\n\t\tjited = array->aux->owner.jited;\n\t\tspin_unlock(&array->aux->owner.lock);\n\t}\n\n\tseq_printf(m,\n\t\t   \"map_type:\\t%u\\n\"\n\t\t   \"key_size:\\t%u\\n\"\n\t\t   \"value_size:\\t%u\\n\"\n\t\t   \"max_entries:\\t%u\\n\"\n\t\t   \"map_flags:\\t%#x\\n\"\n\t\t   \"map_extra:\\t%#llx\\n\"\n\t\t   \"memlock:\\t%lu\\n\"\n\t\t   \"map_id:\\t%u\\n\"\n\t\t   \"frozen:\\t%u\\n\",\n\t\t   map->map_type,\n\t\t   map->key_size,\n\t\t   map->value_size,\n\t\t   map->max_entries,\n\t\t   map->map_flags,\n\t\t   (unsigned long long)map->map_extra,\n\t\t   bpf_map_memory_footprint(map),\n\t\t   map->id,\n\t\t   READ_ONCE(map->frozen));\n\tif (type) {\n\t\tseq_printf(m, \"owner_prog_type:\\t%u\\n\", type);\n\t\tseq_printf(m, \"owner_jited:\\t%u\\n\", jited);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"owner_jited:\\t%u\\n\"",
            "jited"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "map->frozen"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_memory_footprint",
          "args": [
            "map"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_memory_footprint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "548-555",
          "snippet": "static unsigned long bpf_map_memory_footprint(const struct bpf_map *map)\n{\n\tunsigned long size;\n\n\tsize = round_up(map->key_size + bpf_map_value_size(map), 8);\n\n\treturn round_up(map->max_entries * size, PAGE_SIZE);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic unsigned long bpf_map_memory_footprint(const struct bpf_map *map)\n{\n\tunsigned long size;\n\n\tsize = round_up(map->key_size + bpf_map_value_size(map), 8);\n\n\treturn round_up(map->max_entries * size, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&array->aux->owner.lock"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&array->aux->owner.lock"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_map *map = filp->private_data;\n\tconst struct bpf_array *array;\n\tu32 type = 0, jited = 0;\n\n\tif (map->map_type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\tspin_lock(&array->aux->owner.lock);\n\t\ttype  = array->aux->owner.type;\n\t\tjited = array->aux->owner.jited;\n\t\tspin_unlock(&array->aux->owner.lock);\n\t}\n\n\tseq_printf(m,\n\t\t   \"map_type:\\t%u\\n\"\n\t\t   \"key_size:\\t%u\\n\"\n\t\t   \"value_size:\\t%u\\n\"\n\t\t   \"max_entries:\\t%u\\n\"\n\t\t   \"map_flags:\\t%#x\\n\"\n\t\t   \"map_extra:\\t%#llx\\n\"\n\t\t   \"memlock:\\t%lu\\n\"\n\t\t   \"map_id:\\t%u\\n\"\n\t\t   \"frozen:\\t%u\\n\",\n\t\t   map->map_type,\n\t\t   map->key_size,\n\t\t   map->value_size,\n\t\t   map->max_entries,\n\t\t   map->map_flags,\n\t\t   (unsigned long long)map->map_extra,\n\t\t   bpf_map_memory_footprint(map),\n\t\t   map->id,\n\t\t   READ_ONCE(map->frozen));\n\tif (type) {\n\t\tseq_printf(m, \"owner_prog_type:\\t%u\\n\", type);\n\t\tseq_printf(m, \"owner_jited:\\t%u\\n\", jited);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_memory_footprint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "548-555",
    "snippet": "static unsigned long bpf_map_memory_footprint(const struct bpf_map *map)\n{\n\tunsigned long size;\n\n\tsize = round_up(map->key_size + bpf_map_value_size(map), 8);\n\n\treturn round_up(map->max_entries * size, PAGE_SIZE);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->max_entries * size",
            "PAGE_SIZE"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size + bpf_map_value_size(map)",
            "8"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_value_size",
          "args": [
            "map"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_value_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "151-162",
          "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic unsigned long bpf_map_memory_footprint(const struct bpf_map *map)\n{\n\tunsigned long size;\n\n\tsize = round_up(map->key_size + bpf_map_value_size(map), 8);\n\n\treturn round_up(map->max_entries * size, PAGE_SIZE);\n}"
  },
  {
    "function_name": "map_get_sys_perms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "531-541",
    "snippet": "static fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "map->frozen"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic fmode_t map_get_sys_perms(struct bpf_map *map, struct fd f)\n{\n\tfmode_t mode = f.file->f_mode;\n\n\t/* Our file permissions may have been overridden by global\n\t * map permissions facing syscall side.\n\t */\n\tif (READ_ONCE(map->frozen))\n\t\tmode &= ~FMODE_CAN_WRITE;\n\treturn mode;\n}"
  },
  {
    "function_name": "bpf_map_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "520-529",
    "snippet": "static int bpf_map_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_release)\n\t\tmap->ops->map_release(map, filp);\n\n\tbpf_map_put_with_uref(map);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put_with_uref",
          "args": [
            "map"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_release",
          "args": [
            "map",
            "filp"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_release)\n\t\tmap->ops->map_release(map, filp);\n\n\tbpf_map_put_with_uref(map);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_map_put_with_uref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "514-518",
    "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put_uref",
          "args": [
            "map"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "486-492",
          "snippet": "static void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic64_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic64_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
  },
  {
    "function_name": "bpf_map_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "508-511",
    "snippet": "void bpf_map_put(struct bpf_map *map)\n{\n\t__bpf_map_put(map, true);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_map_put",
          "args": [
            "map",
            "true"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "497-506",
          "snippet": "static void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic64_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic64_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put(struct bpf_map *map)\n{\n\t__bpf_map_put(map, true);\n}"
  },
  {
    "function_name": "__bpf_map_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "497-506",
    "snippet": "static void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic64_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&map->work"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&map->work",
            "bpf_map_free_deferred"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "map->btf"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_free_id",
          "args": [
            "map",
            "do_idr_lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "390-414",
          "snippet": "void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nvoid bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_dec_and_test",
          "args": [
            "&map->refcnt"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic64_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_put_uref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "486-492",
    "snippet": "static void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic64_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_release_uref",
          "args": [
            "map"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec_and_test",
          "args": [
            "&map->usercnt"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic64_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_free_deferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "476-484",
    "snippet": "static void bpf_map_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_map, work);\n\n\tsecurity_bpf_map_free(map);\n\tbpf_map_release_memcg(map);\n\t/* implementation dependent freeing */\n\tmap->ops->map_free(map);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_free",
          "args": [
            "map"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_release_memcg",
          "args": [
            "map"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_release_memcg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "470-472",
          "snippet": "static void bpf_map_release_memcg(struct bpf_map *map)\n{\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memcg(struct bpf_map *map)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_map_free",
          "args": [
            "map"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_map",
            "work"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_map, work);\n\n\tsecurity_bpf_map_free(map);\n\tbpf_map_release_memcg(map);\n\t/* implementation dependent freeing */\n\tmap->ops->map_free(map);\n}"
  },
  {
    "function_name": "bpf_map_release_memcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "470-472",
    "snippet": "static void bpf_map_release_memcg(struct bpf_map *map)\n{\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memcg(struct bpf_map *map)\n{\n}"
  },
  {
    "function_name": "bpf_map_save_memcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "466-468",
    "snippet": "static void bpf_map_save_memcg(struct bpf_map *map)\n{\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_save_memcg(struct bpf_map *map)\n{\n}"
  },
  {
    "function_name": "bpf_map_alloc_percpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "452-463",
    "snippet": "void __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "old_memcg"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu_gfp",
          "args": [
            "size",
            "align",
            "flags | __GFP_ACCOUNT"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "map->memcg"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "bpf_map_kzalloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "440-450",
    "snippet": "void *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "old_memcg"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "flags | __GFP_ACCOUNT"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "map->memcg"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kzalloc(const struct bpf_map *map, size_t size, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kzalloc(size, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "bpf_map_kmalloc_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "427-438",
    "snippet": "void *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "old_memcg"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "flags | __GFP_ACCOUNT",
            "node"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_active_memcg",
          "args": [
            "map->memcg"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "bpf_map_release_memcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "422-425",
    "snippet": "static void bpf_map_release_memcg(struct bpf_map *map)\n{\n\tmem_cgroup_put(map->memcg);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_put",
          "args": [
            "map->memcg"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memcg(struct bpf_map *map)\n{\n\tmem_cgroup_put(map->memcg);\n}"
  },
  {
    "function_name": "bpf_map_save_memcg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "417-420",
    "snippet": "static void bpf_map_save_memcg(struct bpf_map *map)\n{\n\tmap->memcg = get_mem_cgroup_from_mm(current->mm);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_mm",
          "args": [
            "current->mm"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_save_memcg(struct bpf_map *map)\n{\n\tmap->memcg = get_mem_cgroup_from_mm(current->mm);\n}"
  },
  {
    "function_name": "bpf_map_free_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "390-414",
    "snippet": "void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "&map_idr_lock"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "253-274",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&map_idr_lock",
            "flags"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&map_idr",
            "map->id"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquire",
          "args": [
            "&map_idr_lock"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&map_idr_lock",
            "flags"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nvoid bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}"
  },
  {
    "function_name": "bpf_map_alloc_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "372-388",
    "snippet": "static int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&map_idr",
            "map",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "bpf_map_init_from_attr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "361-370",
    "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_flags_retain_permanent",
          "args": [
            "attr->map_flags"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_flags_retain_permanent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "349-359",
          "snippet": "static u32 bpf_map_flags_retain_permanent(u32 flags)\n{\n\t/* Some map creation flags are not tied to the map object but\n\t * rather to the map fd instead, so they have no meaning upon\n\t * map object inspection since multiple file descriptors with\n\t * different (access) properties can exist here. Thus, given\n\t * this has zero meaning for the map itself, lets clear these\n\t * from here.\n\t */\n\treturn flags & ~(BPF_F_RDONLY | BPF_F_WRONLY);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_flags_retain_permanent(u32 flags)\n{\n\t/* Some map creation flags are not tied to the map object but\n\t * rather to the map fd instead, so they have no meaning upon\n\t * map object inspection since multiple file descriptors with\n\t * different (access) properties can exist here. Thus, given\n\t * this has zero meaning for the map itself, lets clear these\n\t * from here.\n\t */\n\treturn flags & ~(BPF_F_RDONLY | BPF_F_WRONLY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
  },
  {
    "function_name": "bpf_map_flags_retain_permanent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "349-359",
    "snippet": "static u32 bpf_map_flags_retain_permanent(u32 flags)\n{\n\t/* Some map creation flags are not tied to the map object but\n\t * rather to the map fd instead, so they have no meaning upon\n\t * map object inspection since multiple file descriptors with\n\t * different (access) properties can exist here. Thus, given\n\t * this has zero meaning for the map itself, lets clear these\n\t * from here.\n\t */\n\treturn flags & ~(BPF_F_RDONLY | BPF_F_WRONLY);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_flags_retain_permanent(u32 flags)\n{\n\t/* Some map creation flags are not tied to the map object but\n\t * rather to the map fd instead, so they have no meaning upon\n\t * map object inspection since multiple file descriptors with\n\t * different (access) properties can exist here. Thus, given\n\t * this has zero meaning for the map itself, lets clear these\n\t * from here.\n\t */\n\treturn flags & ~(BPF_F_RDONLY | BPF_F_WRONLY);\n}"
  },
  {
    "function_name": "bpf_map_area_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "344-347",
    "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "area"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
  },
  {
    "function_name": "bpf_map_area_mmapable_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "339-342",
    "snippet": "void *bpf_map_area_mmapable_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, true);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_map_area_alloc",
          "args": [
            "size",
            "numa_node",
            "true"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "297-332",
          "snippet": "static void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_mmapable_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, true);\n}"
  },
  {
    "function_name": "bpf_map_area_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "334-337",
    "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_map_area_alloc",
          "args": [
            "size",
            "numa_node",
            "false"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "297-332",
          "snippet": "static void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
  },
  {
    "function_name": "__bpf_map_area_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "297-332",
    "snippet": "static void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_range",
          "args": [
            "size",
            "align",
            "VMALLOC_START",
            "VMALLOC_END",
            "gfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL",
            "PAGE_KERNEL",
            "flags",
            "numa_node",
            "__builtin_return_address(0)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "gfp | GFP_USER | __GFP_NORETRY",
            "numa_node"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PAGE_ALIGNED(size)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "size"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)\n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "bpf_map_copy_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "232-291",
    "snippet": "static int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "164-173",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_instrumentation",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_and_init_map_value",
          "args": [
            "map",
            "value"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_map_value",
          "args": [
            "map",
            "value",
            "ptr"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_map_value_locked",
          "args": [
            "map",
            "value",
            "ptr",
            "true"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "copy_map_value_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "337-351",
          "snippet": "void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ptr"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_lookup_elem_sys_only",
          "args": [
            "map",
            "key"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_map_sys_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_map_sys_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "245-272",
          "snippet": "int bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct bpf_struct_ops_map *st_map = (struct bpf_struct_ops_map *)map;\n\tstruct bpf_struct_ops_value *uvalue, *kvalue;\n\tenum bpf_struct_ops_state state;\n\n\tif (unlikely(*(u32 *)key != 0))\n\t\treturn -ENOENT;\n\n\tkvalue = &st_map->kvalue;\n\t/* Pair with smp_store_release() during map_update */\n\tstate = smp_load_acquire(&kvalue->state);\n\tif (state == BPF_STRUCT_OPS_STATE_INIT) {\n\t\tmemset(value, 0, map->value_size);\n\t\treturn 0;\n\t}\n\n\t/* No lock is needed.  state and refcnt do not need\n\t * to be updated together under atomic context.\n\t */\n\tuvalue = (struct bpf_struct_ops_value *)value;\n\tmemcpy(uvalue, st_map->uvalue, map->value_size);\n\tuvalue->state = state;\n\trefcount_set(&uvalue->refcnt, refcount_read(&kvalue->refcnt));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_peek_elem",
          "args": [
            "map",
            "value"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_reuseport_array_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_reuseport_array_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "170-190",
          "snippet": "int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = __sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = __sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_htab_map_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_htab_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/hashtab.c",
          "lines": "2324-2341",
          "snippet": "int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_HASH",
          "args": [
            "map"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "759-776",
          "snippet": "int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_PROG_ARRAY",
          "args": [
            "map"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FD_ARRAY",
          "args": [
            "map"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_stackmap_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_stackmap_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1029-1032",
          "snippet": "int __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_cgroup_storage_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_cgroup_storage_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "181-208",
          "snippet": "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_array_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_array_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "245-269",
          "snippet": "int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_hash_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_hash_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/hashtab.c",
          "lines": "2176-2206",
          "snippet": "int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\t/* We do not mark LRU map element here in order to not mess up\n\t * eviction heuristics when user space does a map walk.\n\t */\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\t/* We do not mark LRU map element here in order to not mess up\n\t * eviction heuristics when user space does a map walk.\n\t */\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_disable_instrumentation",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "434-445",
          "snippet": "int bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_lookup_elem(offmap, key, value);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_lookup_elem(offmap, key, value);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,\n\t\t\t      __u64 flags)\n{\n\tvoid *ptr;\n\tint err;\n\n\tif (bpf_map_is_dev_bound(map))\n\t\treturn bpf_map_offload_lookup_elem(map, key, value);\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\t/* struct_ops map requires directly updating \"value\" */\n\t\terr = bpf_struct_ops_map_sys_lookup_elem(map, key, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tif (map->ops->map_lookup_elem_sys_only)\n\t\t\tptr = map->ops->map_lookup_elem_sys_only(map, key);\n\t\telse\n\t\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tif (flags & BPF_F_LOCK)\n\t\t\t\t/* lock 'ptr' and copy everything but lock */\n\t\t\t\tcopy_map_value_locked(map, value, ptr, true);\n\t\t\telse\n\t\t\t\tcopy_map_value(map, value, ptr);\n\t\t\t/* mask lock and timer, since value wasn't zero inited */\n\t\t\tcheck_and_init_map_value(map, value);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_map_update_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "175-230",
    "snippet": "static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "164-173",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_enable_instrumentation",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_push_elem",
          "args": [
            "map",
            "value",
            "flags"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_reuseport_array_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_reuseport_array_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/reuseport_array.c",
          "lines": "237-318",
          "snippet": "int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tuintptr_t sk_user_data;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |\n\t\tSK_USER_DATA_BPF;\n\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tuintptr_t sk_user_data;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |\n\t\tSK_USER_DATA_BPF;\n\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_htab_map_update_elem",
          "args": [
            "map",
            "f.file",
            "key",
            "value",
            "flags"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_htab_map_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/hashtab.c",
          "lines": "2344-2360",
          "snippet": "int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_update_elem",
          "args": [
            "map",
            "f.file",
            "key",
            "value",
            "flags"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "779-809",
          "snippet": "int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, new_ptr);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t}\n\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, new_ptr);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t}\n\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_ARRAY",
          "args": [
            "map"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_percpu_cgroup_storage_update",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_cgroup_storage_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/local_storage.c",
          "lines": "210-242",
          "snippet": "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"../cgroup/cgroup-internal.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_local_storage.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../cgroup/cgroup-internal.h\"\n#include <uapi/linux/btf.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/btf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_array_update",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_array_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "335-371",
          "snippet": "int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_hash_update",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_hash_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/hashtab.c",
          "lines": "2208-2224",
          "snippet": "int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_disable_instrumentation",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FD_PROG_ARRAY",
          "args": [
            "map"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_update_elem_sys",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "flags"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_update_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/offload.c",
          "lines": "447-463",
          "snippet": "int bpf_map_offload_update_elem(struct bpf_map *map,\n\t\t\t\tvoid *key, void *value, u64 flags)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_update_elem(offmap, key, value,\n\t\t\t\t\t\t       flags);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_update_elem(struct bpf_map *map,\n\t\t\t\tvoid *key, void *value, u64 flags)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_update_elem(offmap, key, value,\n\t\t\t\t\t\t       flags);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,\n\t\t\t\tvoid *value, __u64 flags)\n{\n\tint err;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\treturn bpf_map_offload_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {\n\t\treturn map->ops->map_update_elem(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\treturn sock_map_update_elem_sys(map, key, value, flags);\n\t} else if (IS_FD_PROG_ARRAY(map)) {\n\t\treturn bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t    flags);\n\t}\n\n\tbpf_disable_instrumentation();\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK ||\n\t\t   map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {\n\t\terr = map->ops->map_push_elem(map, value, flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, flags);\n\t\trcu_read_unlock();\n\t}\n\tbpf_enable_instrumentation();\n\tmaybe_wait_bpf_programs(map);\n\n\treturn err;\n}"
  },
  {
    "function_name": "maybe_wait_bpf_programs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "164-173",
    "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "bpf_map_value_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "151-162",
    "snippet": "static u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_FD_MAP",
          "args": [
            "map"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic u32 bpf_map_value_size(const struct bpf_map *map)\n{\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\treturn round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\treturn sizeof(u32);\n\telse\n\t\treturn  map->value_size;\n}"
  },
  {
    "function_name": "bpf_map_write_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "146-149",
    "snippet": "bool bpf_map_write_active(const struct bpf_map *map)\n{\n\treturn atomic64_read(&map->writecnt) != 0;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&map->writecnt"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nbool bpf_map_write_active(const struct bpf_map *map)\n{\n\treturn atomic64_read(&map->writecnt) != 0;\n}"
  },
  {
    "function_name": "bpf_map_write_active_dec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "141-144",
    "snippet": "static void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&map->writecnt"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_dec(struct bpf_map *map)\n{\n\tatomic64_dec(&map->writecnt);\n}"
  },
  {
    "function_name": "bpf_map_write_active_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "136-139",
    "snippet": "static void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&map->writecnt"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_write_active_inc(struct bpf_map *map)\n{\n\tatomic64_inc(&map->writecnt);\n}"
  },
  {
    "function_name": "find_and_alloc_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "107-134",
    "snippet": "static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};",
      "const struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->map_alloc",
          "args": [
            "attr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->map_alloc_check",
          "args": [
            "attr"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "type",
            "ARRAY_SIZE(bpf_map_types)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_map_types"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_map_types"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#define BPF_LINK_TYPE(_id, _name)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n};\nconst struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_check_uarg_tail_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "77-98",
    "snippet": "int bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_zeroed_user",
          "args": [
            "uaddr.user + expected_size",
            "actual_size - expected_size"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "uaddr.kernel + expected_size",
            "0",
            "actual_size - expected_size"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "actual_size > PAGE_SIZE"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(bpfptr_t uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tint res;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\tif (uaddr.is_kernel)\n\t\tres = memchr_inv(uaddr.kernel + expected_size, 0,\n\t\t\t\t actual_size - expected_size) == NULL;\n\telse\n\t\tres = check_zeroed_user(uaddr.user + expected_size,\n\t\t\t\t\tactual_size - expected_size);\n\tif (res < 0)\n\t\treturn res;\n\treturn res ? 0 : -E2BIG;\n}"
  },
  {
    "function_name": "bpf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
    "lines": "4736-4739",
    "snippet": "SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)\n{\n\treturn __sys_bpf(cmd, USER_BPFPTR(uattr), size);\n}",
    "includes": [
      "#include <linux/memcontrol.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/poll.h>",
      "#include <linux/bpf_lsm.h>",
      "#include <linux/pgtable.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/audit.h>",
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nSYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)\n{\n\treturn __sys_bpf(cmd, USER_BPFPTR(uattr), size);\n}"
  }
]