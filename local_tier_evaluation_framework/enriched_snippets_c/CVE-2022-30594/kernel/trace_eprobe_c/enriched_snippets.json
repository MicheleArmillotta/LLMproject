[
  {
    "function_name": "trace_events_eprobe_init_early",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "943-952",
    "snippet": "static __init int trace_events_eprobe_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&eprobe_dyn_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register eprobe_dyn_event_ops\\n\");\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not register eprobe_dyn_event_ops\\n\""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_event_register",
          "args": [
            "&eprobe_dyn_event_ops"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "59-70",
          "snippet": "int dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(dyn_event_ops_mutex);",
            "static LIST_HEAD(dyn_event_ops_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};\n\nstatic __init int trace_events_eprobe_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&eprobe_dyn_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register eprobe_dyn_event_ops\\n\");\n\n\treturn err;\n}"
  },
  {
    "function_name": "__trace_eprobe_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "849-937",
    "snippet": "static int __trace_eprobe_create(int argc, const char *argv[])\n{\n\t/*\n\t * Argument syntax:\n\t *      e[:[GRP/]ENAME] SYSTEM.EVENT [FETCHARGS]\n\t * Fetch args:\n\t *  <name>=$<field>[:TYPE]\n\t */\n\tconst char *event = NULL, *group = EPROBE_EVENT_SYSTEM;\n\tconst char *sys_event = NULL, *sys_name = NULL;\n\tstruct trace_event_call *event_call;\n\tstruct trace_eprobe *ep = NULL;\n\tchar buf1[MAX_EVENT_NAME_LEN];\n\tchar buf2[MAX_EVENT_NAME_LEN];\n\tint ret = 0;\n\tint i;\n\n\tif (argc < 2 || argv[0][0] != 'e')\n\t\treturn -ECANCELED;\n\n\ttrace_probe_log_init(\"event_probe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event) {\n\t\tevent++;\n\t\tret = traceprobe_parse_event_name(&event, &group, buf1,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t} else {\n\t\tstrscpy(buf1, argv[1], MAX_EVENT_NAME_LEN);\n\t\tsanitize_event_name(buf1);\n\t\tevent = buf1;\n\t}\n\tif (!is_good_name(event) || !is_good_name(group))\n\t\tgoto parse_error;\n\n\tsys_event = argv[1];\n\tret = traceprobe_parse_event_name(&sys_event, &sys_name, buf2,\n\t\t\t\t\t  sys_event - argv[1]);\n\tif (ret || !sys_name)\n\t\tgoto parse_error;\n\tif (!is_good_name(sys_event) || !is_good_name(sys_name))\n\t\tgoto parse_error;\n\n\tmutex_lock(&event_mutex);\n\tevent_call = find_and_get_event(sys_name, sys_event);\n\tep = alloc_event_probe(group, event, event_call, argc - 2);\n\tmutex_unlock(&event_mutex);\n\n\tif (IS_ERR(ep)) {\n\t\tret = PTR_ERR(ep);\n\t\t/* This must return -ENOMEM or missing event, else there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM && ret != -ENODEV);\n\t\tep = NULL;\n\t\tgoto error;\n\t}\n\n\targc -= 2; argv += 2;\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = trace_eprobe_tp_update_arg(ep, argv, i);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tret = traceprobe_set_print_fmt(&ep->tp, PROBE_PRINT_EVENT);\n\tif (ret < 0)\n\t\tgoto error;\n\tinit_trace_eprobe_call(ep);\n\tmutex_lock(&event_mutex);\n\tret = trace_probe_register_event_call(&ep->tp);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t}\n\t\tmutex_unlock(&event_mutex);\n\t\tgoto error;\n\t}\n\tret = dyn_event_add(&ep->devent, &ep->tp.event->call);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\nparse_error:\n\tret = -EINVAL;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define EPROBE_EVENT_SYSTEM \"eprobes\""
    ],
    "globals_used": [
      "static int __trace_eprobe_create(int argc, const char *argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_probe_cleanup",
          "args": [
            "ep"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "42-52",
          "snippet": "static void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&ep->devent",
            "&ep->tp.event->call"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_err",
          "args": [
            "0",
            "EVENT_EXIST"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_probe_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "163-205",
          "snippet": "void __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *trace_probe_err_text[] = { ERRORS };",
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";",
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\nstatic struct trace_probe_log trace_probe_log;\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t/* Recalculate the length and allocate buffer */\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t/**\n\t\t * Set the error position is next to the last arg + space.\n\t\t * Note that len includes the terminal null and the cursor\n\t\t * appears at pos + 1.\n\t\t */\n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t/* And make a command string from argv array */\n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_log_set_index",
          "args": [
            "0"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_set_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "158-161",
          "snippet": "void trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_register_event_call",
          "args": [
            "&ep->tp"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_register_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1083-1103",
          "snippet": "int trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_trace_eprobe_call",
          "args": [
            "ep"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "init_trace_eprobe_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "794-802",
          "snippet": "static inline void init_trace_eprobe_call(struct trace_eprobe *ep)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);\n\n\tcall->flags = TRACE_EVENT_FL_EPROBE;\n\tcall->event.funcs = &eprobe_funcs;\n\tcall->class->fields_array = eprobe_fields_array;\n\tcall->class->reg = eprobe_register;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_event_fields eprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = eprobe_event_define_fields },\n\t{}\n};",
            "static struct trace_event_functions eprobe_funcs = {\n\t.trace\t\t= print_eprobe_event\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_event_fields eprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = eprobe_event_define_fields },\n\t{}\n};\nstatic struct trace_event_functions eprobe_funcs = {\n\t.trace\t\t= print_eprobe_event\n};\n\nstatic inline void init_trace_eprobe_call(struct trace_eprobe *ep)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);\n\n\tcall->flags = TRACE_EVENT_FL_EPROBE;\n\tcall->event.funcs = &eprobe_funcs;\n\tcall->class->fields_array = eprobe_fields_array;\n\tcall->class->reg = eprobe_register;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_set_print_fmt",
          "args": [
            "&ep->tp",
            "PROBE_PRINT_EVENT"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_set_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "935-952",
          "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_eprobe_tp_update_arg",
          "args": [
            "ep",
            "argv",
            "i"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "trace_eprobe_tp_update_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "834-847",
          "snippet": "static int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)\n{\n\tunsigned int flags = TPARG_FL_KERNEL | TPARG_FL_TPOINT;\n\tint ret;\n\n\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->tp.args[i].code->op == FETCH_OP_TP_ARG)\n\t\tret = trace_eprobe_tp_arg_update(ep, i);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __trace_eprobe_create(int argc, const char *argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int __trace_eprobe_create(int argc, const char *argv[]);\n\nstatic int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)\n{\n\tunsigned int flags = TPARG_FL_KERNEL | TPARG_FL_TPOINT;\n\tint ret;\n\n\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->tp.args[i].code->op == FETCH_OP_TP_ARG)\n\t\tret = trace_eprobe_tp_arg_update(ep, i);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret != -ENOMEM && ret != -ENODEV"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ep"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ep"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_event_probe",
          "args": [
            "group",
            "event",
            "event_call",
            "argc - 2"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_event_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "184-222",
          "snippet": "static struct trace_eprobe *alloc_event_probe(const char *group,\n\t\t\t\t\t      const char *this_event,\n\t\t\t\t\t      struct trace_event_call *event,\n\t\t\t\t\t      int nargs)\n{\n\tstruct trace_eprobe *ep;\n\tconst char *event_name;\n\tconst char *sys_name;\n\tint ret = -ENOMEM;\n\n\tif (!event)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsys_name = event->class->system;\n\tevent_name = trace_event_name(event);\n\n\tep = kzalloc(struct_size(ep, tp.args, nargs), GFP_KERNEL);\n\tif (!ep) {\n\t\ttrace_event_put_ref(event);\n\t\tgoto error;\n\t}\n\tep->event = event;\n\tep->event_name = kstrdup(event_name, GFP_KERNEL);\n\tif (!ep->event_name)\n\t\tgoto error;\n\tep->event_system = kstrdup(sys_name, GFP_KERNEL);\n\tif (!ep->event_system)\n\t\tgoto error;\n\n\tret = trace_probe_init(&ep->tp, this_event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&ep->devent, &eprobe_dyn_event_ops);\n\treturn ep;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};\n\nstatic struct trace_eprobe *alloc_event_probe(const char *group,\n\t\t\t\t\t      const char *this_event,\n\t\t\t\t\t      struct trace_event_call *event,\n\t\t\t\t\t      int nargs)\n{\n\tstruct trace_eprobe *ep;\n\tconst char *event_name;\n\tconst char *sys_name;\n\tint ret = -ENOMEM;\n\n\tif (!event)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsys_name = event->class->system;\n\tevent_name = trace_event_name(event);\n\n\tep = kzalloc(struct_size(ep, tp.args, nargs), GFP_KERNEL);\n\tif (!ep) {\n\t\ttrace_event_put_ref(event);\n\t\tgoto error;\n\t}\n\tep->event = event;\n\tep->event_name = kstrdup(event_name, GFP_KERNEL);\n\tif (!ep->event_name)\n\t\tgoto error;\n\tep->event_system = kstrdup(sys_name, GFP_KERNEL);\n\tif (!ep->event_system)\n\t\tgoto error;\n\n\tret = trace_probe_init(&ep->tp, this_event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&ep->devent, &eprobe_dyn_event_ops);\n\treturn ep;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_and_get_event",
          "args": [
            "sys_name",
            "sys_event"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_get_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "804-832",
          "snippet": "static struct trace_event_call *\nfind_and_get_event(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\t/* Skip other probes and ftrace events */\n\t\tif (tp_event->flags &\n\t\t    (TRACE_EVENT_FL_IGNORE_ENABLE |\n\t\t     TRACE_EVENT_FL_KPROBE |\n\t\t     TRACE_EVENT_FL_UPROBE |\n\t\t     TRACE_EVENT_FL_EPROBE))\n\t\t\tcontinue;\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\tif (!trace_event_try_get_ref(tp_event)) {\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn tp_event;\n\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_event_call *\nfind_and_get_event(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\t/* Skip other probes and ftrace events */\n\t\tif (tp_event->flags &\n\t\t    (TRACE_EVENT_FL_IGNORE_ENABLE |\n\t\t     TRACE_EVENT_FL_KPROBE |\n\t\t     TRACE_EVENT_FL_UPROBE |\n\t\t     TRACE_EVENT_FL_EPROBE))\n\t\t\tcontinue;\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\tif (!trace_event_try_get_ref(tp_event)) {\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn tp_event;\n\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "sys_name"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1976-1985",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_event_name",
          "args": [
            "&sys_event",
            "&sys_name",
            "buf2",
            "sys_event - argv[1]"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_event_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "229-271",
          "snippet": "int traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrlcpy(buf, event, slash - event + 1);\n\t\tif (!is_good_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_event_name",
          "args": [
            "buf1"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_event_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1988-1993",
          "snippet": "static inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void sanitize_event_name(char *name)\n{\n\twhile (*name++ != '\\0')\n\t\tif (*name == ':' || *name == '.')\n\t\t\t*name = '_';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "buf1",
            "argv[1]",
            "MAX_EVENT_NAME_LEN"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "&argv[0][1]",
            "':'"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_log_init",
          "args": [
            "\"event_probe\"",
            "argc",
            "argv"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_log_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "145-151",
          "snippet": "void trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_probe_log trace_probe_log;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EPROBE_EVENT_SYSTEM \"eprobes\"\n\nstatic int __trace_eprobe_create(int argc, const char *argv[]);\n\nstatic int __trace_eprobe_create(int argc, const char *argv[])\n{\n\t/*\n\t * Argument syntax:\n\t *      e[:[GRP/]ENAME] SYSTEM.EVENT [FETCHARGS]\n\t * Fetch args:\n\t *  <name>=$<field>[:TYPE]\n\t */\n\tconst char *event = NULL, *group = EPROBE_EVENT_SYSTEM;\n\tconst char *sys_event = NULL, *sys_name = NULL;\n\tstruct trace_event_call *event_call;\n\tstruct trace_eprobe *ep = NULL;\n\tchar buf1[MAX_EVENT_NAME_LEN];\n\tchar buf2[MAX_EVENT_NAME_LEN];\n\tint ret = 0;\n\tint i;\n\n\tif (argc < 2 || argv[0][0] != 'e')\n\t\treturn -ECANCELED;\n\n\ttrace_probe_log_init(\"event_probe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event) {\n\t\tevent++;\n\t\tret = traceprobe_parse_event_name(&event, &group, buf1,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t} else {\n\t\tstrscpy(buf1, argv[1], MAX_EVENT_NAME_LEN);\n\t\tsanitize_event_name(buf1);\n\t\tevent = buf1;\n\t}\n\tif (!is_good_name(event) || !is_good_name(group))\n\t\tgoto parse_error;\n\n\tsys_event = argv[1];\n\tret = traceprobe_parse_event_name(&sys_event, &sys_name, buf2,\n\t\t\t\t\t  sys_event - argv[1]);\n\tif (ret || !sys_name)\n\t\tgoto parse_error;\n\tif (!is_good_name(sys_event) || !is_good_name(sys_name))\n\t\tgoto parse_error;\n\n\tmutex_lock(&event_mutex);\n\tevent_call = find_and_get_event(sys_name, sys_event);\n\tep = alloc_event_probe(group, event, event_call, argc - 2);\n\tmutex_unlock(&event_mutex);\n\n\tif (IS_ERR(ep)) {\n\t\tret = PTR_ERR(ep);\n\t\t/* This must return -ENOMEM or missing event, else there is a bug */\n\t\tWARN_ON_ONCE(ret != -ENOMEM && ret != -ENODEV);\n\t\tep = NULL;\n\t\tgoto error;\n\t}\n\n\targc -= 2; argv += 2;\n\t/* parse arguments */\n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = trace_eprobe_tp_update_arg(ep, argv, i);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tret = traceprobe_set_print_fmt(&ep->tp, PROBE_PRINT_EVENT);\n\tif (ret < 0)\n\t\tgoto error;\n\tinit_trace_eprobe_call(ep);\n\tmutex_lock(&event_mutex);\n\tret = trace_probe_register_event_call(&ep->tp);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t}\n\t\tmutex_unlock(&event_mutex);\n\t\tgoto error;\n\t}\n\tret = dyn_event_add(&ep->devent, &ep->tp.event->call);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\nparse_error:\n\tret = -EINVAL;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_eprobe_tp_update_arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "834-847",
    "snippet": "static int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)\n{\n\tunsigned int flags = TPARG_FL_KERNEL | TPARG_FL_TPOINT;\n\tint ret;\n\n\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->tp.args[i].code->op == FETCH_OP_TP_ARG)\n\t\tret = trace_eprobe_tp_arg_update(ep, i);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __trace_eprobe_create(int argc, const char *argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_eprobe_tp_arg_update",
          "args": [
            "ep",
            "i"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "trace_eprobe_tp_arg_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "224-241",
          "snippet": "static int trace_eprobe_tp_arg_update(struct trace_eprobe *ep, int i)\n{\n\tstruct probe_arg *parg = &ep->tp.args[i];\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(ep->event);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(parg->code->data, field->name)) {\n\t\t\tkfree(parg->code->data);\n\t\t\tparg->code->data = field;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tkfree(parg->code->data);\n\tparg->code->data = NULL;\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_eprobe_tp_arg_update(struct trace_eprobe *ep, int i)\n{\n\tstruct probe_arg *parg = &ep->tp.args[i];\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(ep->event);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(parg->code->data, field->name)) {\n\t\t\tkfree(parg->code->data);\n\t\t\tparg->code->data = field;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tkfree(parg->code->data);\n\tparg->code->data = NULL;\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_parse_probe_arg",
          "args": [
            "&ep->tp",
            "i",
            "argv[i]",
            "flags"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_parse_probe_arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "770-809",
          "snippet": "int traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t\tunsigned int flags)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t/* Increment count for freeing args in error case */\n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\t/* If argument name is omitted, set \"argN\" */\n\t\tparg->name = kasprintf(GFP_KERNEL, \"arg%d\", i + 1);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\t/* Parse fetch argument */\n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, flags,\n\t\t\t\t\t       body - arg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int __trace_eprobe_create(int argc, const char *argv[]);\n\nstatic int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)\n{\n\tunsigned int flags = TPARG_FL_KERNEL | TPARG_FL_TPOINT;\n\tint ret;\n\n\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->tp.args[i].code->op == FETCH_OP_TP_ARG)\n\t\tret = trace_eprobe_tp_arg_update(ep, i);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_and_get_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "804-832",
    "snippet": "static struct trace_event_call *\nfind_and_get_event(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\t/* Skip other probes and ftrace events */\n\t\tif (tp_event->flags &\n\t\t    (TRACE_EVENT_FL_IGNORE_ENABLE |\n\t\t     TRACE_EVENT_FL_KPROBE |\n\t\t     TRACE_EVENT_FL_UPROBE |\n\t\t     TRACE_EVENT_FL_EPROBE))\n\t\t\tcontinue;\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\tif (!trace_event_try_get_ref(tp_event)) {\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn tp_event;\n\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_try_get_ref",
          "args": [
            "tp_event"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "name"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "tp_event"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_event",
            "&ftrace_events",
            "list"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_event_call *\nfind_and_get_event(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\t/* Skip other probes and ftrace events */\n\t\tif (tp_event->flags &\n\t\t    (TRACE_EVENT_FL_IGNORE_ENABLE |\n\t\t     TRACE_EVENT_FL_KPROBE |\n\t\t     TRACE_EVENT_FL_UPROBE |\n\t\t     TRACE_EVENT_FL_EPROBE))\n\t\t\tcontinue;\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\tif (!trace_event_try_get_ref(tp_event)) {\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn tp_event;\n\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_trace_eprobe_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "794-802",
    "snippet": "static inline void init_trace_eprobe_call(struct trace_eprobe *ep)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);\n\n\tcall->flags = TRACE_EVENT_FL_EPROBE;\n\tcall->event.funcs = &eprobe_funcs;\n\tcall->class->fields_array = eprobe_fields_array;\n\tcall->class->reg = eprobe_register;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_fields eprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = eprobe_event_define_fields },\n\t{}\n};",
      "static struct trace_event_functions eprobe_funcs = {\n\t.trace\t\t= print_eprobe_event\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&ep->tp"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_event_fields eprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = eprobe_event_define_fields },\n\t{}\n};\nstatic struct trace_event_functions eprobe_funcs = {\n\t.trace\t\t= print_eprobe_event\n};\n\nstatic inline void init_trace_eprobe_call(struct trace_eprobe *ep)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);\n\n\tcall->flags = TRACE_EVENT_FL_EPROBE;\n\tcall->event.funcs = &eprobe_funcs;\n\tcall->class->fields_array = eprobe_fields_array;\n\tcall->class->reg = eprobe_register;\n}"
  },
  {
    "function_name": "eprobe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "771-792",
    "snippet": "static int eprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_eprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_eprobe(event, file);\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_trace_eprobe",
          "args": [
            "event",
            "file"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "disable_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "732-769",
          "snippet": "static int disable_trace_eprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp)) {\n\t\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\t}\n\t}\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int disable_trace_eprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp)) {\n\t\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\t}\n\t}\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_trace_eprobe",
          "args": [
            "event",
            "file"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "enable_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "687-730",
          "snippet": "static int enable_trace_eprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\tret = enable_eprobe(ep, file);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int enable_trace_eprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\tret = enable_eprobe(ep, file);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_eprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_eprobe(event, file);\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "disable_trace_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "732-769",
    "snippet": "static int disable_trace_eprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp)) {\n\t\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\t}\n\t}\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_eprobe",
          "args": [
            "ep",
            "file->tr"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "disable_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "652-685",
          "snippet": "static int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "pos",
            "structtrace_eprobe",
            "tp"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "trace_probe_probe_list(tp)",
            "list"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_has_single_file",
          "args": [
            "tp"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_single_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "327-330",
          "snippet": "static inline bool trace_probe_has_single_file(struct trace_probe *tp)\n{\n\treturn !!list_is_singular(&tp->event->files);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_single_file(struct trace_probe *tp)\n{\n\treturn !!list_is_singular(&tp->event->files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_get_file_link",
          "args": [
            "tp",
            "file"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_get_file_link",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1120-1131",
          "snippet": "struct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int disable_trace_eprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp)) {\n\t\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\t}\n\t}\n\n out:\n\tif (file)\n\t\t/*\n\t\t * Synchronization is done in below function. For perf event,\n\t\t * file == NULL and perf_trace_event_unreg() calls\n\t\t * tracepoint_synchronize_unregister() to ensure synchronize\n\t\t * event. We don't need to care about it.\n\t\t */\n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_trace_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "687-730",
    "snippet": "static int enable_trace_eprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\tret = enable_eprobe(ep, file);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_clear_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_clear_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "268-272",
          "snippet": "static inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_remove_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_remove_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1133-1149",
          "snippet": "int trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_eprobe",
          "args": [
            "ep",
            "file->tr"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "disable_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "652-685",
          "snippet": "static int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_eprobe",
          "args": [
            "ep",
            "file"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "enable_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "626-646",
          "snippet": "static int enable_eprobe(struct trace_eprobe *ep,\n\t\t\t struct trace_event_file *eprobe_file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = eprobe_file->tr;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\ttrigger = new_eprobe_trigger(ep, eprobe_file);\n\tif (IS_ERR(trigger))\n\t\treturn PTR_ERR(trigger);\n\n\tlist_add_tail_rcu(&trigger->list, &file->triggers);\n\n\ttrace_event_trigger_enable_disable(file, 1);\n\tupdate_cond_flag(file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int enable_eprobe(struct trace_eprobe *ep,\n\t\t\t struct trace_event_file *eprobe_file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = eprobe_file->tr;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\ttrigger = new_eprobe_trigger(ep, eprobe_file);\n\tif (IS_ERR(trigger))\n\t\treturn PTR_ERR(trigger);\n\n\tlist_add_tail_rcu(&trigger->list, &file->triggers);\n\n\ttrace_event_trigger_enable_disable(file, 1);\n\tupdate_cond_flag(file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "pos",
            "structtrace_eprobe",
            "tp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "trace_probe_probe_list(tp)",
            "list"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_probe_list",
          "args": [
            "tp"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_probe_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "309-312",
          "snippet": "static inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_set_flag",
          "args": [
            "tp",
            "TP_FLAG_PROFILE"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_set_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "262-266",
          "snippet": "static inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\tconst char *argv, unsigned int flags);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_add_file",
          "args": [
            "tp",
            "file"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_add_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1105-1118",
          "snippet": "int trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "tp"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "call"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int enable_trace_eprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *pos, *tp;\n\tstruct trace_eprobe *ep;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t/* This also changes \"enabled\" state */\n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, trace_probe_probe_list(tp), list) {\n\t\tep = container_of(pos, struct trace_eprobe, tp);\n\t\tret = enable_eprobe(ep, file);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t}\n\n\tif (ret) {\n\t\t/* Failed to enable one of them. Roll back all */\n\t\tif (enabled)\n\t\t\tdisable_eprobe(ep, file->tr);\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "disable_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "652-685",
    "snippet": "static int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&trigger->list"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "trigger",
            "&file->triggers",
            "list"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "trigger",
            "&file->triggers",
            "list"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "ep->event_system",
            "ep->event_name"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(trigger, &file->triggers, list) {\n\t\tif (!(trigger->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = trigger->private_data;\n\t\tif (edata->ep == ep)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(trigger, &file->triggers, list))\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t/* Make sure nothing is using the edata or trigger */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "626-646",
    "snippet": "static int enable_eprobe(struct trace_eprobe *ep,\n\t\t\t struct trace_event_file *eprobe_file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = eprobe_file->tr;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\ttrigger = new_eprobe_trigger(ep, eprobe_file);\n\tif (IS_ERR(trigger))\n\t\treturn PTR_ERR(trigger);\n\n\tlist_add_tail_rcu(&trigger->list, &file->triggers);\n\n\ttrace_event_trigger_enable_disable(file, 1);\n\tupdate_cond_flag(file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&trigger->list",
            "&file->triggers"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trigger"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trigger"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_eprobe_trigger",
          "args": [
            "ep",
            "eprobe_file"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "new_eprobe_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "591-624",
          "snippet": "static struct event_trigger_data *\nnew_eprobe_trigger(struct trace_eprobe *ep, struct trace_event_file *file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct eprobe_data *edata;\n\n\tedata = kzalloc(sizeof(*edata), GFP_KERNEL);\n\ttrigger = kzalloc(sizeof(*trigger), GFP_KERNEL);\n\tif (!trigger || !edata) {\n\t\tkfree(edata);\n\t\tkfree(trigger);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\ttrigger->flags = EVENT_TRIGGER_FL_PROBE;\n\ttrigger->count = -1;\n\ttrigger->ops = &eprobe_trigger_ops;\n\n\t/*\n\t * EVENT PROBE triggers are not registered as commands with\n\t * register_event_command(), as they are not controlled by the user\n\t * from the trigger file\n\t */\n\ttrigger->cmd_ops = &event_trigger_cmd;\n\n\tINIT_LIST_HEAD(&trigger->list);\n\tRCU_INIT_POINTER(trigger->filter, NULL);\n\n\tedata->file = file;\n\tedata->ep = ep;\n\ttrigger->private_data = edata;\n\n\treturn trigger;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};",
            "static struct event_command event_trigger_cmd = {\n\t.name\t\t\t= \"eprobe\",\n\t.trigger_type\t\t= ETT_EVENT_EPROBE,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= eprobe_trigger_cmd_parse,\n\t.reg\t\t\t= eprobe_trigger_reg_func,\n\t.unreg\t\t\t= eprobe_trigger_unreg_func,\n\t.unreg_all\t\t= NULL,\n\t.get_trigger_ops\t= eprobe_trigger_get_ops,\n\t.set_filter\t\t= NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};\nstatic struct event_command event_trigger_cmd = {\n\t.name\t\t\t= \"eprobe\",\n\t.trigger_type\t\t= ETT_EVENT_EPROBE,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= eprobe_trigger_cmd_parse,\n\t.reg\t\t\t= eprobe_trigger_reg_func,\n\t.unreg\t\t\t= eprobe_trigger_unreg_func,\n\t.unreg_all\t\t= NULL,\n\t.get_trigger_ops\t= eprobe_trigger_get_ops,\n\t.set_filter\t\t= NULL,\n};\n\nstatic struct event_trigger_data *\nnew_eprobe_trigger(struct trace_eprobe *ep, struct trace_event_file *file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct eprobe_data *edata;\n\n\tedata = kzalloc(sizeof(*edata), GFP_KERNEL);\n\ttrigger = kzalloc(sizeof(*trigger), GFP_KERNEL);\n\tif (!trigger || !edata) {\n\t\tkfree(edata);\n\t\tkfree(trigger);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\ttrigger->flags = EVENT_TRIGGER_FL_PROBE;\n\ttrigger->count = -1;\n\ttrigger->ops = &eprobe_trigger_ops;\n\n\t/*\n\t * EVENT PROBE triggers are not registered as commands with\n\t * register_event_command(), as they are not controlled by the user\n\t * from the trigger file\n\t */\n\ttrigger->cmd_ops = &event_trigger_cmd;\n\n\tINIT_LIST_HEAD(&trigger->list);\n\tRCU_INIT_POINTER(trigger->filter, NULL);\n\n\tedata->file = file;\n\tedata->ep = ep;\n\ttrigger->private_data = edata;\n\n\treturn trigger;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "ep->event_system",
            "ep->event_name"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int enable_eprobe(struct trace_eprobe *ep,\n\t\t\t struct trace_event_file *eprobe_file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = eprobe_file->tr;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\ttrigger = new_eprobe_trigger(ep, eprobe_file);\n\tif (IS_ERR(trigger))\n\t\treturn PTR_ERR(trigger);\n\n\tlist_add_tail_rcu(&trigger->list, &file->triggers);\n\n\ttrace_event_trigger_enable_disable(file, 1);\n\tupdate_cond_flag(file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "new_eprobe_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "591-624",
    "snippet": "static struct event_trigger_data *\nnew_eprobe_trigger(struct trace_eprobe *ep, struct trace_event_file *file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct eprobe_data *edata;\n\n\tedata = kzalloc(sizeof(*edata), GFP_KERNEL);\n\ttrigger = kzalloc(sizeof(*trigger), GFP_KERNEL);\n\tif (!trigger || !edata) {\n\t\tkfree(edata);\n\t\tkfree(trigger);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\ttrigger->flags = EVENT_TRIGGER_FL_PROBE;\n\ttrigger->count = -1;\n\ttrigger->ops = &eprobe_trigger_ops;\n\n\t/*\n\t * EVENT PROBE triggers are not registered as commands with\n\t * register_event_command(), as they are not controlled by the user\n\t * from the trigger file\n\t */\n\ttrigger->cmd_ops = &event_trigger_cmd;\n\n\tINIT_LIST_HEAD(&trigger->list);\n\tRCU_INIT_POINTER(trigger->filter, NULL);\n\n\tedata->file = file;\n\tedata->ep = ep;\n\ttrigger->private_data = edata;\n\n\treturn trigger;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};",
      "static struct event_command event_trigger_cmd = {\n\t.name\t\t\t= \"eprobe\",\n\t.trigger_type\t\t= ETT_EVENT_EPROBE,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= eprobe_trigger_cmd_parse,\n\t.reg\t\t\t= eprobe_trigger_reg_func,\n\t.unreg\t\t\t= eprobe_trigger_unreg_func,\n\t.unreg_all\t\t= NULL,\n\t.get_trigger_ops\t= eprobe_trigger_get_ops,\n\t.set_filter\t\t= NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger->filter",
            "NULL"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger->list"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger)",
            "GFP_KERNEL"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*edata)",
            "GFP_KERNEL"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};\nstatic struct event_command event_trigger_cmd = {\n\t.name\t\t\t= \"eprobe\",\n\t.trigger_type\t\t= ETT_EVENT_EPROBE,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= eprobe_trigger_cmd_parse,\n\t.reg\t\t\t= eprobe_trigger_reg_func,\n\t.unreg\t\t\t= eprobe_trigger_unreg_func,\n\t.unreg_all\t\t= NULL,\n\t.get_trigger_ops\t= eprobe_trigger_get_ops,\n\t.set_filter\t\t= NULL,\n};\n\nstatic struct event_trigger_data *\nnew_eprobe_trigger(struct trace_eprobe *ep, struct trace_event_file *file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct eprobe_data *edata;\n\n\tedata = kzalloc(sizeof(*edata), GFP_KERNEL);\n\ttrigger = kzalloc(sizeof(*trigger), GFP_KERNEL);\n\tif (!trigger || !edata) {\n\t\tkfree(edata);\n\t\tkfree(trigger);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\ttrigger->flags = EVENT_TRIGGER_FL_PROBE;\n\ttrigger->count = -1;\n\ttrigger->ops = &eprobe_trigger_ops;\n\n\t/*\n\t * EVENT PROBE triggers are not registered as commands with\n\t * register_event_command(), as they are not controlled by the user\n\t * from the trigger file\n\t */\n\ttrigger->cmd_ops = &event_trigger_cmd;\n\n\tINIT_LIST_HEAD(&trigger->list);\n\tRCU_INIT_POINTER(trigger->filter, NULL);\n\n\tedata->file = file;\n\tedata->ep = ep;\n\ttrigger->private_data = edata;\n\n\treturn trigger;\n}"
  },
  {
    "function_name": "eprobe_trigger_get_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "573-577",
    "snippet": "static struct event_trigger_ops *eprobe_trigger_get_ops(char *cmd,\n\t\t\t\t\t\t\tchar *param)\n{\n\treturn &eprobe_trigger_ops;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};\n\nstatic struct event_trigger_ops *eprobe_trigger_get_ops(char *cmd,\n\t\t\t\t\t\t\tchar *param)\n{\n\treturn &eprobe_trigger_ops;\n}"
  },
  {
    "function_name": "eprobe_trigger_unreg_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "566-571",
    "snippet": "static void eprobe_trigger_unreg_func(char *glob,\n\t\t\t\t      struct event_trigger_data *data,\n\t\t\t\t      struct trace_event_file *file)\n{\n\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void eprobe_trigger_unreg_func(char *glob,\n\t\t\t\t      struct event_trigger_data *data,\n\t\t\t\t      struct trace_event_file *file)\n{\n\n}"
  },
  {
    "function_name": "eprobe_trigger_reg_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "559-564",
    "snippet": "static int eprobe_trigger_reg_func(char *glob,\n\t\t\t\t   struct event_trigger_data *data,\n\t\t\t\t   struct trace_event_file *file)\n{\n\treturn -1;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_trigger_reg_func(char *glob,\n\t\t\t\t   struct event_trigger_data *data,\n\t\t\t\t   struct trace_event_file *file)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "eprobe_trigger_cmd_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "552-557",
    "snippet": "static int eprobe_trigger_cmd_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\treturn -1;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_trigger_cmd_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd, char *param)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "eprobe_trigger_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "536-543",
    "snippet": "static void eprobe_trigger_func(struct event_trigger_data *data,\n\t\t\t\tstruct trace_buffer *buffer, void *rec,\n\t\t\t\tstruct ring_buffer_event *rbe)\n{\n\tstruct eprobe_data *edata = data->private_data;\n\n\t__eprobe_trace_func(edata, rec);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__eprobe_trace_func",
          "args": [
            "edata",
            "rec"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__eprobe_trace_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "478-508",
          "snippet": "static inline void\n__eprobe_trace_func(struct eprobe_data *edata, void *rec)\n{\n\tstruct eprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != edata->file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(edata->file))\n\t\treturn;\n\n\tdsize = get_eprobe_size(&edata->ep->tp, rec);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,\n\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tif (edata->ep->event)\n\t\tentry->type = edata->ep->event->event.type;\n\telse\n\t\tentry->type = 0;\n\tstore_trace_args(&entry[1], &edata->ep->tp, rec, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void\n__eprobe_trace_func(struct eprobe_data *edata, void *rec)\n{\n\tstruct eprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != edata->file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(edata->file))\n\t\treturn;\n\n\tdsize = get_eprobe_size(&edata->ep->tp, rec);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,\n\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tif (edata->ep->event)\n\t\tentry->type = edata->ep->event->event.type;\n\telse\n\t\tentry->type = 0;\n\tstore_trace_args(&entry[1], &edata->ep->tp, rec, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void eprobe_trigger_func(struct event_trigger_data *data,\n\t\t\t\tstruct trace_buffer *buffer, void *rec,\n\t\t\t\tstruct ring_buffer_event *rbe)\n{\n\tstruct eprobe_data *edata = data->private_data;\n\n\t__eprobe_trace_func(edata, rec);\n}"
  },
  {
    "function_name": "eprobe_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "528-534",
    "snippet": "static int eprobe_trigger_print(struct seq_file *m,\n\t\t\t\tstruct event_trigger_ops *ops,\n\t\t\t\tstruct event_trigger_data *data)\n{\n\t/* Do not print eprobe event triggers */\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_trigger_print(struct seq_file *m,\n\t\t\t\tstruct event_trigger_ops *ops,\n\t\t\t\tstruct event_trigger_data *data)\n{\n\t/* Do not print eprobe event triggers */\n\treturn 0;\n}"
  },
  {
    "function_name": "eprobe_trigger_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "522-526",
    "snippet": "static void eprobe_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\tstruct event_trigger_data *data)\n{\n\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void eprobe_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\tstruct event_trigger_data *data)\n{\n\n}"
  },
  {
    "function_name": "eprobe_trigger_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "516-520",
    "snippet": "static int eprobe_trigger_init(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_trigger_init(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "__eprobe_trace_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "478-508",
    "snippet": "static inline void\n__eprobe_trace_func(struct eprobe_data *edata, void *rec)\n{\n\tstruct eprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != edata->file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(edata->file))\n\t\treturn;\n\n\tdsize = get_eprobe_size(&edata->ep->tp, rec);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,\n\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tif (edata->ep->event)\n\t\tentry->type = edata->ep->event->event.type;\n\telse\n\t\tentry->type = 0;\n\tstore_trace_args(&entry[1], &edata->ep->tp, rec, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_trace_args",
          "args": [
            "&entry[1]",
            "&edata->ep->tp",
            "rec",
            "sizeof(*entry)",
            "dsize"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "store_trace_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "190-214",
          "snippet": "static nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t/* Data location */\n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t/* Point the dynamic data area if needed */\n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (unlikely(ret < 0 && arg->dynamic)) {\n\t\t\t*dl = make_data_loc(0, dyndata - base);\n\t\t} else {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "fbuffer.event"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "edata->file",
            "sizeof(*entry) + edata->ep->tp.size + dsize"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_eprobe_size",
          "args": [
            "&edata->ep->tp",
            "rec"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "get_eprobe_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "340-358",
          "snippet": "static int get_eprobe_size(struct trace_probe *tp, void *rec)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tunsigned long val;\n\n\t\t\tval = get_event_field(arg->code, rec);\n\t\t\tlen = process_fetch_insn_bottom(arg->code + 1, val, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int get_eprobe_size(struct trace_probe *tp, void *rec)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tunsigned long val;\n\n\t\t\tval = get_event_field(arg->code, rec);\n\t\t\tlen = process_fetch_insn_bottom(arg->code + 1, val, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "edata->file"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call != edata->file->event_call"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_event_call",
          "args": [
            "&edata->ep->tp"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "289-293",
          "snippet": "static inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void\n__eprobe_trace_func(struct eprobe_data *edata, void *rec)\n{\n\tstruct eprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != edata->file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(edata->file))\n\t\treturn;\n\n\tdsize = get_eprobe_size(&edata->ep->tp, rec);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,\n\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tif (edata->ep->event)\n\t\tentry->type = edata->ep->event->event.type;\n\telse\n\t\tentry->type = 0;\n\tstore_trace_args(&entry[1], &edata->ep->tp, rec, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}"
  },
  {
    "function_name": "probe_mem_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "467-475",
    "snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_mem_read_user",
          "args": [
            "dest",
            "src",
            "size"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "probe_mem_read_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "459-465",
          "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)src < TASK_SIZE)\n\t\treturn probe_mem_read_user(dest, src, size);\n#endif\n\treturn copy_from_kernel_nofault(dest, src, size);\n}"
  },
  {
    "function_name": "probe_mem_read_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "459-465",
    "snippet": "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user_nofault",
          "args": [
            "dest",
            "uaddr",
            "size"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\tconst void __user *uaddr =  (__force const void __user *)src;\n\n\treturn copy_from_user_nofault(dest, uaddr, size);\n}"
  },
  {
    "function_name": "fetch_store_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "431-457",
    "snippet": "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "__dest - base"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_kernel_nofault",
          "args": [
            "__dest",
            "(void *)addr",
            "maxlen"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_store_string_user",
          "args": [
            "addr",
            "dest",
            "base"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_string_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "407-425",
          "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "*(u32 *)dest"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif ((unsigned long)addr < TASK_SIZE)\n\t\treturn fetch_store_string_user(addr, dest, base);\n#endif\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\t/*\n\t * Try to get string again, since the string can be changed while\n\t * probing.\n\t */\n\tret = strncpy_from_kernel_nofault(__dest, (void *)addr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fetch_store_string_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "407-425",
    "snippet": "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_data_loc",
          "args": [
            "ret",
            "__dest - base"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user_nofault",
          "args": [
            "__dest",
            "uaddr",
            "maxlen"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "dest",
            "base"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!maxlen"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_loc_len",
          "args": [
            "*(u32 *)dest"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\tlong ret;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\tret = strncpy_from_user_nofault(__dest, uaddr, maxlen);\n\tif (ret >= 0)\n\t\t*(u32 *)dest = make_data_loc(ret, __dest - base);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fetch_store_strlen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "384-401",
    "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&c",
            "(u8 *)addr + len",
            "1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_store_strlen_user",
          "args": [
            "addr"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "375-381",
          "snippet": "int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
  },
  {
    "function_name": "fetch_store_strlen_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "375-381",
    "snippet": "int\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strnlen_user_nofault",
          "args": [
            "uaddr",
            "MAX_STRING_SIZE"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint\nfetch_store_strlen_user(unsigned long addr)\n{\n\tconst void __user *uaddr =  (__force const void __user *)addr;\n\n\treturn strnlen_user_nofault(uaddr, MAX_STRING_SIZE);\n}"
  },
  {
    "function_name": "process_fetch_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "363-371",
    "snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\n\tval = get_event_field(code, rec);\n\treturn process_fetch_insn_bottom(code + 1, val, dest, base);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "code + 1",
            "val",
            "dest",
            "base"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_event_field",
          "args": [
            "code",
            "rec"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "get_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "303-338",
          "snippet": "static unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\n\tval = get_event_field(code, rec);\n\treturn process_fetch_insn_bottom(code + 1, val, dest, base);\n}"
  },
  {
    "function_name": "get_eprobe_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "340-358",
    "snippet": "static int get_eprobe_size(struct trace_probe *tp, void *rec)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tunsigned long val;\n\n\t\t\tval = get_event_field(arg->code, rec);\n\t\t\tlen = process_fetch_insn_bottom(arg->code + 1, val, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_fetch_insn_bottom",
          "args": [
            "arg->code + 1",
            "val",
            "NULL",
            "NULL"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "process_fetch_insn_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "71-168",
          "snippet": "static nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);",
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t/* 2nd stage: dereference memory if needed */\n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t/* 3rd stage: store value to buffer */\n\tif (unlikely(!dest)) {\n\t\tif (code->op == FETCH_OP_ST_STRING) {\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else if (code->op == FETCH_OP_ST_USTRING) {\n\t\t\tret += fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\t} else\n\t\t\treturn -EILSEQ;\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t/* 4th stage: modify stored value if needed */\n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t/* the last stage: Loop on array */\n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_event_field",
          "args": [
            "arg->code",
            "rec"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "get_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "303-338",
          "snippet": "static unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "arg->dynamic"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int get_eprobe_size(struct trace_probe *tp, void *rec)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tunsigned long val;\n\n\t\t\tval = get_event_field(arg->code, rec);\n\t\t\tlen = process_fetch_insn_bottom(arg->code + 1, val, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_event_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "303-338",
    "snippet": "static unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic unsigned long get_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}"
  },
  {
    "function_name": "print_eprobe_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "265-301",
    "snippet": "static enum print_line_t\nprint_eprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct eprobe_trace_entry_head *field;\n\tstruct trace_event_call *pevent;\n\tstruct trace_event *probed_event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct eprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tprobed_event = ftrace_find_event(field->type);\n\tif (probed_event) {\n\t\tpevent = container_of(probed_event, struct trace_event_call, event);\n\t\ttrace_seq_printf(s, \"%s.%s\", pevent->class->system,\n\t\t\t\t trace_event_name(pevent));\n\t} else {\n\t\ttrace_seq_printf(s, \"%u\", field->type);\n\t}\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_probe_args",
          "args": [
            "s",
            "tp->args",
            "tp->nr_args",
            "(u8 *)&field[1]",
            "field"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "print_probe_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe_tmpl.h",
          "lines": "216-242",
          "snippet": "static inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);",
            "static nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "static nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic inline int\nprint_probe_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%u\"",
            "field->type"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "pevent"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "probed_event",
            "structtrace_event_call",
            "event"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_event",
          "args": [
            "field->type"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "676-689",
          "snippet": "struct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVENT_HASHSIZE\t128"
          ],
          "globals_used": [
            "static struct hlist_head event_hash[EVENT_HASHSIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "tp"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "container_of(event, struct trace_event_call, event)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structtrace_event_call",
            "event"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum print_line_t\nprint_eprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct eprobe_trace_entry_head *field;\n\tstruct trace_event_call *pevent;\n\tstruct trace_event *probed_event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct eprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tprobed_event = ftrace_find_event(field->type);\n\tif (probed_event) {\n\t\tpevent = container_of(probed_event, struct trace_event_call, event);\n\t\ttrace_seq_printf(s, \"%s.%s\", pevent->class->system,\n\t\t\t\t trace_event_name(pevent));\n\t} else {\n\t\ttrace_seq_printf(s, \"%u\", field->type);\n\t}\n\n\ttrace_seq_putc(s, ')');\n\n\tif (print_probe_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "eprobe_event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "243-256",
    "snippet": "static int eprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct eprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned int, type, FIELD_STRING_TYPE, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceprobe_define_arg_fields",
          "args": [
            "event_call",
            "sizeof(field)",
            "tp"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_define_arg_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "954-977",
          "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_primary_from_call",
          "args": [
            "event_call"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_primary_from_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "301-307",
          "snippet": "static inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry(&tpe->probes, struct trace_probe, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct eprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned int, type, FIELD_STRING_TYPE, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}"
  },
  {
    "function_name": "trace_eprobe_tp_arg_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "224-241",
    "snippet": "static int trace_eprobe_tp_arg_update(struct trace_eprobe *ep, int i)\n{\n\tstruct probe_arg *parg = &ep->tp.args[i];\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(ep->event);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(parg->code->data, field->name)) {\n\t\t\tkfree(parg->code->data);\n\t\t\tparg->code->data = field;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tkfree(parg->code->data);\n\tparg->code->data = NULL;\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "parg->code->data"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->code->data",
            "field->name"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "field",
            "head",
            "link"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "ep->event"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int trace_eprobe_tp_arg_update(struct trace_eprobe *ep, int i)\n{\n\tstruct probe_arg *parg = &ep->tp.args[i];\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(ep->event);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(parg->code->data, field->name)) {\n\t\t\tkfree(parg->code->data);\n\t\t\tparg->code->data = field;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tkfree(parg->code->data);\n\tparg->code->data = NULL;\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "alloc_event_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "184-222",
    "snippet": "static struct trace_eprobe *alloc_event_probe(const char *group,\n\t\t\t\t\t      const char *this_event,\n\t\t\t\t\t      struct trace_event_call *event,\n\t\t\t\t\t      int nargs)\n{\n\tstruct trace_eprobe *ep;\n\tconst char *event_name;\n\tconst char *sys_name;\n\tint ret = -ENOMEM;\n\n\tif (!event)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsys_name = event->class->system;\n\tevent_name = trace_event_name(event);\n\n\tep = kzalloc(struct_size(ep, tp.args, nargs), GFP_KERNEL);\n\tif (!ep) {\n\t\ttrace_event_put_ref(event);\n\t\tgoto error;\n\t}\n\tep->event = event;\n\tep->event_name = kstrdup(event_name, GFP_KERNEL);\n\tif (!ep->event_name)\n\t\tgoto error;\n\tep->event_system = kstrdup(sys_name, GFP_KERNEL);\n\tif (!ep->event_system)\n\t\tgoto error;\n\n\tret = trace_probe_init(&ep->tp, this_event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&ep->devent, &eprobe_dyn_event_ops);\n\treturn ep;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_probe_cleanup",
          "args": [
            "ep"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "42-52",
          "snippet": "static void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_init",
          "args": [
            "&ep->devent",
            "&eprobe_dyn_event_ops"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "68-77",
          "snippet": "static inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_init",
          "args": [
            "&ep->tp",
            "this_event",
            "group",
            "false"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1020-1062",
          "snippet": "int trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sys_name",
            "GFP_KERNEL"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event_name",
            "GFP_KERNEL"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "event"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(ep, tp.args, nargs)",
            "GFP_KERNEL"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "ep",
            "tp.args",
            "nargs"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "event"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};\n\nstatic struct trace_eprobe *alloc_event_probe(const char *group,\n\t\t\t\t\t      const char *this_event,\n\t\t\t\t\t      struct trace_event_call *event,\n\t\t\t\t\t      int nargs)\n{\n\tstruct trace_eprobe *ep;\n\tconst char *event_name;\n\tconst char *sys_name;\n\tint ret = -ENOMEM;\n\n\tif (!event)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsys_name = event->class->system;\n\tevent_name = trace_event_name(event);\n\n\tep = kzalloc(struct_size(ep, tp.args, nargs), GFP_KERNEL);\n\tif (!ep) {\n\t\ttrace_event_put_ref(event);\n\t\tgoto error;\n\t}\n\tep->event = event;\n\tep->event_name = kstrdup(event_name, GFP_KERNEL);\n\tif (!ep->event_name)\n\t\tgoto error;\n\tep->event_system = kstrdup(sys_name, GFP_KERNEL);\n\tif (!ep->event_system)\n\t\tgoto error;\n\n\tret = trace_probe_init(&ep->tp, this_event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&ep->devent, &eprobe_dyn_event_ops);\n\treturn ep;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "eprobe_dyn_event_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "118-174",
    "snippet": "static bool eprobe_dyn_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tconst char *slash;\n\n\t/*\n\t * We match the following:\n\t *  event only\t\t\t- match all eprobes with event name\n\t *  system and event only\t- match all system/event probes\n\t *\n\t * The below has the above satisfied with more arguments:\n\t *\n\t *  attached system/event\t- If the arg has the system and event\n\t *\t\t\t\t  the probe is attached to, match\n\t *\t\t\t\t  probes with the attachment.\n\t *\n\t *  If any more args are given, then it requires a full match.\n\t */\n\n\t/*\n\t * If system exists, but this probe is not part of that system\n\t * do not match.\n\t */\n\tif (system && strcmp(trace_probe_group_name(&ep->tp), system) != 0)\n\t\treturn false;\n\n\t/* Must match the event name */\n\tif (strcmp(trace_probe_name(&ep->tp), event) != 0)\n\t\treturn false;\n\n\t/* No arguments match all */\n\tif (argc < 1)\n\t\treturn true;\n\n\t/* First argument is the system/event the probe is attached to */\n\n\tslash = strchr(argv[0], '/');\n\tif (!slash)\n\t\tslash = strchr(argv[0], '.');\n\tif (!slash)\n\t\treturn false;\n\n\tif (strncmp(ep->event_system, argv[0], slash - argv[0]))\n\t\treturn false;\n\tif (strcmp(ep->event_name, slash + 1))\n\t\treturn false;\n\n\targc--;\n\targv++;\n\n\t/* If there are no other args, then match */\n\tif (argc < 1)\n\t\treturn true;\n\n\treturn trace_probe_match_command_args(&ep->tp, argc, argv);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __trace_eprobe_create(int argc, const char *argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_match_command_args",
          "args": [
            "&ep->tp",
            "argc",
            "argv"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_match_command_args",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1176-1192",
          "snippet": "bool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ep->event_name",
            "slash + 1"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ep->event_system",
            "argv[0]",
            "slash - argv[0]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[0]",
            "'.'"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&ep->tp"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&ep->tp"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_eprobe",
          "args": [
            "ev"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "54-57",
          "snippet": "static struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int __trace_eprobe_create(int argc, const char *argv[]);\n\nstatic bool eprobe_dyn_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tconst char *slash;\n\n\t/*\n\t * We match the following:\n\t *  event only\t\t\t- match all eprobes with event name\n\t *  system and event only\t- match all system/event probes\n\t *\n\t * The below has the above satisfied with more arguments:\n\t *\n\t *  attached system/event\t- If the arg has the system and event\n\t *\t\t\t\t  the probe is attached to, match\n\t *\t\t\t\t  probes with the attachment.\n\t *\n\t *  If any more args are given, then it requires a full match.\n\t */\n\n\t/*\n\t * If system exists, but this probe is not part of that system\n\t * do not match.\n\t */\n\tif (system && strcmp(trace_probe_group_name(&ep->tp), system) != 0)\n\t\treturn false;\n\n\t/* Must match the event name */\n\tif (strcmp(trace_probe_name(&ep->tp), event) != 0)\n\t\treturn false;\n\n\t/* No arguments match all */\n\tif (argc < 1)\n\t\treturn true;\n\n\t/* First argument is the system/event the probe is attached to */\n\n\tslash = strchr(argv[0], '/');\n\tif (!slash)\n\t\tslash = strchr(argv[0], '.');\n\tif (!slash)\n\t\treturn false;\n\n\tif (strncmp(ep->event_system, argv[0], slash - argv[0]))\n\t\treturn false;\n\tif (strcmp(ep->event_name, slash + 1))\n\t\treturn false;\n\n\targc--;\n\targv++;\n\n\t/* If there are no other args, then match */\n\tif (argc < 1)\n\t\treturn true;\n\n\treturn trace_probe_match_command_args(&ep->tp, argc, argv);\n}"
  },
  {
    "function_name": "eprobe_dyn_event_is_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "111-116",
    "snippet": "static bool eprobe_dyn_event_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\n\treturn trace_probe_is_enabled(&ep->tp);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&ep->tp"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_eprobe",
          "args": [
            "ev"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "54-57",
          "snippet": "static struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic bool eprobe_dyn_event_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\n\treturn trace_probe_is_enabled(&ep->tp);\n}"
  },
  {
    "function_name": "eprobe_dyn_event_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "101-109",
    "snippet": "static int eprobe_dyn_event_release(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint ret = unregister_trace_eprobe(ep);\n\n\tif (!ret)\n\t\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_probe_cleanup",
          "args": [
            "ep"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "42-52",
          "snippet": "static void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_trace_eprobe",
          "args": [
            "ep"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "80-99",
          "snippet": "static int unregister_trace_eprobe(struct trace_eprobe *ep)\n{\n\t/* If other probes are on the event, just unregister eprobe */\n\tif (trace_probe_has_sibling(&ep->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&ep->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (trace_probe_unregister_event_call(&ep->tp))\n\t\treturn -EBUSY;\n\nunreg:\n\tdyn_event_remove(&ep->devent);\n\ttrace_probe_unlink(&ep->tp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int unregister_trace_eprobe(struct trace_eprobe *ep)\n{\n\t/* If other probes are on the event, just unregister eprobe */\n\tif (trace_probe_has_sibling(&ep->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&ep->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (trace_probe_unregister_event_call(&ep->tp))\n\t\treturn -EBUSY;\n\nunreg:\n\tdyn_event_remove(&ep->devent);\n\ttrace_probe_unlink(&ep->tp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_eprobe",
          "args": [
            "ev"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "54-57",
          "snippet": "static struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_dyn_event_release(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint ret = unregister_trace_eprobe(ep);\n\n\tif (!ret)\n\t\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trace_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "80-99",
    "snippet": "static int unregister_trace_eprobe(struct trace_eprobe *ep)\n{\n\t/* If other probes are on the event, just unregister eprobe */\n\tif (trace_probe_has_sibling(&ep->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&ep->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (trace_probe_unregister_event_call(&ep->tp))\n\t\treturn -EBUSY;\n\nunreg:\n\tdyn_event_remove(&ep->devent);\n\ttrace_probe_unlink(&ep->tp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_unlink",
          "args": [
            "&ep->tp"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1001-1007",
          "snippet": "void trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_remove",
          "args": [
            "&ep->devent"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "92-96",
          "snippet": "static inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_unregister_event_call",
          "args": [
            "&ep->tp"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_unregister_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "321-325",
          "snippet": "static inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t/* tp->event is unregistered in trace_remove_event_call() */\n\treturn trace_remove_event_call(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_is_enabled",
          "args": [
            "&ep->tp"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_is_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "274-277",
          "snippet": "static inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [
            "#define TP_FLAG_PROFILE\t\t2",
            "#define TP_FLAG_TRACE\t\t1"
          ],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#define TP_FLAG_PROFILE\t\t2\n#define TP_FLAG_TRACE\t\t1\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_has_sibling",
          "args": [
            "&ep->tp"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_has_sibling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "314-319",
          "snippet": "static inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int unregister_trace_eprobe(struct trace_eprobe *ep)\n{\n\t/* If other probes are on the event, just unregister eprobe */\n\tif (trace_probe_has_sibling(&ep->tp))\n\t\tgoto unreg;\n\n\t/* Enabled event can not be unregistered */\n\tif (trace_probe_is_enabled(&ep->tp))\n\t\treturn -EBUSY;\n\n\t/* Will fail if probe is being used by ftrace or perf */\n\tif (trace_probe_unregister_event_call(&ep->tp))\n\t\treturn -EBUSY;\n\nunreg:\n\tdyn_event_remove(&ep->devent);\n\ttrace_probe_unlink(&ep->tp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eprobe_dyn_event_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "64-78",
    "snippet": "static int eprobe_dyn_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint i;\n\n\tseq_printf(m, \"e:%s/%s\", trace_probe_group_name(&ep->tp),\n\t\t\t\ttrace_probe_name(&ep->tp));\n\tseq_printf(m, \" %s.%s\", ep->event_system, ep->event_name);\n\n\tfor (i = 0; i < ep->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", ep->tp.args[i].name, ep->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s=%s\"",
            "ep->tp.args[i].name",
            "ep->tp.args[i].comm"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_name",
          "args": [
            "&ep->tp"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "279-282",
          "snippet": "static inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_probe_group_name",
          "args": [
            "&ep->tp"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_group_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.h",
          "lines": "284-287",
          "snippet": "static inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void trace_probe_cleanup(struct trace_probe *tp);",
            "void trace_probe_unlink(struct trace_probe *tp);",
            "int trace_probe_register_event_call(struct trace_probe *tp);",
            "extern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nvoid trace_probe_cleanup(struct trace_probe *tp);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_trace_eprobe",
          "args": [
            "ev"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "to_trace_eprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "54-57",
          "snippet": "static struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_dyn_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint i;\n\n\tseq_printf(m, \"e:%s/%s\", trace_probe_group_name(&ep->tp),\n\t\t\t\ttrace_probe_name(&ep->tp));\n\tseq_printf(m, \" %s.%s\", ep->event_system, ep->event_name);\n\n\tfor (i = 0; i < ep->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", ep->tp.args[i].name, ep->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eprobe_dyn_event_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "59-62",
    "snippet": "static int eprobe_dyn_event_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_eprobe_create);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_probe_create",
          "args": [
            "raw_command",
            "__trace_eprobe_create"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1194-1209",
          "snippet": "int trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int eprobe_dyn_event_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_eprobe_create);\n}"
  },
  {
    "function_name": "to_trace_eprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "54-57",
    "snippet": "static struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ev",
            "structtrace_eprobe",
            "devent"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}"
  },
  {
    "function_name": "trace_event_probe_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
    "lines": "42-52",
    "snippet": "static void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}",
    "includes": [
      "#include \"trace_probe_tmpl.h\"",
      "#include \"trace_probe.h\"",
      "#include \"trace_dynevent.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ep"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "ep->event"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_probe_cleanup",
          "args": [
            "&ep->tp"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "trace_probe_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_probe.c",
          "lines": "1009-1018",
          "snippet": "void trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep);\n}"
  }
]