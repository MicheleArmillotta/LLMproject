[
  {
    "function_name": "trace_pid_list_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "457-495",
    "snippet": "void trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pid_list"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&pid_list->refill_irqwork"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "276-290",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\tmight_sleep();\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt()) {\n\t\trcuwait_wait_event(&work->irqwait, !irq_work_is_busy(work),\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\t\treturn;\n\t}\n\n\twhile (irq_work_is_busy(work))\n\t\tcpu_relax();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nvoid trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}"
  },
  {
    "function_name": "trace_pid_list_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "411-450",
    "snippet": "struct trace_pid_list *trace_pid_list_alloc(void)\n{\n\tstruct trace_pid_list *pid_list;\n\tint i;\n\n\t/* According to linux/thread.h, pids can be no bigger that 30 bits */\n\tWARN_ON_ONCE(pid_max > (1 << 30));\n\n\tpid_list = kzalloc(sizeof(*pid_list), GFP_KERNEL);\n\tif (!pid_list)\n\t\treturn NULL;\n\n\tinit_irq_work(&pid_list->refill_irqwork, pid_list_refill_irq);\n\n\traw_spin_lock_init(&pid_list->lock);\n\n\tfor (i = 0; i < CHUNK_ALLOC; i++) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\tchunk->next = pid_list->upper_list;\n\t\tpid_list->upper_list = chunk;\n\t\tpid_list->free_upper_chunks++;\n\t}\n\n\tfor (i = 0; i < CHUNK_ALLOC; i++) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\tchunk->next = pid_list->lower_list;\n\t\tpid_list->lower_list = chunk;\n\t\tpid_list->free_lower_chunks++;\n\t}\n\n\treturn pid_list;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*chunk)",
            "GFP_KERNEL"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*chunk)",
            "GFP_KERNEL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&pid_list->lock"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&pid_list->refill_irqwork",
            "pid_list_refill_irq"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pid_list)",
            "GFP_KERNEL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pid_max > (1 << 30)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstruct trace_pid_list *trace_pid_list_alloc(void)\n{\n\tstruct trace_pid_list *pid_list;\n\tint i;\n\n\t/* According to linux/thread.h, pids can be no bigger that 30 bits */\n\tWARN_ON_ONCE(pid_max > (1 << 30));\n\n\tpid_list = kzalloc(sizeof(*pid_list), GFP_KERNEL);\n\tif (!pid_list)\n\t\treturn NULL;\n\n\tinit_irq_work(&pid_list->refill_irqwork, pid_list_refill_irq);\n\n\traw_spin_lock_init(&pid_list->lock);\n\n\tfor (i = 0; i < CHUNK_ALLOC; i++) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\tchunk->next = pid_list->upper_list;\n\t\tpid_list->upper_list = chunk;\n\t\tpid_list->free_upper_chunks++;\n\t}\n\n\tfor (i = 0; i < CHUNK_ALLOC; i++) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\tchunk->next = pid_list->lower_list;\n\t\tpid_list->lower_list = chunk;\n\t\tpid_list->free_lower_chunks++;\n\t}\n\n\treturn pid_list;\n}"
  },
  {
    "function_name": "pid_list_refill_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "332-402",
    "snippet": "static void pid_list_refill_irq(struct irq_work *iwork)\n{\n\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,\n\t\t\t\t\t\t       refill_irqwork);\n\tunion upper_chunk *upper = NULL;\n\tunion lower_chunk *lower = NULL;\n\tunion upper_chunk **upper_next = &upper;\n\tunion lower_chunk **lower_next = &lower;\n\tint upper_count;\n\tint lower_count;\n\tint ucnt = 0;\n\tint lcnt = 0;\n\n again:\n\traw_spin_lock(&pid_list->lock);\n\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;\n\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;\n\traw_spin_unlock(&pid_list->lock);\n\n\tif (upper_count <= 0 && lower_count <= 0)\n\t\treturn;\n\n\twhile (upper_count-- > 0) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\t*upper_next = chunk;\n\t\tupper_next = &chunk->next;\n\t\tucnt++;\n\t}\n\n\twhile (lower_count-- > 0) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\t*lower_next = chunk;\n\t\tlower_next = &chunk->next;\n\t\tlcnt++;\n\t}\n\n\traw_spin_lock(&pid_list->lock);\n\tif (upper) {\n\t\t*upper_next = pid_list->upper_list;\n\t\tpid_list->upper_list = upper;\n\t\tpid_list->free_upper_chunks += ucnt;\n\t}\n\tif (lower) {\n\t\t*lower_next = pid_list->lower_list;\n\t\tpid_list->lower_list = lower;\n\t\tpid_list->free_lower_chunks += lcnt;\n\t}\n\traw_spin_unlock(&pid_list->lock);\n\n\t/*\n\t * On success of allocating all the chunks, both counters\n\t * will be less than zero. If they are not, then an allocation\n\t * failed, and we should not try again.\n\t */\n\tif (upper_count >= 0 || lower_count >= 0)\n\t\treturn;\n\t/*\n\t * When the locks were released, free chunks could have\n\t * been used and allocation needs to be done again. Might as\n\t * well allocate it now.\n\t */\n\tgoto again;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&pid_list->lock"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&pid_list->lock"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*chunk)",
            "GFP_KERNEL"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*chunk)",
            "GFP_KERNEL"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "iwork",
            "structtrace_pid_list",
            "refill_irqwork"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic void pid_list_refill_irq(struct irq_work *iwork)\n{\n\tstruct trace_pid_list *pid_list = container_of(iwork, struct trace_pid_list,\n\t\t\t\t\t\t       refill_irqwork);\n\tunion upper_chunk *upper = NULL;\n\tunion lower_chunk *lower = NULL;\n\tunion upper_chunk **upper_next = &upper;\n\tunion lower_chunk **lower_next = &lower;\n\tint upper_count;\n\tint lower_count;\n\tint ucnt = 0;\n\tint lcnt = 0;\n\n again:\n\traw_spin_lock(&pid_list->lock);\n\tupper_count = CHUNK_ALLOC - pid_list->free_upper_chunks;\n\tlower_count = CHUNK_ALLOC - pid_list->free_lower_chunks;\n\traw_spin_unlock(&pid_list->lock);\n\n\tif (upper_count <= 0 && lower_count <= 0)\n\t\treturn;\n\n\twhile (upper_count-- > 0) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\t*upper_next = chunk;\n\t\tupper_next = &chunk->next;\n\t\tucnt++;\n\t}\n\n\twhile (lower_count-- > 0) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\t\tif (!chunk)\n\t\t\tbreak;\n\t\t*lower_next = chunk;\n\t\tlower_next = &chunk->next;\n\t\tlcnt++;\n\t}\n\n\traw_spin_lock(&pid_list->lock);\n\tif (upper) {\n\t\t*upper_next = pid_list->upper_list;\n\t\tpid_list->upper_list = upper;\n\t\tpid_list->free_upper_chunks += ucnt;\n\t}\n\tif (lower) {\n\t\t*lower_next = pid_list->lower_list;\n\t\tpid_list->lower_list = lower;\n\t\tpid_list->free_lower_chunks += lcnt;\n\t}\n\traw_spin_unlock(&pid_list->lock);\n\n\t/*\n\t * On success of allocating all the chunks, both counters\n\t * will be less than zero. If they are not, then an allocation\n\t * failed, and we should not try again.\n\t */\n\tif (upper_count >= 0 || lower_count >= 0)\n\t\treturn;\n\t/*\n\t * When the locks were released, free chunks could have\n\t * been used and allocation needs to be done again. Might as\n\t * well allocate it now.\n\t */\n\tgoto again;\n}"
  },
  {
    "function_name": "trace_pid_list_first",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "327-330",
    "snippet": "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)\n{\n\treturn trace_pid_list_next(pid_list, 0, pid);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_list_next",
          "args": [
            "pid_list",
            "0",
            "pid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "273-315",
          "snippet": "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,\n\t\t\tunsigned int *next)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {\n\t\tupper_chunk = pid_list->upper[upper1];\n\n\t\tif (!upper_chunk)\n\t\t\tcontinue;\n\n\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {\n\t\t\tlower_chunk = upper_chunk->data[upper2];\n\t\t\tif (!lower_chunk)\n\t\t\t\tcontinue;\n\n\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,\n\t\t\t\t\t    lower);\n\t\t\tif (lower < LOWER_MAX)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n found:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\tif (upper1 > UPPER_MASK)\n\t\treturn -1;\n\n\t*next = pid_join(upper1, upper2, lower);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,\n\t\t\tunsigned int *next)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {\n\t\tupper_chunk = pid_list->upper[upper1];\n\n\t\tif (!upper_chunk)\n\t\t\tcontinue;\n\n\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {\n\t\t\tlower_chunk = upper_chunk->data[upper2];\n\t\t\tif (!lower_chunk)\n\t\t\t\tcontinue;\n\n\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,\n\t\t\t\t\t    lower);\n\t\t\tif (lower < LOWER_MAX)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n found:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\tif (upper1 > UPPER_MASK)\n\t\treturn -1;\n\n\t*next = pid_join(upper1, upper2, lower);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)\n{\n\treturn trace_pid_list_next(pid_list, 0, pid);\n}"
  },
  {
    "function_name": "trace_pid_list_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "273-315",
    "snippet": "int trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,\n\t\t\tunsigned int *next)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {\n\t\tupper_chunk = pid_list->upper[upper1];\n\n\t\tif (!upper_chunk)\n\t\t\tcontinue;\n\n\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {\n\t\t\tlower_chunk = upper_chunk->data[upper2];\n\t\t\tif (!lower_chunk)\n\t\t\t\tcontinue;\n\n\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,\n\t\t\t\t\t    lower);\n\t\t\tif (lower < LOWER_MAX)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n found:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\tif (upper1 > UPPER_MASK)\n\t\treturn -1;\n\n\t*next = pid_join(upper1, upper2, lower);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_join",
          "args": [
            "upper1",
            "upper2",
            "lower"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "pid_join",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "110-116",
          "snippet": "static inline unsigned int pid_join(unsigned int upper1,\n\t\t\t\t    unsigned int upper2, unsigned int lower)\n{\n\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |\n\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |\n\t\t(lower & LOWER_MASK);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int pid_join(unsigned int upper1,\n\t\t\t\t    unsigned int upper2, unsigned int lower)\n{\n\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |\n\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |\n\t\t(lower & LOWER_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "lower_chunk->data",
            "LOWER_MAX",
            "lower"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_split",
          "args": [
            "pid",
            "&upper1",
            "&upper2",
            "&lower"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pid_split",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "93-108",
          "snippet": "static inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_next(struct trace_pid_list *pid_list, unsigned int pid,\n\t\t\tunsigned int *next)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tfor (; upper1 <= UPPER_MASK; upper1++, upper2 = 0) {\n\t\tupper_chunk = pid_list->upper[upper1];\n\n\t\tif (!upper_chunk)\n\t\t\tcontinue;\n\n\t\tfor (; upper2 <= UPPER_MASK; upper2++, lower = 0) {\n\t\t\tlower_chunk = upper_chunk->data[upper2];\n\t\t\tif (!lower_chunk)\n\t\t\t\tcontinue;\n\n\t\t\tlower = find_next_bit(lower_chunk->data, LOWER_MAX,\n\t\t\t\t\t    lower);\n\t\t\tif (lower < LOWER_MAX)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n found:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\tif (upper1 > UPPER_MASK)\n\t\treturn -1;\n\n\t*next = pid_join(upper1, upper2, lower);\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_pid_list_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "221-259",
    "snippet": "int trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (!upper_chunk)\n\t\tgoto out;\n\n\tlower_chunk = upper_chunk->data[upper2];\n\tif (!lower_chunk)\n\t\tgoto out;\n\n\tclear_bit(lower, lower_chunk->data);\n\n\t/* if there's no more bits set, add it to the free list */\n\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {\n\t\tput_lower_chunk(pid_list, lower_chunk);\n\t\tupper_chunk->data[upper2] = NULL;\n\t\tif (upper_empty(upper_chunk)) {\n\t\t\tput_upper_chunk(pid_list, upper_chunk);\n\t\t\tpid_list->upper[upper1] = NULL;\n\t\t}\n\t}\n out:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_upper_chunk",
          "args": [
            "pid_list",
            "upper_chunk"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "put_upper_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "70-78",
          "snippet": "static inline void put_upper_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union upper_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->upper_list;\n\tpid_list->upper_list = chunk;\n\tpid_list->free_upper_chunks++;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline void put_upper_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union upper_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->upper_list;\n\tpid_list->upper_list = chunk;\n\tpid_list->free_upper_chunks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "upper_empty",
          "args": [
            "upper_chunk"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "upper_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "80-91",
          "snippet": "static inline bool upper_empty(union upper_chunk *chunk)\n{\n\t/*\n\t * If chunk->data has no lower chunks, it will be the same\n\t * as a zeroed bitmask. Use find_first_bit() to test it\n\t * and if it doesn't find any bits set, then the array\n\t * is empty.\n\t */\n\tint bit = find_first_bit((unsigned long *)chunk->data,\n\t\t\t\t sizeof(chunk->data) * 8);\n\treturn bit >= sizeof(chunk->data) * 8;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline bool upper_empty(union upper_chunk *chunk)\n{\n\t/*\n\t * If chunk->data has no lower chunks, it will be the same\n\t * as a zeroed bitmask. Use find_first_bit() to test it\n\t * and if it doesn't find any bits set, then the array\n\t * is empty.\n\t */\n\tint bit = find_first_bit((unsigned long *)chunk->data,\n\t\t\t\t sizeof(chunk->data) * 8);\n\treturn bit >= sizeof(chunk->data) * 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_lower_chunk",
          "args": [
            "pid_list",
            "lower_chunk"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "put_lower_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "60-68",
          "snippet": "static inline void put_lower_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union lower_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->lower_list;\n\tpid_list->lower_list = chunk;\n\tpid_list->free_lower_chunks++;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline void put_lower_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union lower_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->lower_list;\n\tpid_list->lower_list = chunk;\n\tpid_list->free_lower_chunks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "lower_chunk->data",
            "LOWER_MAX"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "lower",
            "lower_chunk->data"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_split",
          "args": [
            "pid",
            "&upper1",
            "&upper2",
            "&lower"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "pid_split",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "93-108",
          "snippet": "static inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_clear(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (!upper_chunk)\n\t\tgoto out;\n\n\tlower_chunk = upper_chunk->data[upper2];\n\tif (!lower_chunk)\n\t\tgoto out;\n\n\tclear_bit(lower, lower_chunk->data);\n\n\t/* if there's no more bits set, add it to the free list */\n\tif (find_first_bit(lower_chunk->data, LOWER_MAX) >= LOWER_MAX) {\n\t\tput_lower_chunk(pid_list, lower_chunk);\n\t\tupper_chunk->data[upper2] = NULL;\n\t\tif (upper_empty(upper_chunk)) {\n\t\t\tput_upper_chunk(pid_list, upper_chunk);\n\t\t\tpid_list->upper[upper1] = NULL;\n\t\t}\n\t}\n out:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_pid_list_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "168-208",
    "snippet": "int trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\tint ret;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (!upper_chunk) {\n\t\tupper_chunk = get_upper_chunk(pid_list);\n\t\tif (!upper_chunk) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpid_list->upper[upper1] = upper_chunk;\n\t}\n\tlower_chunk = upper_chunk->data[upper2];\n\tif (!lower_chunk) {\n\t\tlower_chunk = get_lower_chunk(pid_list);\n\t\tif (!lower_chunk) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tupper_chunk->data[upper2] = lower_chunk;\n\t}\n\tset_bit(lower, lower_chunk->data);\n\tret = 0;\n out:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "lower",
            "lower_chunk->data"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lower_chunk",
          "args": [
            "pid_list"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "get_lower_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "12-34",
          "snippet": "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)\n{\n\tunion lower_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->lower_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->lower_list;\n\tpid_list->lower_list = chunk->next;\n\tpid_list->free_lower_chunks--;\n\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)\n{\n\tunion lower_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->lower_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->lower_list;\n\tpid_list->lower_list = chunk->next;\n\tpid_list->free_lower_chunks--;\n\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_upper_chunk",
          "args": [
            "pid_list"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "get_upper_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "36-58",
          "snippet": "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->upper_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->upper_list;\n\tpid_list->upper_list = chunk->next;\n\tpid_list->free_upper_chunks--;\n\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->upper_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->upper_list;\n\tpid_list->upper_list = chunk->next;\n\tpid_list->free_upper_chunks--;\n\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_split",
          "args": [
            "pid",
            "&upper1",
            "&upper2",
            "&lower"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "pid_split",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "93-108",
          "snippet": "static inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_set(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\tint ret;\n\n\tif (!pid_list)\n\t\treturn -ENODEV;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (!upper_chunk) {\n\t\tupper_chunk = get_upper_chunk(pid_list);\n\t\tif (!upper_chunk) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpid_list->upper[upper1] = upper_chunk;\n\t}\n\tlower_chunk = upper_chunk->data[upper2];\n\tif (!lower_chunk) {\n\t\tlower_chunk = get_lower_chunk(pid_list);\n\t\tif (!lower_chunk) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tupper_chunk->data[upper2] = lower_chunk;\n\t}\n\tset_bit(lower, lower_chunk->data);\n\tret = 0;\n out:\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_pid_list_is_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "129-155",
    "snippet": "bool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\tbool ret = false;\n\n\tif (!pid_list)\n\t\treturn false;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (upper_chunk) {\n\t\tlower_chunk = upper_chunk->data[upper2];\n\t\tif (lower_chunk)\n\t\t\tret = test_bit(lower, lower_chunk->data);\n\t}\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "lower",
            "lower_chunk->data"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pid_list->lock",
            "flags"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_split",
          "args": [
            "pid",
            "&upper1",
            "&upper2",
            "&lower"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "pid_split",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "93-108",
          "snippet": "static inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nbool trace_pid_list_is_set(struct trace_pid_list *pid_list, unsigned int pid)\n{\n\tunion upper_chunk *upper_chunk;\n\tunion lower_chunk *lower_chunk;\n\tunsigned long flags;\n\tunsigned int upper1;\n\tunsigned int upper2;\n\tunsigned int lower;\n\tbool ret = false;\n\n\tif (!pid_list)\n\t\treturn false;\n\n\tif (pid_split(pid, &upper1, &upper2, &lower) < 0)\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&pid_list->lock, flags);\n\tupper_chunk = pid_list->upper[upper1];\n\tif (upper_chunk) {\n\t\tlower_chunk = upper_chunk->data[upper2];\n\t\tif (lower_chunk)\n\t\t\tret = test_bit(lower, lower_chunk->data);\n\t}\n\traw_spin_unlock_irqrestore(&pid_list->lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pid_join",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "110-116",
    "snippet": "static inline unsigned int pid_join(unsigned int upper1,\n\t\t\t\t    unsigned int upper2, unsigned int lower)\n{\n\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |\n\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |\n\t\t(lower & LOWER_MASK);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int pid_join(unsigned int upper1,\n\t\t\t\t    unsigned int upper2, unsigned int lower)\n{\n\treturn ((upper1 & UPPER_MASK) << UPPER1_SHIFT) |\n\t\t((upper2 & UPPER_MASK) << UPPER2_SHIFT) |\n\t\t(lower & LOWER_MASK);\n}"
  },
  {
    "function_name": "pid_split",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "93-108",
    "snippet": "static inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pid >= MAX_PID"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MAX_PID < PID_MAX_LIMIT"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline int pid_split(unsigned int pid, unsigned int *upper1,\n\t\t\t     unsigned int *upper2, unsigned int *lower)\n{\n\t/* MAX_PID should cover all pids */\n\tBUILD_BUG_ON(MAX_PID < PID_MAX_LIMIT);\n\n\t/* In case a bad pid is passed in, then fail */\n\tif (unlikely(pid >= MAX_PID))\n\t\treturn -1;\n\n\t*upper1 = (pid >> UPPER1_SHIFT) & UPPER_MASK;\n\t*upper2 = (pid >> UPPER2_SHIFT) & UPPER_MASK;\n\t*lower = pid & LOWER_MASK;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "upper_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "80-91",
    "snippet": "static inline bool upper_empty(union upper_chunk *chunk)\n{\n\t/*\n\t * If chunk->data has no lower chunks, it will be the same\n\t * as a zeroed bitmask. Use find_first_bit() to test it\n\t * and if it doesn't find any bits set, then the array\n\t * is empty.\n\t */\n\tint bit = find_first_bit((unsigned long *)chunk->data,\n\t\t\t\t sizeof(chunk->data) * 8);\n\treturn bit >= sizeof(chunk->data) * 8;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "(unsigned long *)chunk->data",
            "sizeof(chunk->data) * 8"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline bool upper_empty(union upper_chunk *chunk)\n{\n\t/*\n\t * If chunk->data has no lower chunks, it will be the same\n\t * as a zeroed bitmask. Use find_first_bit() to test it\n\t * and if it doesn't find any bits set, then the array\n\t * is empty.\n\t */\n\tint bit = find_first_bit((unsigned long *)chunk->data,\n\t\t\t\t sizeof(chunk->data) * 8);\n\treturn bit >= sizeof(chunk->data) * 8;\n}"
  },
  {
    "function_name": "put_upper_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "70-78",
    "snippet": "static inline void put_upper_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union upper_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->upper_list;\n\tpid_list->upper_list = chunk;\n\tpid_list->free_upper_chunks++;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pid_list->lock"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline void put_upper_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union upper_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->upper_list;\n\tpid_list->upper_list = chunk;\n\tpid_list->free_upper_chunks++;\n}"
  },
  {
    "function_name": "put_lower_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "60-68",
    "snippet": "static inline void put_lower_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union lower_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->lower_list;\n\tpid_list->lower_list = chunk;\n\tpid_list->free_lower_chunks++;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pid_list->lock"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline void put_lower_chunk(struct trace_pid_list *pid_list,\n\t\t\t\t   union lower_chunk *chunk)\n{\n\tlockdep_assert_held(&pid_list->lock);\n\n\tchunk->next = pid_list->lower_list;\n\tpid_list->lower_list = chunk;\n\tpid_list->free_lower_chunks++;\n}"
  },
  {
    "function_name": "get_upper_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "36-58",
    "snippet": "static inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->upper_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->upper_list;\n\tpid_list->upper_list = chunk->next;\n\tpid_list->free_upper_chunks--;\n\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&pid_list->refill_irqwork"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pid_list->free_upper_chunks < 0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pid_list->lock"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline union upper_chunk *get_upper_chunk(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->upper_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->upper_list;\n\tpid_list->upper_list = chunk->next;\n\tpid_list->free_upper_chunks--;\n\tWARN_ON_ONCE(pid_list->free_upper_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_upper_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}"
  },
  {
    "function_name": "get_lower_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
    "lines": "12-34",
    "snippet": "static inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)\n{\n\tunion lower_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->lower_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->lower_list;\n\tpid_list->lower_list = chunk->next;\n\tpid_list->free_lower_chunks--;\n\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/slab.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&pid_list->refill_irqwork"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pid_list->free_lower_chunks < 0"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pid_list->lock"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nstatic inline union lower_chunk *get_lower_chunk(struct trace_pid_list *pid_list)\n{\n\tunion lower_chunk *chunk;\n\n\tlockdep_assert_held(&pid_list->lock);\n\n\tif (!pid_list->lower_list)\n\t\treturn NULL;\n\n\tchunk = pid_list->lower_list;\n\tpid_list->lower_list = chunk->next;\n\tpid_list->free_lower_chunks--;\n\tWARN_ON_ONCE(pid_list->free_lower_chunks < 0);\n\tchunk->next = NULL;\n\t/*\n\t * If a refill needs to happen, it can not happen here\n\t * as the scheduler run queue locks are held.\n\t */\n\tif (pid_list->free_lower_chunks <= CHUNK_REALLOC)\n\t\tirq_work_queue(&pid_list->refill_irqwork);\n\n\treturn chunk;\n}"
  }
]